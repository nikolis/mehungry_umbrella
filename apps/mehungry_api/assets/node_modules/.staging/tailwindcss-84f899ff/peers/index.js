/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 69414:
/***/ ((__unused_webpack_module, exports) => {

;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            var parsedEntity = parseEntity(parser)

            // Custom entities can contain tags, so we potentially need to parse the result
            if (parser.state === S.TEXT_ENTITY && !sax.ENTITIES[parser.entity] && parsedEntity !== '&' + parser.entity + ';') {
              chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i)
            } else {
              parser[buffer] += parsedEntity
            }

            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }
})( false ? 0 : exports)


/***/ }),

/***/ 94135:
/***/ ((module) => {

var zero = '0'.charCodeAt(0);
var plus = '+'.charCodeAt(0);
var minus = '-'.charCodeAt(0);

function isWhitespace(code) {
	return code <= 32;
}

function isDigit(code) {
	return 48 <= code && code <= 57;
}

function isSign(code) {
	return code === minus || code === plus;
}

module.exports = function (opts, a, b) {
	var checkSign = opts.sign;
	var ia = 0;
	var ib = 0;
	var ma = a.length;
	var mb = b.length;
	var ca, cb; // character code
	var za, zb; // leading zero count
	var na, nb; // number length
	var sa, sb; // number sign
	var ta, tb; // temporary
	var bias;

	while (ia < ma && ib < mb) {
		ca = a.charCodeAt(ia);
		cb = b.charCodeAt(ib);
		za = zb = 0;
		na = nb = 0;
		sa = sb = true;
		bias = 0;

		// skip over leading spaces
		while (isWhitespace(ca)) {
			ia += 1;
			ca = a.charCodeAt(ia);
		}
		while (isWhitespace(cb)) {
			ib += 1;
			cb = b.charCodeAt(ib);
		}

		// skip and save sign
		if (checkSign) {
			ta = a.charCodeAt(ia + 1);
			if (isSign(ca) && isDigit(ta)) {
				if (ca === minus) {
					sa = false;
				}
				ia += 1;
				ca = ta;
			}
			tb = b.charCodeAt(ib + 1);
			if (isSign(cb) && isDigit(tb)) {
				if (cb === minus) {
					sb = false;
				}
				ib += 1;
				cb = tb;
			}
		}

		// compare digits with other symbols
		if (isDigit(ca) && !isDigit(cb)) {
			return -1;
		}
		if (!isDigit(ca) && isDigit(cb)) {
			return 1;
		}

		// compare negative and positive
		if (!sa && sb) {
			return -1;
		}
		if (sa && !sb) {
			return 1;
		}

		// count leading zeros
		while (ca === zero) {
			za += 1;
			ia += 1;
			ca = a.charCodeAt(ia);
		}
		while (cb === zero) {
			zb += 1;
			ib += 1;
			cb = b.charCodeAt(ib);
		}

		// count numbers
		while (isDigit(ca) || isDigit(cb)) {
			if (isDigit(ca) && isDigit(cb) && bias === 0) {
				if (sa) {
					if (ca < cb) {
						bias = -1;
					} else if (ca > cb) {
						bias = 1;
					}
				} else {
					if (ca > cb) {
						bias = -1;
					} else if (ca < cb) {
						bias = 1;
					}
				}
			}
			if (isDigit(ca)) {
				ia += 1;
				na += 1;
				ca = a.charCodeAt(ia);
			}
			if (isDigit(cb)) {
				ib += 1;
				nb += 1;
				cb = b.charCodeAt(ib);
			}
		}

		// compare number length
		if (sa) {
			if (na < nb) {
				return -1;
			}
			if (na > nb) {
				return 1;
			}
		} else {
			if (na > nb) {
				return -1;
			}
			if (na < nb) {
				return 1;
			}
		}

		// compare numbers
		if (bias) {
			return bias;
		}

		// compare leading zeros
		if (sa) {
			if (za > zb) {
				return -1;
			}
			if (za < zb) {
				return 1;
			}
		} else {
			if (za < zb) {
				return -1;
			}
			if (za > zb) {
				return 1;
			}
		}

		// compare ascii codes
		if (ca < cb) {
			return -1;
		}
		if (ca > cb) {
			return 1;
		}

		ia += 1;
		ib += 1;
	}

	// compare length
	if (ma < mb) {
		return -1;
	}
	if (ma > mb) {
		return 1;
	}
};


/***/ }),

/***/ 37910:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var compare = __nccwpck_require__(94135);

function mediator(a, b) {
	return compare(this, a.converted, b.converted);
}

module.exports = function (array, opts) {
	if (!Array.isArray(array) || array.length < 2) {
		return array;
	}
	if (typeof opts !== 'object') {
		opts = {};
	}
	opts.sign = !!opts.sign;
	var insensitive = !!opts.insensitive;
	var result = Array(array.length);
	var i, max, value;

	for (i = 0, max = array.length; i < max; i += 1) {
		value = String(array[i]);
		result[i] = {
			value: array[i],
			converted: insensitive ? value.toLowerCase() : value
		};
	}

	result.sort(mediator.bind(opts));

	for (i = result.length - 1; ~i; i -= 1) {
		result[i] = result[i].value;
	}

	return result;
};


/***/ }),

/***/ 79659:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let unpack = __nccwpck_require__(64006).feature

function browsersSort(a, b) {
  a = a.split(' ')
  b = b.split(' ')
  if (a[0] > b[0]) {
    return 1
  } else if (a[0] < b[0]) {
    return -1
  } else {
    return Math.sign(parseFloat(a[1]) - parseFloat(b[1]))
  }
}

// Convert Can I Use data
function f(data, opts, callback) {
  data = unpack(data)

  if (!callback) {
    ;[callback, opts] = [opts, {}]
  }

  let match = opts.match || /\sx($|\s)/
  let need = []

  for (let browser in data.stats) {
    let versions = data.stats[browser]
    for (let version in versions) {
      let support = versions[version]
      if (support.match(match)) {
        need.push(browser + ' ' + version)
      }
    }
  }

  callback(need.sort(browsersSort))
}

// Add data for all properties
let result = {}

function prefix(names, data) {
  for (let name of names) {
    result[name] = Object.assign({}, data)
  }
}

function add(names, data) {
  for (let name of names) {
    result[name].browsers = result[name].browsers
      .concat(data.browsers)
      .sort(browsersSort)
  }
}

module.exports = result

// Border Radius
let prefixBorderRadius = __nccwpck_require__(72853)

f(prefixBorderRadius, browsers =>
  prefix(
    [
      'border-radius',
      'border-top-left-radius',
      'border-top-right-radius',
      'border-bottom-right-radius',
      'border-bottom-left-radius'
    ],
    {
      mistakes: ['-khtml-', '-ms-', '-o-'],
      feature: 'border-radius',
      browsers
    }
  )
)

// Box Shadow
let prefixBoxshadow = __nccwpck_require__(22004)

f(prefixBoxshadow, browsers =>
  prefix(['box-shadow'], {
    mistakes: ['-khtml-'],
    feature: 'css-boxshadow',
    browsers
  })
)

// Animation
let prefixAnimation = __nccwpck_require__(40083)

f(prefixAnimation, browsers =>
  prefix(
    [
      'animation',
      'animation-name',
      'animation-duration',
      'animation-delay',
      'animation-direction',
      'animation-fill-mode',
      'animation-iteration-count',
      'animation-play-state',
      'animation-timing-function',
      '@keyframes'
    ],
    {
      mistakes: ['-khtml-', '-ms-'],
      feature: 'css-animation',
      browsers
    }
  )
)

// Transition
let prefixTransition = __nccwpck_require__(61964)

f(prefixTransition, browsers =>
  prefix(
    [
      'transition',
      'transition-property',
      'transition-duration',
      'transition-delay',
      'transition-timing-function'
    ],
    {
      mistakes: ['-khtml-', '-ms-'],
      browsers,
      feature: 'css-transitions'
    }
  )
)

// Transform 2D
let prefixTransform2d = __nccwpck_require__(98415)

f(prefixTransform2d, browsers =>
  prefix(['transform', 'transform-origin'], {
    feature: 'transforms2d',
    browsers
  })
)

// Transform 3D
let prefixTransforms3d = __nccwpck_require__(48912)

f(prefixTransforms3d, browsers => {
  prefix(['perspective', 'perspective-origin'], {
    feature: 'transforms3d',
    browsers
  })
  return prefix(['transform-style'], {
    mistakes: ['-ms-', '-o-'],
    browsers,
    feature: 'transforms3d'
  })
})

f(prefixTransforms3d, { match: /y\sx|y\s#2/ }, browsers =>
  prefix(['backface-visibility'], {
    mistakes: ['-ms-', '-o-'],
    feature: 'transforms3d',
    browsers
  })
)

// Gradients
let prefixGradients = __nccwpck_require__(13657)

f(prefixGradients, { match: /y\sx/ }, browsers =>
  prefix(
    [
      'linear-gradient',
      'repeating-linear-gradient',
      'radial-gradient',
      'repeating-radial-gradient'
    ],
    {
      props: [
        'background',
        'background-image',
        'border-image',
        'mask',
        'list-style',
        'list-style-image',
        'content',
        'mask-image'
      ],
      mistakes: ['-ms-'],
      feature: 'css-gradients',
      browsers
    }
  )
)

f(prefixGradients, { match: /a\sx/ }, browsers => {
  browsers = browsers.map(i => {
    if (/firefox|op/.test(i)) {
      return i
    } else {
      return `${i} old`
    }
  })
  return add(
    [
      'linear-gradient',
      'repeating-linear-gradient',
      'radial-gradient',
      'repeating-radial-gradient'
    ],
    {
      feature: 'css-gradients',
      browsers
    }
  )
})

// Box sizing
let prefixBoxsizing = __nccwpck_require__(47610)

f(prefixBoxsizing, browsers =>
  prefix(['box-sizing'], {
    feature: 'css3-boxsizing',
    browsers
  })
)

// Filter Effects
let prefixFilters = __nccwpck_require__(35123)

f(prefixFilters, browsers =>
  prefix(['filter'], {
    feature: 'css-filters',
    browsers
  })
)

// filter() function
let prefixFilterFunction = __nccwpck_require__(19533)

f(prefixFilterFunction, browsers =>
  prefix(['filter-function'], {
    props: [
      'background',
      'background-image',
      'border-image',
      'mask',
      'list-style',
      'list-style-image',
      'content',
      'mask-image'
    ],
    feature: 'css-filter-function',
    browsers
  })
)

// Backdrop-filter
let prefixBackdrop = __nccwpck_require__(74043)

f(prefixBackdrop, { match: /y\sx|y\s#2/ }, browsers =>
  prefix(['backdrop-filter'], {
    feature: 'css-backdrop-filter',
    browsers
  })
)

// element() function
let prefixElementFunction = __nccwpck_require__(21694)

f(prefixElementFunction, browsers =>
  prefix(['element'], {
    props: [
      'background',
      'background-image',
      'border-image',
      'mask',
      'list-style',
      'list-style-image',
      'content',
      'mask-image'
    ],
    feature: 'css-element-function',
    browsers
  })
)

// Multicolumns
let prefixMulticolumns = __nccwpck_require__(24233)

f(prefixMulticolumns, browsers => {
  prefix(
    [
      'columns',
      'column-width',
      'column-gap',
      'column-rule',
      'column-rule-color',
      'column-rule-width',
      'column-count',
      'column-rule-style',
      'column-span',
      'column-fill'
    ],
    {
      feature: 'multicolumn',
      browsers
    }
  )

  let noff = browsers.filter(i => !/firefox/.test(i))
  prefix(['break-before', 'break-after', 'break-inside'], {
    feature: 'multicolumn',
    browsers: noff
  })
})

// User select
let prefixUserSelect = __nccwpck_require__(85671)

f(prefixUserSelect, browsers =>
  prefix(['user-select'], {
    mistakes: ['-khtml-'],
    feature: 'user-select-none',
    browsers
  })
)

// Flexible Box Layout
let prefixFlexbox = __nccwpck_require__(48976)

f(prefixFlexbox, { match: /a\sx/ }, browsers => {
  browsers = browsers.map(i => {
    if (/ie|firefox/.test(i)) {
      return i
    } else {
      return `${i} 2009`
    }
  })
  prefix(['display-flex', 'inline-flex'], {
    props: ['display'],
    feature: 'flexbox',
    browsers
  })
  prefix(['flex', 'flex-grow', 'flex-shrink', 'flex-basis'], {
    feature: 'flexbox',
    browsers
  })
  prefix(
    [
      'flex-direction',
      'flex-wrap',
      'flex-flow',
      'justify-content',
      'order',
      'align-items',
      'align-self',
      'align-content'
    ],
    {
      feature: 'flexbox',
      browsers
    }
  )
})

f(prefixFlexbox, { match: /y\sx/ }, browsers => {
  add(['display-flex', 'inline-flex'], {
    feature: 'flexbox',
    browsers
  })
  add(['flex', 'flex-grow', 'flex-shrink', 'flex-basis'], {
    feature: 'flexbox',
    browsers
  })
  add(
    [
      'flex-direction',
      'flex-wrap',
      'flex-flow',
      'justify-content',
      'order',
      'align-items',
      'align-self',
      'align-content'
    ],
    {
      feature: 'flexbox',
      browsers
    }
  )
})

// calc() unit
let prefixCalc = __nccwpck_require__(287)

f(prefixCalc, browsers =>
  prefix(['calc'], {
    props: ['*'],
    feature: 'calc',
    browsers
  })
)

// Background options
let prefixBackgroundOptions = __nccwpck_require__(22115)

f(prefixBackgroundOptions, browsers =>
  prefix(['background-origin', 'background-size'], {
    feature: 'background-img-opts',
    browsers
  })
)

// background-clip: text
let prefixBackgroundClipText = __nccwpck_require__(13197)

f(prefixBackgroundClipText, browsers =>
  prefix(['background-clip'], {
    feature: 'background-clip-text',
    browsers
  })
)

// Font feature settings
let prefixFontFeature = __nccwpck_require__(26538)

f(prefixFontFeature, browsers =>
  prefix(
    [
      'font-feature-settings',
      'font-variant-ligatures',
      'font-language-override'
    ],
    {
      feature: 'font-feature',
      browsers
    }
  )
)

// CSS font-kerning property
let prefixFontKerning = __nccwpck_require__(88367)

f(prefixFontKerning, browsers =>
  prefix(['font-kerning'], {
    feature: 'font-kerning',
    browsers
  })
)

// Border image
let prefixBorderImage = __nccwpck_require__(14915)

f(prefixBorderImage, browsers =>
  prefix(['border-image'], {
    feature: 'border-image',
    browsers
  })
)

// Selection selector
let prefixSelection = __nccwpck_require__(16302)

f(prefixSelection, browsers =>
  prefix(['::selection'], {
    selector: true,
    feature: 'css-selection',
    browsers
  })
)

// Placeholder selector
let prefixPlaceholder = __nccwpck_require__(83448)

f(prefixPlaceholder, browsers => {
  prefix(['::placeholder'], {
    selector: true,
    feature: 'css-placeholder',
    browsers: browsers.concat(['ie 10 old', 'ie 11 old', 'firefox 18 old'])
  })
})

// Placeholder-shown selector
let prefixPlaceholderShown = __nccwpck_require__(70361)

f(prefixPlaceholderShown, browsers => {
  prefix([':placeholder-shown'], {
    selector: true,
    feature: 'css-placeholder-shown',
    browsers
  })
})

// Hyphenation
let prefixHyphens = __nccwpck_require__(89317)

f(prefixHyphens, browsers =>
  prefix(['hyphens'], {
    feature: 'css-hyphens',
    browsers
  })
)

// Fullscreen selector
let prefixFullscreen = __nccwpck_require__(99086)

f(prefixFullscreen, browsers =>
  prefix([':fullscreen'], {
    selector: true,
    feature: 'fullscreen',
    browsers
  })
)

f(prefixFullscreen, { match: /x(\s#2|$)/ }, browsers =>
  prefix(['::backdrop'], {
    selector: true,
    feature: 'fullscreen',
    browsers
  })
)

// File selector button
prefix(['::file-selector-button'], {
  selector: true,
  feature: 'fullscreen',
  browsers: [
    'chrome 89',
    'edge 89',
    'firefox 82',
    'opera 75',
    'safari 14.1',
    'android 89',
    'and_chr 89',
    'op_mob 63',
    'and_ff 82',
    'ios_saf 14.5',
    'samsung 15.0'
  ]
})

// Tab size
let prefixTabsize = __nccwpck_require__(87604)

f(prefixTabsize, browsers =>
  prefix(['tab-size'], {
    feature: 'css3-tabsize',
    browsers
  })
)

// Intrinsic & extrinsic sizing
let prefixIntrinsic = __nccwpck_require__(56835)

let sizeProps = [
  'width',
  'min-width',
  'max-width',
  'height',
  'min-height',
  'max-height',
  'inline-size',
  'min-inline-size',
  'max-inline-size',
  'block-size',
  'min-block-size',
  'max-block-size',
  'grid',
  'grid-template',
  'grid-template-rows',
  'grid-template-columns',
  'grid-auto-columns',
  'grid-auto-rows'
]

f(prefixIntrinsic, browsers =>
  prefix(['max-content', 'min-content'], {
    props: sizeProps,
    feature: 'intrinsic-width',
    browsers
  })
)

f(prefixIntrinsic, { match: /x|\s#4/ }, browsers =>
  prefix(['fill', 'fill-available', 'stretch'], {
    props: sizeProps,
    feature: 'intrinsic-width',
    browsers
  })
)

f(prefixIntrinsic, { match: /x|\s#5/ }, browsers =>
  prefix(['fit-content'], {
    props: sizeProps,
    feature: 'intrinsic-width',
    browsers
  })
)

// Zoom cursors
let prefixCursorsNewer = __nccwpck_require__(70800)

f(prefixCursorsNewer, browsers =>
  prefix(['zoom-in', 'zoom-out'], {
    props: ['cursor'],
    feature: 'css3-cursors-newer',
    browsers
  })
)

// Grab cursors
let prefixCursorsGrab = __nccwpck_require__(63355)

f(prefixCursorsGrab, browsers =>
  prefix(['grab', 'grabbing'], {
    props: ['cursor'],
    feature: 'css3-cursors-grab',
    browsers
  })
)

// Sticky position
let prefixSticky = __nccwpck_require__(67425)

f(prefixSticky, browsers =>
  prefix(['sticky'], {
    props: ['position'],
    feature: 'css-sticky',
    browsers
  })
)

// Pointer Events
let prefixPointer = __nccwpck_require__(27252)

f(prefixPointer, browsers =>
  prefix(['touch-action'], {
    feature: 'pointer',
    browsers
  })
)

// Text decoration
let prefixDecoration = __nccwpck_require__(6866)

f(prefixDecoration, browsers =>
  prefix(
    [
      'text-decoration-style',
      'text-decoration-color',
      'text-decoration-line',
      'text-decoration'
    ],
    {
      feature: 'text-decoration',
      browsers
    }
  )
)

f(prefixDecoration, { match: /x.*#[235]/ }, browsers =>
  prefix(['text-decoration-skip', 'text-decoration-skip-ink'], {
    feature: 'text-decoration',
    browsers
  })
)

// Text Size Adjust
let prefixTextSizeAdjust = __nccwpck_require__(2368)

f(prefixTextSizeAdjust, browsers =>
  prefix(['text-size-adjust'], {
    feature: 'text-size-adjust',
    browsers
  })
)

// CSS Masks
let prefixCssMasks = __nccwpck_require__(15592)

f(prefixCssMasks, browsers => {
  prefix(
    [
      'mask-clip',
      'mask-composite',
      'mask-image',
      'mask-origin',
      'mask-repeat',
      'mask-border-repeat',
      'mask-border-source'
    ],
    {
      feature: 'css-masks',
      browsers
    }
  )
  prefix(
    [
      'mask',
      'mask-position',
      'mask-size',
      'mask-border',
      'mask-border-outset',
      'mask-border-width',
      'mask-border-slice'
    ],
    {
      feature: 'css-masks',
      browsers
    }
  )
})

// CSS clip-path property
let prefixClipPath = __nccwpck_require__(37028)

f(prefixClipPath, browsers =>
  prefix(['clip-path'], {
    feature: 'css-clip-path',
    browsers
  })
)

// Fragmented Borders and Backgrounds
let prefixBoxdecoration = __nccwpck_require__(81371)

f(prefixBoxdecoration, browsers =>
  prefix(['box-decoration-break'], {
    feature: 'css-boxdecorationbreak',
    browsers
  })
)

// CSS3 object-fit/object-position
let prefixObjectFit = __nccwpck_require__(6228)

f(prefixObjectFit, browsers =>
  prefix(['object-fit', 'object-position'], {
    feature: 'object-fit',
    browsers
  })
)

// CSS Shapes
let prefixShapes = __nccwpck_require__(56938)

f(prefixShapes, browsers =>
  prefix(['shape-margin', 'shape-outside', 'shape-image-threshold'], {
    feature: 'css-shapes',
    browsers
  })
)

// CSS3 text-overflow
let prefixTextOverflow = __nccwpck_require__(73033)

f(prefixTextOverflow, browsers =>
  prefix(['text-overflow'], {
    feature: 'text-overflow',
    browsers
  })
)

// Viewport at-rule
let prefixDeviceadaptation = __nccwpck_require__(83318)

f(prefixDeviceadaptation, browsers =>
  prefix(['@viewport'], {
    feature: 'css-deviceadaptation',
    browsers
  })
)

// Resolution Media Queries
let prefixResolut = __nccwpck_require__(79494)

f(prefixResolut, { match: /( x($| )|a #2)/ }, browsers =>
  prefix(['@resolution'], {
    feature: 'css-media-resolution',
    browsers
  })
)

// CSS text-align-last
let prefixTextAlignLast = __nccwpck_require__(68887)

f(prefixTextAlignLast, browsers =>
  prefix(['text-align-last'], {
    feature: 'css-text-align-last',
    browsers
  })
)

// Crisp Edges Image Rendering Algorithm
let prefixCrispedges = __nccwpck_require__(36717)

f(prefixCrispedges, { match: /y x|a x #1/ }, browsers =>
  prefix(['pixelated'], {
    props: ['image-rendering'],
    feature: 'css-crisp-edges',
    browsers
  })
)

f(prefixCrispedges, { match: /a x #2/ }, browsers =>
  prefix(['image-rendering'], {
    feature: 'css-crisp-edges',
    browsers
  })
)

// Logical Properties
let prefixLogicalProps = __nccwpck_require__(23871)

f(prefixLogicalProps, browsers =>
  prefix(
    [
      'border-inline-start',
      'border-inline-end',
      'margin-inline-start',
      'margin-inline-end',
      'padding-inline-start',
      'padding-inline-end'
    ],
    {
      feature: 'css-logical-props',
      browsers
    }
  )
)

f(prefixLogicalProps, { match: /x\s#2/ }, browsers =>
  prefix(
    [
      'border-block-start',
      'border-block-end',
      'margin-block-start',
      'margin-block-end',
      'padding-block-start',
      'padding-block-end'
    ],
    {
      feature: 'css-logical-props',
      browsers
    }
  )
)

// CSS appearance
let prefixAppearance = __nccwpck_require__(3599)

f(prefixAppearance, { match: /#2|x/ }, browsers =>
  prefix(['appearance'], {
    feature: 'css-appearance',
    browsers
  })
)

// CSS Scroll snap points
let prefixSnappoints = __nccwpck_require__(82776)

f(prefixSnappoints, browsers =>
  prefix(
    [
      'scroll-snap-type',
      'scroll-snap-coordinate',
      'scroll-snap-destination',
      'scroll-snap-points-x',
      'scroll-snap-points-y'
    ],
    {
      feature: 'css-snappoints',
      browsers
    }
  )
)

// CSS Regions
let prefixRegions = __nccwpck_require__(32598)

f(prefixRegions, browsers =>
  prefix(['flow-into', 'flow-from', 'region-fragment'], {
    feature: 'css-regions',
    browsers
  })
)

// CSS image-set
let prefixImageSet = __nccwpck_require__(2762)

f(prefixImageSet, browsers =>
  prefix(['image-set'], {
    props: [
      'background',
      'background-image',
      'border-image',
      'cursor',
      'mask',
      'mask-image',
      'list-style',
      'list-style-image',
      'content'
    ],
    feature: 'css-image-set',
    browsers
  })
)

// Writing Mode
let prefixWritingMode = __nccwpck_require__(47816)

f(prefixWritingMode, { match: /a|x/ }, browsers =>
  prefix(['writing-mode'], {
    feature: 'css-writing-mode',
    browsers
  })
)

// Cross-Fade Function
let prefixCrossFade = __nccwpck_require__(90831)

f(prefixCrossFade, browsers =>
  prefix(['cross-fade'], {
    props: [
      'background',
      'background-image',
      'border-image',
      'mask',
      'list-style',
      'list-style-image',
      'content',
      'mask-image'
    ],
    feature: 'css-cross-fade',
    browsers
  })
)

// Read Only selector
let prefixReadOnly = __nccwpck_require__(17667)

f(prefixReadOnly, browsers =>
  prefix([':read-only', ':read-write'], {
    selector: true,
    feature: 'css-read-only-write',
    browsers
  })
)

// Text Emphasize
let prefixTextEmphasis = __nccwpck_require__(76001)

f(prefixTextEmphasis, browsers =>
  prefix(
    [
      'text-emphasis',
      'text-emphasis-position',
      'text-emphasis-style',
      'text-emphasis-color'
    ],
    {
      feature: 'text-emphasis',
      browsers
    }
  )
)

// CSS Grid Layout
let prefixGrid = __nccwpck_require__(19330)

f(prefixGrid, browsers => {
  prefix(['display-grid', 'inline-grid'], {
    props: ['display'],
    feature: 'css-grid',
    browsers
  })
  prefix(
    [
      'grid-template-columns',
      'grid-template-rows',
      'grid-row-start',
      'grid-column-start',
      'grid-row-end',
      'grid-column-end',
      'grid-row',
      'grid-column',
      'grid-area',
      'grid-template',
      'grid-template-areas',
      'place-self'
    ],
    {
      feature: 'css-grid',
      browsers
    }
  )
})

f(prefixGrid, { match: /a x/ }, browsers =>
  prefix(['grid-column-align', 'grid-row-align'], {
    feature: 'css-grid',
    browsers
  })
)

// CSS text-spacing
let prefixTextSpacing = __nccwpck_require__(75688)

f(prefixTextSpacing, browsers =>
  prefix(['text-spacing'], {
    feature: 'css-text-spacing',
    browsers
  })
)

// :any-link selector
let prefixAnyLink = __nccwpck_require__(2031)

f(prefixAnyLink, browsers =>
  prefix([':any-link'], {
    selector: true,
    feature: 'css-any-link',
    browsers
  })
)

// unicode-bidi
let prefixBidi = __nccwpck_require__(45257)

f(prefixBidi, browsers =>
  prefix(['isolate'], {
    props: ['unicode-bidi'],
    feature: 'css-unicode-bidi',
    browsers
  })
)

f(prefixBidi, { match: /y x|a x #2/ }, browsers =>
  prefix(['plaintext'], {
    props: ['unicode-bidi'],
    feature: 'css-unicode-bidi',
    browsers
  })
)

f(prefixBidi, { match: /y x/ }, browsers =>
  prefix(['isolate-override'], {
    props: ['unicode-bidi'],
    feature: 'css-unicode-bidi',
    browsers
  })
)

// overscroll-behavior selector
let prefixOverscroll = __nccwpck_require__(50237)

f(prefixOverscroll, { match: /a #1/ }, browsers =>
  prefix(['overscroll-behavior'], {
    feature: 'css-overscroll-behavior',
    browsers
  })
)

// color-adjust
let prefixColorAdjust = __nccwpck_require__(75747)

f(prefixColorAdjust, browsers =>
  prefix(['color-adjust'], {
    feature: 'css-color-adjust',
    browsers
  })
)

// text-orientation
let prefixTextOrientation = __nccwpck_require__(80045)

f(prefixTextOrientation, browsers =>
  prefix(['text-orientation'], {
    feature: 'css-text-orientation',
    browsers
  })
)


/***/ }),

/***/ 87170:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Prefixer = __nccwpck_require__(26579)

class AtRule extends Prefixer {
  /**
   * Clone and add prefixes for at-rule
   */
  add(rule, prefix) {
    let prefixed = prefix + rule.name

    let already = rule.parent.some(
      i => i.name === prefixed && i.params === rule.params
    )
    if (already) {
      return undefined
    }

    let cloned = this.clone(rule, { name: prefixed })
    return rule.parent.insertBefore(rule, cloned)
  }

  /**
   * Clone node with prefixes
   */
  process(node) {
    let parent = this.parentPrefix(node)

    for (let prefix of this.prefixes) {
      if (!parent || parent === prefix) {
        this.add(node, prefix)
      }
    }
  }
}

module.exports = AtRule


/***/ }),

/***/ 1376:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let browserslist = __nccwpck_require__(55478)
let { agents } = __nccwpck_require__(64006)
let colorette = __nccwpck_require__(95666)

let Browsers = __nccwpck_require__(50931)
let Prefixes = __nccwpck_require__(25396)
let dataPrefixes = __nccwpck_require__(79659)
let getInfo = __nccwpck_require__(83028)

let autoprefixerData = { browsers: agents, prefixes: dataPrefixes }

const WARNING =
  '\n' +
  '  Replace Autoprefixer `browsers` option to Browserslist config.\n' +
  '  Use `browserslist` key in `package.json` or `.browserslistrc` file.\n' +
  '\n' +
  '  Using `browsers` option can cause errors. Browserslist config can\n' +
  '  be used for Babel, Autoprefixer, postcss-normalize and other tools.\n' +
  '\n' +
  '  If you really need to use option, rename it to `overrideBrowserslist`.\n' +
  '\n' +
  '  Learn more at:\n' +
  '  https://github.com/browserslist/browserslist#readme\n' +
  '  https://twitter.com/browserslist\n' +
  '\n'

function isPlainObject(obj) {
  return Object.prototype.toString.apply(obj) === '[object Object]'
}

let cache = new Map()

function timeCapsule(result, prefixes) {
  if (prefixes.browsers.selected.length === 0) {
    return
  }
  if (prefixes.add.selectors.length > 0) {
    return
  }
  if (Object.keys(prefixes.add).length > 2) {
    return
  }

  /* istanbul ignore next */
  result.warn(
    'Autoprefixer target browsers do not need any prefixes.' +
      'You do not need Autoprefixer anymore.\n' +
      'Check your Browserslist config to be sure that your targets ' +
      'are set up correctly.\n' +
      '\n' +
      '  Learn more at:\n' +
      '  https://github.com/postcss/autoprefixer#readme\n' +
      '  https://github.com/browserslist/browserslist#readme\n' +
      '\n'
  )
}

module.exports = plugin

function plugin(...reqs) {
  let options
  if (reqs.length === 1 && isPlainObject(reqs[0])) {
    options = reqs[0]
    reqs = undefined
  } else if (reqs.length === 0 || (reqs.length === 1 && !reqs[0])) {
    reqs = undefined
  } else if (reqs.length <= 2 && (Array.isArray(reqs[0]) || !reqs[0])) {
    options = reqs[1]
    reqs = reqs[0]
  } else if (typeof reqs[reqs.length - 1] === 'object') {
    options = reqs.pop()
  }

  if (!options) {
    options = {}
  }

  if (options.browser) {
    throw new Error(
      'Change `browser` option to `overrideBrowserslist` in Autoprefixer'
    )
  } else if (options.browserslist) {
    throw new Error(
      'Change `browserslist` option to `overrideBrowserslist` in Autoprefixer'
    )
  }

  if (options.overrideBrowserslist) {
    reqs = options.overrideBrowserslist
  } else if (options.browsers) {
    if (typeof console !== 'undefined' && console.warn) {
      if (colorette.red) {
        console.warn(
          colorette.red(
            WARNING.replace(/`[^`]+`/g, i => colorette.yellow(i.slice(1, -1)))
          )
        )
      } else {
        console.warn(WARNING)
      }
    }
    reqs = options.browsers
  }

  let brwlstOpts = {
    ignoreUnknownVersions: options.ignoreUnknownVersions,
    stats: options.stats,
    env: options.env
  }

  function loadPrefixes(opts) {
    let d = autoprefixerData
    let browsers = new Browsers(d.browsers, reqs, opts, brwlstOpts)
    let key = browsers.selected.join(', ') + JSON.stringify(options)

    if (!cache.has(key)) {
      cache.set(key, new Prefixes(d.prefixes, browsers, options))
    }

    return cache.get(key)
  }

  return {
    postcssPlugin: 'autoprefixer',

    prepare(result) {
      let prefixes = loadPrefixes({
        from: result.opts.from,
        env: options.env
      })

      return {
        OnceExit(root) {
          timeCapsule(result, prefixes)
          if (options.remove !== false) {
            prefixes.processor.remove(root, result)
          }
          if (options.add !== false) {
            prefixes.processor.add(root, result)
          }
        }
      }
    },

    info(opts) {
      opts = opts || {}
      opts.from = opts.from || process.cwd()
      return getInfo(loadPrefixes(opts))
    },

    options,
    browsers: reqs
  }
}

plugin.postcss = true

/**
 * Autoprefixer data
 */
plugin.data = autoprefixerData

/**
 * Autoprefixer default browsers
 */
plugin.defaults = browserslist.defaults

/**
 * Inspect with default Autoprefixer
 */
plugin.info = () => plugin().info()


/***/ }),

/***/ 59137:
/***/ ((module) => {

function last(array) {
  return array[array.length - 1]
}

let brackets = {
  /**
   * Parse string to nodes tree
   */
  parse(str) {
    let current = ['']
    let stack = [current]

    for (let sym of str) {
      if (sym === '(') {
        current = ['']
        last(stack).push(current)
        stack.push(current)
        continue
      }

      if (sym === ')') {
        stack.pop()
        current = last(stack)
        current.push('')
        continue
      }

      current[current.length - 1] += sym
    }

    return stack[0]
  },

  /**
   * Generate output string by nodes tree
   */
  stringify(ast) {
    let result = ''
    for (let i of ast) {
      if (typeof i === 'object') {
        result += `(${brackets.stringify(i)})`
        continue
      }

      result += i
    }
    return result
  }
}

module.exports = brackets


/***/ }),

/***/ 50931:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let browserslist = __nccwpck_require__(55478)
let agents = __nccwpck_require__(64006).agents

let utils = __nccwpck_require__(96584)

class Browsers {
  /**
   * Return all prefixes for default browser data
   */
  static prefixes() {
    if (this.prefixesCache) {
      return this.prefixesCache
    }

    this.prefixesCache = []
    for (let name in agents) {
      this.prefixesCache.push(`-${agents[name].prefix}-`)
    }

    this.prefixesCache = utils
      .uniq(this.prefixesCache)
      .sort((a, b) => b.length - a.length)

    return this.prefixesCache
  }

  /**
   * Check is value contain any possible prefix
   */
  static withPrefix(value) {
    if (!this.prefixesRegexp) {
      this.prefixesRegexp = new RegExp(this.prefixes().join('|'))
    }

    return this.prefixesRegexp.test(value)
  }

  constructor(data, requirements, options, browserslistOpts) {
    this.data = data
    this.options = options || {}
    this.browserslistOpts = browserslistOpts || {}
    this.selected = this.parse(requirements)
  }

  /**
   * Return browsers selected by requirements
   */
  parse(requirements) {
    let opts = {}
    for (let i in this.browserslistOpts) {
      opts[i] = this.browserslistOpts[i]
    }
    opts.path = this.options.from
    return browserslist(requirements, opts)
  }

  /**
   * Return prefix for selected browser
   */
  prefix(browser) {
    let [name, version] = browser.split(' ')
    let data = this.data[name]

    let prefix = data.prefix_exceptions && data.prefix_exceptions[version]
    if (!prefix) {
      prefix = data.prefix
    }
    return `-${prefix}-`
  }

  /**
   * Is browser is selected by requirements
   */
  isSelected(browser) {
    return this.selected.includes(browser)
  }
}

module.exports = Browsers


/***/ }),

/***/ 69011:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Prefixer = __nccwpck_require__(26579)
let Browsers = __nccwpck_require__(50931)
let utils = __nccwpck_require__(96584)

class Declaration extends Prefixer {
  /**
   * Always true, because we already get prefixer by property name
   */
  check(/* decl */) {
    return true
  }

  /**
   * Return prefixed version of property
   */
  prefixed(prop, prefix) {
    return prefix + prop
  }

  /**
   * Return unprefixed version of property
   */
  normalize(prop) {
    return prop
  }

  /**
   * Check `value`, that it contain other prefixes, rather than `prefix`
   */
  otherPrefixes(value, prefix) {
    for (let other of Browsers.prefixes()) {
      if (other === prefix) {
        continue
      }
      if (value.includes(other)) {
        return true
      }
    }
    return false
  }

  /**
   * Set prefix to declaration
   */
  set(decl, prefix) {
    decl.prop = this.prefixed(decl.prop, prefix)
    return decl
  }

  /**
   * Should we use visual cascade for prefixes
   */
  needCascade(decl) {
    if (!decl._autoprefixerCascade) {
      decl._autoprefixerCascade =
        this.all.options.cascade !== false && decl.raw('before').includes('\n')
    }
    return decl._autoprefixerCascade
  }

  /**
   * Return maximum length of possible prefixed property
   */
  maxPrefixed(prefixes, decl) {
    if (decl._autoprefixerMax) {
      return decl._autoprefixerMax
    }

    let max = 0
    for (let prefix of prefixes) {
      prefix = utils.removeNote(prefix)
      if (prefix.length > max) {
        max = prefix.length
      }
    }
    decl._autoprefixerMax = max

    return decl._autoprefixerMax
  }

  /**
   * Calculate indentation to create visual cascade
   */
  calcBefore(prefixes, decl, prefix = '') {
    let max = this.maxPrefixed(prefixes, decl)
    let diff = max - utils.removeNote(prefix).length

    let before = decl.raw('before')
    if (diff > 0) {
      before += Array(diff).fill(' ').join('')
    }

    return before
  }

  /**
   * Remove visual cascade
   */
  restoreBefore(decl) {
    let lines = decl.raw('before').split('\n')
    let min = lines[lines.length - 1]

    this.all.group(decl).up(prefixed => {
      let array = prefixed.raw('before').split('\n')
      let last = array[array.length - 1]
      if (last.length < min.length) {
        min = last
      }
    })

    lines[lines.length - 1] = min
    decl.raws.before = lines.join('\n')
  }

  /**
   * Clone and insert new declaration
   */
  insert(decl, prefix, prefixes) {
    let cloned = this.set(this.clone(decl), prefix)
    if (!cloned) return undefined

    let already = decl.parent.some(
      i => i.prop === cloned.prop && i.value === cloned.value
    )
    if (already) {
      return undefined
    }

    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    return decl.parent.insertBefore(decl, cloned)
  }

  /**
   * Did this declaration has this prefix above
   */
  isAlready(decl, prefixed) {
    let already = this.all.group(decl).up(i => i.prop === prefixed)
    if (!already) {
      already = this.all.group(decl).down(i => i.prop === prefixed)
    }
    return already
  }

  /**
   * Clone and add prefixes for declaration
   */
  add(decl, prefix, prefixes, result) {
    let prefixed = this.prefixed(decl.prop, prefix)
    if (
      this.isAlready(decl, prefixed) ||
      this.otherPrefixes(decl.value, prefix)
    ) {
      return undefined
    }
    return this.insert(decl, prefix, prefixes, result)
  }

  /**
   * Add spaces for visual cascade
   */
  process(decl, result) {
    if (!this.needCascade(decl)) {
      super.process(decl, result)
      return
    }

    let prefixes = super.process(decl, result)

    if (!prefixes || !prefixes.length) {
      return
    }

    this.restoreBefore(decl)
    decl.raws.before = this.calcBefore(prefixes, decl)
  }

  /**
   * Return list of prefixed properties to clean old prefixes
   */
  old(prop, prefix) {
    return [this.prefixed(prop, prefix)]
  }
}

module.exports = Declaration


/***/ }),

/***/ 46788:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class AlignContent extends Declaration {
  /**
   * Change property name for 2012 spec
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012) {
      return prefix + 'flex-line-pack'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'align-content'
  }

  /**
   * Change value for 2012 spec and ignore prefix for 2009
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2012) {
      decl.value = AlignContent.oldValues[decl.value] || decl.value
      return super.set(decl, prefix)
    }
    if (spec === 'final') {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

AlignContent.names = ['align-content', 'flex-line-pack']

AlignContent.oldValues = {
  'flex-end': 'end',
  'flex-start': 'start',
  'space-between': 'justify',
  'space-around': 'distribute'
}

module.exports = AlignContent


/***/ }),

/***/ 92478:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class AlignItems extends Declaration {
  /**
   * Change property name for 2009 and 2012 specs
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return prefix + 'box-align'
    }
    if (spec === 2012) {
      return prefix + 'flex-align'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'align-items'
  }

  /**
   * Change value for 2009 and 2012 specs
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2009 || spec === 2012) {
      decl.value = AlignItems.oldValues[decl.value] || decl.value
    }
    return super.set(decl, prefix)
  }
}

AlignItems.names = ['align-items', 'flex-align', 'box-align']

AlignItems.oldValues = {
  'flex-end': 'end',
  'flex-start': 'start'
}

module.exports = AlignItems


/***/ }),

/***/ 70119:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class AlignSelf extends Declaration {
  check(decl) {
    return (
      decl.parent &&
      !decl.parent.some(i => {
        return i.prop && i.prop.startsWith('grid-')
      })
    )
  }

  /**
   * Change property name for 2012 specs
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012) {
      return prefix + 'flex-item-align'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'align-self'
  }

  /**
   * Change value for 2012 spec and ignore prefix for 2009
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2012) {
      decl.value = AlignSelf.oldValues[decl.value] || decl.value
      return super.set(decl, prefix)
    }
    if (spec === 'final') {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

AlignSelf.names = ['align-self', 'flex-item-align']

AlignSelf.oldValues = {
  'flex-end': 'end',
  'flex-start': 'start'
}

module.exports = AlignSelf


/***/ }),

/***/ 57508:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class Animation extends Declaration {
  /**
   * Dont add prefixes for modern values.
   */
  check(decl) {
    return !decl.value.split(/\s+/).some(i => {
      let lower = i.toLowerCase()
      return lower === 'reverse' || lower === 'alternate-reverse'
    })
  }
}

Animation.names = ['animation', 'animation-direction']

module.exports = Animation


/***/ }),

/***/ 53397:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(96584)

class Appearance extends Declaration {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)

    if (this.prefixes) {
      this.prefixes = utils.uniq(
        this.prefixes.map(i => {
          if (i === '-ms-') {
            return '-webkit-'
          }
          return i
        })
      )
    }
  }
}

Appearance.names = ['appearance']

module.exports = Appearance


/***/ }),

/***/ 46667:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(96584)

class BackdropFilter extends Declaration {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)

    if (this.prefixes) {
      this.prefixes = utils.uniq(
        this.prefixes.map(i => {
          return i === '-ms-' ? '-webkit-' : i
        })
      )
    }
  }
}

BackdropFilter.names = ['backdrop-filter']

module.exports = BackdropFilter


/***/ }),

/***/ 32781:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(96584)

class BackgroundClip extends Declaration {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)

    if (this.prefixes) {
      this.prefixes = utils.uniq(
        this.prefixes.map(i => {
          return i === '-ms-' ? '-webkit-' : i
        })
      )
    }
  }

  check(decl) {
    return decl.value.toLowerCase() === 'text'
  }
}

BackgroundClip.names = ['background-clip']

module.exports = BackgroundClip


/***/ }),

/***/ 17397:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class BackgroundSize extends Declaration {
  /**
   * Duplication parameter for -webkit- browsers
   */
  set(decl, prefix) {
    let value = decl.value.toLowerCase()
    if (
      prefix === '-webkit-' &&
      !value.includes(' ') &&
      value !== 'contain' &&
      value !== 'cover'
    ) {
      decl.value = decl.value + ' ' + decl.value
    }
    return super.set(decl, prefix)
  }
}

BackgroundSize.names = ['background-size']

module.exports = BackgroundSize


/***/ }),

/***/ 51447:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class BlockLogical extends Declaration {
  /**
   * Use old syntax for -moz- and -webkit-
   */
  prefixed(prop, prefix) {
    if (prop.includes('-start')) {
      return prefix + prop.replace('-block-start', '-before')
    }
    return prefix + prop.replace('-block-end', '-after')
  }

  /**
   * Return property name by spec
   */
  normalize(prop) {
    if (prop.includes('-before')) {
      return prop.replace('-before', '-block-start')
    }
    return prop.replace('-after', '-block-end')
  }
}

BlockLogical.names = [
  'border-block-start',
  'border-block-end',
  'margin-block-start',
  'margin-block-end',
  'padding-block-start',
  'padding-block-end',
  'border-before',
  'border-after',
  'margin-before',
  'margin-after',
  'padding-before',
  'padding-after'
]

module.exports = BlockLogical


/***/ }),

/***/ 92212:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class BorderImage extends Declaration {
  /**
   * Remove fill parameter for prefixed declarations
   */
  set(decl, prefix) {
    decl.value = decl.value.replace(/\s+fill(\s)/, '$1')
    return super.set(decl, prefix)
  }
}

BorderImage.names = ['border-image']

module.exports = BorderImage


/***/ }),

/***/ 80189:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class BorderRadius extends Declaration {
  /**
   * Change syntax, when add Mozilla prefix
   */
  prefixed(prop, prefix) {
    if (prefix === '-moz-') {
      return prefix + (BorderRadius.toMozilla[prop] || prop)
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return unprefixed version of property
   */
  normalize(prop) {
    return BorderRadius.toNormal[prop] || prop
  }
}

BorderRadius.names = ['border-radius']

BorderRadius.toMozilla = {}
BorderRadius.toNormal = {}

for (let ver of ['top', 'bottom']) {
  for (let hor of ['left', 'right']) {
    let normal = `border-${ver}-${hor}-radius`
    let mozilla = `border-radius-${ver}${hor}`

    BorderRadius.names.push(normal)
    BorderRadius.names.push(mozilla)

    BorderRadius.toMozilla[normal] = mozilla
    BorderRadius.toNormal[mozilla] = normal
  }
}

module.exports = BorderRadius


/***/ }),

/***/ 26946:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class BreakProps extends Declaration {
  /**
   * Change name for -webkit- and -moz- prefix
   */
  prefixed(prop, prefix) {
    return `${prefix}column-${prop}`
  }

  /**
   * Return property name by final spec
   */
  normalize(prop) {
    if (prop.includes('inside')) {
      return 'break-inside'
    }
    if (prop.includes('before')) {
      return 'break-before'
    }
    return 'break-after'
  }

  /**
   * Change prefixed value for avoid-column and avoid-page
   */
  set(decl, prefix) {
    if (
      (decl.prop === 'break-inside' && decl.value === 'avoid-column') ||
      decl.value === 'avoid-page'
    ) {
      decl.value = 'avoid'
    }
    return super.set(decl, prefix)
  }

  /**
   * Dont prefix some values
   */
  insert(decl, prefix, prefixes) {
    if (decl.prop !== 'break-inside') {
      return super.insert(decl, prefix, prefixes)
    }
    if (/region/i.test(decl.value) || /page/i.test(decl.value)) {
      return undefined
    }
    return super.insert(decl, prefix, prefixes)
  }
}

BreakProps.names = [
  'break-inside',
  'page-break-inside',
  'column-break-inside',
  'break-before',
  'page-break-before',
  'column-break-before',
  'break-after',
  'page-break-after',
  'column-break-after'
]

module.exports = BreakProps


/***/ }),

/***/ 8527:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class ColorAdjust extends Declaration {
  /**
   * Change property name for WebKit-based browsers
   */
  prefixed(prop, prefix) {
    return prefix + 'print-color-adjust'
  }

  /**
   * Return property name by spec
   */
  normalize() {
    return 'color-adjust'
  }
}

ColorAdjust.names = ['color-adjust', 'print-color-adjust']

module.exports = ColorAdjust


/***/ }),

/***/ 52315:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let list = __nccwpck_require__(77001).list

let Value = __nccwpck_require__(52530)

class CrossFade extends Value {
  replace(string, prefix) {
    return list
      .space(string)
      .map(value => {
        if (value.slice(0, +this.name.length + 1) !== this.name + '(') {
          return value
        }

        let close = value.lastIndexOf(')')
        let after = value.slice(close + 1)
        let args = value.slice(this.name.length + 1, close)

        if (prefix === '-webkit-') {
          let match = args.match(/\d*.?\d+%?/)
          if (match) {
            args = args.slice(match[0].length).trim()
            args += `, ${match[0]}`
          } else {
            args += ', 0.5'
          }
        }
        return prefix + this.name + '(' + args + ')' + after
      })
      .join(' ')
  }
}

CrossFade.names = ['cross-fade']

module.exports = CrossFade


/***/ }),

/***/ 69470:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let OldValue = __nccwpck_require__(86029)
let Value = __nccwpck_require__(52530)

class DisplayFlex extends Value {
  constructor(name, prefixes) {
    super(name, prefixes)
    if (name === 'display-flex') {
      this.name = 'flex'
    }
  }

  /**
   * Faster check for flex value
   */
  check(decl) {
    return decl.prop === 'display' && decl.value === this.name
  }

  /**
   * Return value by spec
   */
  prefixed(prefix) {
    let spec, value
    ;[spec, prefix] = flexSpec(prefix)

    if (spec === 2009) {
      if (this.name === 'flex') {
        value = 'box'
      } else {
        value = 'inline-box'
      }
    } else if (spec === 2012) {
      if (this.name === 'flex') {
        value = 'flexbox'
      } else {
        value = 'inline-flexbox'
      }
    } else if (spec === 'final') {
      value = this.name
    }

    return prefix + value
  }

  /**
   * Add prefix to value depend on flebox spec version
   */
  replace(string, prefix) {
    return this.prefixed(prefix)
  }

  /**
   * Change value for old specs
   */
  old(prefix) {
    let prefixed = this.prefixed(prefix)
    if (!prefixed) return undefined
    return new OldValue(this.name, prefixed)
  }
}

DisplayFlex.names = ['display-flex', 'inline-flex']

module.exports = DisplayFlex


/***/ }),

/***/ 35643:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Value = __nccwpck_require__(52530)

class DisplayGrid extends Value {
  constructor(name, prefixes) {
    super(name, prefixes)
    if (name === 'display-grid') {
      this.name = 'grid'
    }
  }

  /**
   * Faster check for flex value
   */
  check(decl) {
    return decl.prop === 'display' && decl.value === this.name
  }
}

DisplayGrid.names = ['display-grid', 'inline-grid']

module.exports = DisplayGrid


/***/ }),

/***/ 35407:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Selector = __nccwpck_require__(52098)
let utils = __nccwpck_require__(96584)

class FileSelectorButton extends Selector {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)

    if (this.prefixes) {
      this.prefixes = utils.uniq(
        this.prefixes.map(i => {
          return '-webkit-'
        })
      )
    }
  }

  /**
   * Return different selectors depend on prefix
   */
  prefixed(prefix) {
    if (prefix === '-webkit-') {
      return '::-webkit-file-upload-button'
    }
    return `::${prefix}file-selector-button`
  }
}

FileSelectorButton.names = ['::file-selector-button']

module.exports = FileSelectorButton


/***/ }),

/***/ 56122:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Value = __nccwpck_require__(52530)

class FilterValue extends Value {
  constructor(name, prefixes) {
    super(name, prefixes)
    if (name === 'filter-function') {
      this.name = 'filter'
    }
  }
}

FilterValue.names = ['filter', 'filter-function']

module.exports = FilterValue


/***/ }),

/***/ 46437:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class Filter extends Declaration {
  /**
   * Check is it Internet Explorer filter
   */
  check(decl) {
    let v = decl.value
    return (
      !v.toLowerCase().includes('alpha(') &&
      !v.includes('DXImageTransform.Microsoft') &&
      !v.includes('data:image/svg+xml')
    )
  }
}

Filter.names = ['filter']

module.exports = Filter


/***/ }),

/***/ 33962:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class FlexBasis extends Declaration {
  /**
   * Return property name by final spec
   */
  normalize() {
    return 'flex-basis'
  }

  /**
   * Return flex property for 2012 spec
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012) {
      return prefix + 'flex-preferred-size'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Ignore 2009 spec and use flex property for 2012
   */
  set(decl, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012 || spec === 'final') {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

FlexBasis.names = ['flex-basis', 'flex-preferred-size']

module.exports = FlexBasis


/***/ }),

/***/ 58440:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class FlexDirection extends Declaration {
  /**
   * Return property name by final spec
   */
  normalize() {
    return 'flex-direction'
  }

  /**
   * Use two properties for 2009 spec
   */
  insert(decl, prefix, prefixes) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec !== 2009) {
      return super.insert(decl, prefix, prefixes)
    }
    let already = decl.parent.some(
      i =>
        i.prop === prefix + 'box-orient' || i.prop === prefix + 'box-direction'
    )
    if (already) {
      return undefined
    }

    let v = decl.value
    let orient, dir
    if (v === 'inherit' || v === 'initial' || v === 'unset') {
      orient = v
      dir = v
    } else {
      orient = v.includes('row') ? 'horizontal' : 'vertical'
      dir = v.includes('reverse') ? 'reverse' : 'normal'
    }

    let cloned = this.clone(decl)
    cloned.prop = prefix + 'box-orient'
    cloned.value = orient
    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    decl.parent.insertBefore(decl, cloned)

    cloned = this.clone(decl)
    cloned.prop = prefix + 'box-direction'
    cloned.value = dir
    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    return decl.parent.insertBefore(decl, cloned)
  }

  /**
   * Clean two properties for 2009 spec
   */
  old(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return [prefix + 'box-orient', prefix + 'box-direction']
    } else {
      return super.old(prop, prefix)
    }
  }
}

FlexDirection.names = ['flex-direction', 'box-direction', 'box-orient']

module.exports = FlexDirection


/***/ }),

/***/ 99225:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class FlexFlow extends Declaration {
  /**
   * Use two properties for 2009 spec
   */
  insert(decl, prefix, prefixes) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec !== 2009) {
      return super.insert(decl, prefix, prefixes)
    }
    let values = decl.value
      .split(/\s+/)
      .filter(i => i !== 'wrap' && i !== 'nowrap' && 'wrap-reverse')
    if (values.length === 0) {
      return undefined
    }

    let already = decl.parent.some(
      i =>
        i.prop === prefix + 'box-orient' || i.prop === prefix + 'box-direction'
    )
    if (already) {
      return undefined
    }

    let value = values[0]
    let orient = value.includes('row') ? 'horizontal' : 'vertical'
    let dir = value.includes('reverse') ? 'reverse' : 'normal'

    let cloned = this.clone(decl)
    cloned.prop = prefix + 'box-orient'
    cloned.value = orient
    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    decl.parent.insertBefore(decl, cloned)

    cloned = this.clone(decl)
    cloned.prop = prefix + 'box-direction'
    cloned.value = dir
    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    return decl.parent.insertBefore(decl, cloned)
  }
}

FlexFlow.names = ['flex-flow', 'box-direction', 'box-orient']

module.exports = FlexFlow


/***/ }),

/***/ 11708:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class Flex extends Declaration {
  /**
   * Return property name by final spec
   */
  normalize() {
    return 'flex'
  }

  /**
   * Return flex property for 2009 and 2012 specs
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return prefix + 'box-flex'
    }
    if (spec === 2012) {
      return prefix + 'flex-positive'
    }
    return super.prefixed(prop, prefix)
  }
}

Flex.names = ['flex-grow', 'flex-positive']

module.exports = Flex


/***/ }),

/***/ 61945:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class FlexShrink extends Declaration {
  /**
   * Return property name by final spec
   */
  normalize() {
    return 'flex-shrink'
  }

  /**
   * Return flex property for 2012 spec
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012) {
      return prefix + 'flex-negative'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Ignore 2009 spec and use flex property for 2012
   */
  set(decl, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012 || spec === 'final') {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

FlexShrink.names = ['flex-shrink', 'flex-negative']

module.exports = FlexShrink


/***/ }),

/***/ 43713:
/***/ ((module) => {

/**
 * Return flexbox spec versions by prefix
 */
module.exports = function (prefix) {
  let spec
  if (prefix === '-webkit- 2009' || prefix === '-moz-') {
    spec = 2009
  } else if (prefix === '-ms-') {
    spec = 2012
  } else if (prefix === '-webkit-') {
    spec = 'final'
  }

  if (prefix === '-webkit- 2009') {
    prefix = '-webkit-'
  }

  return [spec, prefix]
}


/***/ }),

/***/ 44910:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class FlexWrap extends Declaration {
  /**
   * Don't add prefix for 2009 spec
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec !== 2009) {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

FlexWrap.names = ['flex-wrap']

module.exports = FlexWrap


/***/ }),

/***/ 84190:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let list = __nccwpck_require__(77001).list

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class Flex extends Declaration {
  /**
   * Change property name for 2009 spec
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return prefix + 'box-flex'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'flex'
  }

  /**
   * Spec 2009 supports only first argument
   * Spec 2012 disallows unitless basis
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2009) {
      decl.value = list.space(decl.value)[0]
      decl.value = Flex.oldValues[decl.value] || decl.value
      return super.set(decl, prefix)
    }
    if (spec === 2012) {
      let components = list.space(decl.value)
      if (components.length === 3 && components[2] === '0') {
        decl.value = components.slice(0, 2).concat('0px').join(' ')
      }
    }
    return super.set(decl, prefix)
  }
}

Flex.names = ['flex', 'box-flex']

Flex.oldValues = {
  auto: '1',
  none: '0'
}

module.exports = Flex


/***/ }),

/***/ 55233:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Selector = __nccwpck_require__(52098)

class Fullscreen extends Selector {
  /**
   * Return different selectors depend on prefix
   */
  prefixed(prefix) {
    if (prefix === '-webkit-') {
      return ':-webkit-full-screen'
    }
    if (prefix === '-moz-') {
      return ':-moz-full-screen'
    }
    return `:${prefix}fullscreen`
  }
}

Fullscreen.names = [':fullscreen']

module.exports = Fullscreen


/***/ }),

/***/ 29864:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let parser = __nccwpck_require__(19285)
let range = __nccwpck_require__(24251)

let OldValue = __nccwpck_require__(86029)
let Value = __nccwpck_require__(52530)
let utils = __nccwpck_require__(96584)

let IS_DIRECTION = /top|left|right|bottom/gi

class Gradient extends Value {
  /**
   * Change degrees for webkit prefix
   */
  replace(string, prefix) {
    let ast = parser(string)
    for (let node of ast.nodes) {
      if (node.type === 'function' && node.value === this.name) {
        node.nodes = this.newDirection(node.nodes)
        node.nodes = this.normalize(node.nodes)
        if (prefix === '-webkit- old') {
          let changes = this.oldWebkit(node)
          if (!changes) {
            return false
          }
        } else {
          node.nodes = this.convertDirection(node.nodes)
          node.value = prefix + node.value
        }
      }
    }
    return ast.toString()
  }

  /**
   * Replace first token
   */
  replaceFirst(params, ...words) {
    let prefix = words.map(i => {
      if (i === ' ') {
        return { type: 'space', value: i }
      }
      return { type: 'word', value: i }
    })
    return prefix.concat(params.slice(1))
  }

  /**
   * Convert angle unit to deg
   */
  normalizeUnit(str, full) {
    let num = parseFloat(str)
    let deg = (num / full) * 360
    return `${deg}deg`
  }

  /**
   * Normalize angle
   */
  normalize(nodes) {
    if (!nodes[0]) return nodes

    if (/-?\d+(.\d+)?grad/.test(nodes[0].value)) {
      nodes[0].value = this.normalizeUnit(nodes[0].value, 400)
    } else if (/-?\d+(.\d+)?rad/.test(nodes[0].value)) {
      nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI)
    } else if (/-?\d+(.\d+)?turn/.test(nodes[0].value)) {
      nodes[0].value = this.normalizeUnit(nodes[0].value, 1)
    } else if (nodes[0].value.includes('deg')) {
      let num = parseFloat(nodes[0].value)
      num = range.wrap(0, 360, num)
      nodes[0].value = `${num}deg`
    }

    if (nodes[0].value === '0deg') {
      nodes = this.replaceFirst(nodes, 'to', ' ', 'top')
    } else if (nodes[0].value === '90deg') {
      nodes = this.replaceFirst(nodes, 'to', ' ', 'right')
    } else if (nodes[0].value === '180deg') {
      nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom')
    } else if (nodes[0].value === '270deg') {
      nodes = this.replaceFirst(nodes, 'to', ' ', 'left')
    }

    return nodes
  }

  /**
   * Replace old direction to new
   */
  newDirection(params) {
    if (params[0].value === 'to') {
      return params
    }
    IS_DIRECTION.lastIndex = 0 // reset search index of global regexp
    if (!IS_DIRECTION.test(params[0].value)) {
      return params
    }

    params.unshift(
      {
        type: 'word',
        value: 'to'
      },
      {
        type: 'space',
        value: ' '
      }
    )

    for (let i = 2; i < params.length; i++) {
      if (params[i].type === 'div') {
        break
      }
      if (params[i].type === 'word') {
        params[i].value = this.revertDirection(params[i].value)
      }
    }

    return params
  }

  /**
   * Look for at word
   */
  isRadial(params) {
    let state = 'before'
    for (let param of params) {
      if (state === 'before' && param.type === 'space') {
        state = 'at'
      } else if (state === 'at' && param.value === 'at') {
        state = 'after'
      } else if (state === 'after' && param.type === 'space') {
        return true
      } else if (param.type === 'div') {
        break
      } else {
        state = 'before'
      }
    }
    return false
  }

  /**
   * Change new direction to old
   */
  convertDirection(params) {
    if (params.length > 0) {
      if (params[0].value === 'to') {
        this.fixDirection(params)
      } else if (params[0].value.includes('deg')) {
        this.fixAngle(params)
      } else if (this.isRadial(params)) {
        this.fixRadial(params)
      }
    }
    return params
  }

  /**
   * Replace `to top left` to `bottom right`
   */
  fixDirection(params) {
    params.splice(0, 2)

    for (let param of params) {
      if (param.type === 'div') {
        break
      }
      if (param.type === 'word') {
        param.value = this.revertDirection(param.value)
      }
    }
  }

  /**
   * Add 90 degrees
   */
  fixAngle(params) {
    let first = params[0].value
    first = parseFloat(first)
    first = Math.abs(450 - first) % 360
    first = this.roundFloat(first, 3)
    params[0].value = `${first}deg`
  }

  /**
   * Fix radial direction syntax
   */
  fixRadial(params) {
    let first = []
    let second = []
    let a, b, c, i, next

    for (i = 0; i < params.length - 2; i++) {
      a = params[i]
      b = params[i + 1]
      c = params[i + 2]
      if (a.type === 'space' && b.value === 'at' && c.type === 'space') {
        next = i + 3
        break
      } else {
        first.push(a)
      }
    }

    let div
    for (i = next; i < params.length; i++) {
      if (params[i].type === 'div') {
        div = params[i]
        break
      } else {
        second.push(params[i])
      }
    }

    params.splice(0, i, ...second, div, ...first)
  }

  revertDirection(word) {
    return Gradient.directions[word.toLowerCase()] || word
  }

  /**
   * Round float and save digits under dot
   */
  roundFloat(float, digits) {
    return parseFloat(float.toFixed(digits))
  }

  /**
   * Convert to old webkit syntax
   */
  oldWebkit(node) {
    let { nodes } = node
    let string = parser.stringify(node.nodes)

    if (this.name !== 'linear-gradient') {
      return false
    }
    if (nodes[0] && nodes[0].value.includes('deg')) {
      return false
    }
    if (
      string.includes('px') ||
      string.includes('-corner') ||
      string.includes('-side')
    ) {
      return false
    }

    let params = [[]]
    for (let i of nodes) {
      params[params.length - 1].push(i)
      if (i.type === 'div' && i.value === ',') {
        params.push([])
      }
    }

    this.oldDirection(params)
    this.colorStops(params)

    node.nodes = []
    for (let param of params) {
      node.nodes = node.nodes.concat(param)
    }

    node.nodes.unshift(
      { type: 'word', value: 'linear' },
      this.cloneDiv(node.nodes)
    )
    node.value = '-webkit-gradient'

    return true
  }

  /**
   * Change direction syntax to old webkit
   */
  oldDirection(params) {
    let div = this.cloneDiv(params[0])

    if (params[0][0].value !== 'to') {
      return params.unshift([
        { type: 'word', value: Gradient.oldDirections.bottom },
        div
      ])
    } else {
      let words = []
      for (let node of params[0].slice(2)) {
        if (node.type === 'word') {
          words.push(node.value.toLowerCase())
        }
      }

      words = words.join(' ')
      let old = Gradient.oldDirections[words] || words

      params[0] = [{ type: 'word', value: old }, div]
      return params[0]
    }
  }

  /**
   * Get div token from exists parameters
   */
  cloneDiv(params) {
    for (let i of params) {
      if (i.type === 'div' && i.value === ',') {
        return i
      }
    }
    return { type: 'div', value: ',', after: ' ' }
  }

  /**
   * Change colors syntax to old webkit
   */
  colorStops(params) {
    let result = []
    for (let i = 0; i < params.length; i++) {
      let pos
      let param = params[i]
      let item
      if (i === 0) {
        continue
      }

      let color = parser.stringify(param[0])
      if (param[1] && param[1].type === 'word') {
        pos = param[1].value
      } else if (param[2] && param[2].type === 'word') {
        pos = param[2].value
      }

      let stop
      if (i === 1 && (!pos || pos === '0%')) {
        stop = `from(${color})`
      } else if (i === params.length - 1 && (!pos || pos === '100%')) {
        stop = `to(${color})`
      } else if (pos) {
        stop = `color-stop(${pos}, ${color})`
      } else {
        stop = `color-stop(${color})`
      }

      let div = param[param.length - 1]
      params[i] = [{ type: 'word', value: stop }]
      if (div.type === 'div' && div.value === ',') {
        item = params[i].push(div)
      }
      result.push(item)
    }
    return result
  }

  /**
   * Remove old WebKit gradient too
   */
  old(prefix) {
    if (prefix === '-webkit-') {
      let type = this.name === 'linear-gradient' ? 'linear' : 'radial'
      let string = '-gradient'
      let regexp = utils.regexp(
        `-webkit-(${type}-gradient|gradient\\(\\s*${type})`,
        false
      )

      return new OldValue(this.name, prefix + this.name, string, regexp)
    } else {
      return super.old(prefix)
    }
  }

  /**
   * Do not add non-webkit prefixes for list-style and object
   */
  add(decl, prefix) {
    let p = decl.prop
    if (p.includes('mask')) {
      if (prefix === '-webkit-' || prefix === '-webkit- old') {
        return super.add(decl, prefix)
      }
    } else if (
      p === 'list-style' ||
      p === 'list-style-image' ||
      p === 'content'
    ) {
      if (prefix === '-webkit-' || prefix === '-webkit- old') {
        return super.add(decl, prefix)
      }
    } else {
      return super.add(decl, prefix)
    }
    return undefined
  }
}

Gradient.names = [
  'linear-gradient',
  'repeating-linear-gradient',
  'radial-gradient',
  'repeating-radial-gradient'
]

Gradient.directions = {
  top: 'bottom',
  left: 'right',
  bottom: 'top',
  right: 'left'
}

// Direction to replace
Gradient.oldDirections = {
  'top': 'left bottom, left top',
  'left': 'right top, left top',
  'bottom': 'left top, left bottom',
  'right': 'left top, right top',

  'top right': 'left bottom, right top',
  'top left': 'right bottom, left top',
  'right top': 'left bottom, right top',
  'right bottom': 'left top, right bottom',
  'bottom right': 'left top, right bottom',
  'bottom left': 'right top, left bottom',
  'left top': 'right bottom, left top',
  'left bottom': 'right top, left bottom'
}

module.exports = Gradient


/***/ }),

/***/ 85159:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(73398)

class GridArea extends Declaration {
  /**
   * Translate grid-area to separate -ms- prefixed properties
   */
  insert(decl, prefix, prefixes, result) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    let values = utils.parse(decl)

    let [rowStart, rowSpan] = utils.translate(values, 0, 2)
    let [columnStart, columnSpan] = utils.translate(values, 1, 3)

    ;[
      ['grid-row', rowStart],
      ['grid-row-span', rowSpan],
      ['grid-column', columnStart],
      ['grid-column-span', columnSpan]
    ].forEach(([prop, value]) => {
      utils.insertDecl(decl, prop, value)
    })

    utils.warnTemplateSelectorNotFound(decl, result)
    utils.warnIfGridRowColumnExists(decl, result)

    return undefined
  }
}

GridArea.names = ['grid-area']

module.exports = GridArea


/***/ }),

/***/ 4621:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class GridColumnAlign extends Declaration {
  /**
   * Do not prefix flexbox values
   */
  check(decl) {
    return !decl.value.includes('flex-') && decl.value !== 'baseline'
  }

  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    return prefix + 'grid-column-align'
  }

  /**
   * Change IE property back
   */
  normalize() {
    return 'justify-self'
  }
}

GridColumnAlign.names = ['grid-column-align']

module.exports = GridColumnAlign


/***/ }),

/***/ 6307:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class GridEnd extends Declaration {
  /**
   * Change repeating syntax for IE
   */
  insert(decl, prefix, prefixes, result) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    let clonedDecl = this.clone(decl)

    let startProp = decl.prop.replace(/end$/, 'start')
    let spanProp = prefix + decl.prop.replace(/end$/, 'span')

    if (decl.parent.some(i => i.prop === spanProp)) {
      return undefined
    }

    clonedDecl.prop = spanProp

    if (decl.value.includes('span')) {
      clonedDecl.value = decl.value.replace(/span\s/i, '')
    } else {
      let startDecl
      decl.parent.walkDecls(startProp, d => {
        startDecl = d
      })
      if (startDecl) {
        let value = Number(decl.value) - Number(startDecl.value) + ''
        clonedDecl.value = value
      } else {
        decl.warn(
          result,
          `Can not prefix ${decl.prop} (${startProp} is not found)`
        )
      }
    }

    decl.cloneBefore(clonedDecl)

    return undefined
  }
}

GridEnd.names = ['grid-row-end', 'grid-column-end']

module.exports = GridEnd


/***/ }),

/***/ 85565:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class GridRowAlign extends Declaration {
  /**
   * Do not prefix flexbox values
   */
  check(decl) {
    return !decl.value.includes('flex-') && decl.value !== 'baseline'
  }

  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    return prefix + 'grid-row-align'
  }

  /**
   * Change IE property back
   */
  normalize() {
    return 'align-self'
  }
}

GridRowAlign.names = ['grid-row-align']

module.exports = GridRowAlign


/***/ }),

/***/ 98041:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(73398)

class GridRowColumn extends Declaration {
  /**
   * Translate grid-row / grid-column to separate -ms- prefixed properties
   */
  insert(decl, prefix, prefixes) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    let values = utils.parse(decl)
    let [start, span] = utils.translate(values, 0, 1)

    let hasStartValueSpan = values[0] && values[0].includes('span')

    if (hasStartValueSpan) {
      span = values[0].join('').replace(/\D/g, '')
    }

    ;[
      [decl.prop, start],
      [`${decl.prop}-span`, span]
    ].forEach(([prop, value]) => {
      utils.insertDecl(decl, prop, value)
    })

    return undefined
  }
}

GridRowColumn.names = ['grid-row', 'grid-column']

module.exports = GridRowColumn


/***/ }),

/***/ 39572:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let {
  prefixTrackProp,
  prefixTrackValue,
  autoplaceGridItems,
  getGridGap,
  inheritGridGap
} = __nccwpck_require__(73398)
let Processor = __nccwpck_require__(54108)

class GridRowsColumns extends Declaration {
  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    if (prefix === '-ms-') {
      return prefixTrackProp({ prop, prefix })
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Change IE property back
   */
  normalize(prop) {
    return prop.replace(/^grid-(rows|columns)/, 'grid-template-$1')
  }

  insert(decl, prefix, prefixes, result) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    let { parent, prop, value } = decl
    let isRowProp = prop.includes('rows')
    let isColumnProp = prop.includes('columns')

    let hasGridTemplate = parent.some(
      i => i.prop === 'grid-template' || i.prop === 'grid-template-areas'
    )

    /**
     * Not to prefix rows declaration if grid-template(-areas) is present
     */
    if (hasGridTemplate && isRowProp) {
      return false
    }

    let processor = new Processor({ options: {} })
    let status = processor.gridStatus(parent, result)
    let gap = getGridGap(decl)
    gap = inheritGridGap(decl, gap) || gap

    let gapValue = isRowProp ? gap.row : gap.column

    if ((status === 'no-autoplace' || status === true) && !hasGridTemplate) {
      gapValue = null
    }

    let prefixValue = prefixTrackValue({
      value,
      gap: gapValue
    })

    /**
     * Insert prefixes
     */
    decl.cloneBefore({
      prop: prefixTrackProp({ prop, prefix }),
      value: prefixValue
    })

    let autoflow = parent.nodes.find(i => i.prop === 'grid-auto-flow')
    let autoflowValue = 'row'

    if (autoflow && !processor.disabled(autoflow, result)) {
      autoflowValue = autoflow.value.trim()
    }
    if (status === 'autoplace') {
      /**
       * Show warning if grid-template-rows decl is not found
       */
      let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows')

      if (!rowDecl && hasGridTemplate) {
        return undefined
      } else if (!rowDecl && !hasGridTemplate) {
        decl.warn(
          result,
          'Autoplacement does not work without grid-template-rows property'
        )
        return undefined
      }

      /**
       * Show warning if grid-template-columns decl is not found
       */
      let columnDecl = parent.nodes.find(i => {
        return i.prop === 'grid-template-columns'
      })
      if (!columnDecl && !hasGridTemplate) {
        decl.warn(
          result,
          'Autoplacement does not work without grid-template-columns property'
        )
      }

      /**
       * Autoplace grid items
       */
      if (isColumnProp && !hasGridTemplate) {
        autoplaceGridItems(decl, result, gap, autoflowValue)
      }
    }

    return undefined
  }
}

GridRowsColumns.names = [
  'grid-template-rows',
  'grid-template-columns',
  'grid-rows',
  'grid-columns'
]

module.exports = GridRowsColumns


/***/ }),

/***/ 57526:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class GridStart extends Declaration {
  /**
   * Do not add prefix for unsupported value in IE
   */
  check(decl) {
    let value = decl.value
    return !value.includes('/') || value.includes('span')
  }

  /**
   * Return a final spec property
   */
  normalize(prop) {
    return prop.replace('-start', '')
  }

  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    let result = super.prefixed(prop, prefix)
    if (prefix === '-ms-') {
      result = result.replace('-start', '')
    }
    return result
  }
}

GridStart.names = ['grid-row-start', 'grid-column-start']

module.exports = GridStart


/***/ }),

/***/ 10577:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let {
  parseGridAreas,
  warnMissedAreas,
  prefixTrackProp,
  prefixTrackValue,
  getGridGap,
  warnGridGap,
  inheritGridGap
} = __nccwpck_require__(73398)

function getGridRows(tpl) {
  return tpl
    .trim()
    .slice(1, -1)
    .split(/["']\s*["']?/g)
}

class GridTemplateAreas extends Declaration {
  /**
   * Translate grid-template-areas to separate -ms- prefixed properties
   */
  insert(decl, prefix, prefixes, result) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    let hasColumns = false
    let hasRows = false
    let parent = decl.parent
    let gap = getGridGap(decl)
    gap = inheritGridGap(decl, gap) || gap

    // remove already prefixed rows
    // to prevent doubling prefixes
    parent.walkDecls(/-ms-grid-rows/, i => i.remove())

    // add empty tracks to rows
    parent.walkDecls(/grid-template-(rows|columns)/, trackDecl => {
      if (trackDecl.prop === 'grid-template-rows') {
        hasRows = true
        let { prop, value } = trackDecl
        trackDecl.cloneBefore({
          prop: prefixTrackProp({ prop, prefix }),
          value: prefixTrackValue({ value, gap: gap.row })
        })
      } else {
        hasColumns = true
      }
    })

    let gridRows = getGridRows(decl.value)

    if (hasColumns && !hasRows && gap.row && gridRows.length > 1) {
      decl.cloneBefore({
        prop: '-ms-grid-rows',
        value: prefixTrackValue({
          value: `repeat(${gridRows.length}, auto)`,
          gap: gap.row
        }),
        raws: {}
      })
    }

    // warnings
    warnGridGap({
      gap,
      hasColumns,
      decl,
      result
    })

    let areas = parseGridAreas({
      rows: gridRows,
      gap
    })

    warnMissedAreas(areas, decl, result)

    return decl
  }
}

GridTemplateAreas.names = ['grid-template-areas']

module.exports = GridTemplateAreas


/***/ }),

/***/ 10304:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let {
  parseTemplate,
  warnMissedAreas,
  getGridGap,
  warnGridGap,
  inheritGridGap
} = __nccwpck_require__(73398)

class GridTemplate extends Declaration {
  /**
   * Translate grid-template to separate -ms- prefixed properties
   */
  insert(decl, prefix, prefixes, result) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    if (decl.parent.some(i => i.prop === '-ms-grid-rows')) {
      return undefined
    }

    let gap = getGridGap(decl)

    /**
     * we must insert inherited gap values in some cases:
     * if we are inside media query && if we have no grid-gap value
     */
    let inheritedGap = inheritGridGap(decl, gap)

    let { rows, columns, areas } = parseTemplate({
      decl,
      gap: inheritedGap || gap
    })

    let hasAreas = Object.keys(areas).length > 0
    let hasRows = Boolean(rows)
    let hasColumns = Boolean(columns)

    warnGridGap({
      gap,
      hasColumns,
      decl,
      result
    })

    warnMissedAreas(areas, decl, result)

    if ((hasRows && hasColumns) || hasAreas) {
      decl.cloneBefore({
        prop: '-ms-grid-rows',
        value: rows,
        raws: {}
      })
    }

    if (hasColumns) {
      decl.cloneBefore({
        prop: '-ms-grid-columns',
        value: columns,
        raws: {}
      })
    }

    return decl
  }
}

GridTemplate.names = ['grid-template']

module.exports = GridTemplate


/***/ }),

/***/ 73398:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

let parser = __nccwpck_require__(19285)
let list = __nccwpck_require__(77001).list

let uniq = __nccwpck_require__(96584).uniq
let escapeRegexp = __nccwpck_require__(96584).escapeRegexp
let splitSelector = __nccwpck_require__(96584).splitSelector

function convert(value) {
  if (
    value &&
    value.length === 2 &&
    value[0] === 'span' &&
    parseInt(value[1], 10) > 0
  ) {
    return [false, parseInt(value[1], 10)]
  }

  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {
    return [parseInt(value[0], 10), false]
  }

  return [false, false]
}

exports.translate = translate

function translate(values, startIndex, endIndex) {
  let startValue = values[startIndex]
  let endValue = values[endIndex]

  if (!startValue) {
    return [false, false]
  }

  let [start, spanStart] = convert(startValue)
  let [end, spanEnd] = convert(endValue)

  if (start && !endValue) {
    return [start, false]
  }

  if (spanStart && end) {
    return [end - spanStart, spanStart]
  }

  if (start && spanEnd) {
    return [start, spanEnd]
  }

  if (start && end) {
    return [start, end - start]
  }

  return [false, false]
}

exports.parse = parse

function parse(decl) {
  let node = parser(decl.value)

  let values = []
  let current = 0
  values[current] = []

  for (let i of node.nodes) {
    if (i.type === 'div') {
      current += 1
      values[current] = []
    } else if (i.type === 'word') {
      values[current].push(i.value)
    }
  }

  return values
}

exports.insertDecl = insertDecl

function insertDecl(decl, prop, value) {
  if (value && !decl.parent.some(i => i.prop === `-ms-${prop}`)) {
    decl.cloneBefore({
      prop: `-ms-${prop}`,
      value: value.toString()
    })
  }
}

// Track transforms

exports.prefixTrackProp = prefixTrackProp

function prefixTrackProp({ prop, prefix }) {
  return prefix + prop.replace('template-', '')
}

function transformRepeat({ nodes }, { gap }) {
  let { count, size } = nodes.reduce(
    (result, node) => {
      if (node.type === 'div' && node.value === ',') {
        result.key = 'size'
      } else {
        result[result.key].push(parser.stringify(node))
      }
      return result
    },
    {
      key: 'count',
      size: [],
      count: []
    }
  )

  // insert gap values
  if (gap) {
    size = size.filter(i => i.trim())
    let val = []
    for (let i = 1; i <= count; i++) {
      size.forEach((item, index) => {
        if (index > 0 || i > 1) {
          val.push(gap)
        }
        val.push(item)
      })
    }

    return val.join(' ')
  }

  return `(${size.join('')})[${count.join('')}]`
}

exports.prefixTrackValue = prefixTrackValue

function prefixTrackValue({ value, gap }) {
  let result = parser(value).nodes.reduce((nodes, node) => {
    if (node.type === 'function' && node.value === 'repeat') {
      return nodes.concat({
        type: 'word',
        value: transformRepeat(node, { gap })
      })
    }
    if (gap && node.type === 'space') {
      return nodes.concat(
        {
          type: 'space',
          value: ' '
        },
        {
          type: 'word',
          value: gap
        },
        node
      )
    }
    return nodes.concat(node)
  }, [])

  return parser.stringify(result)
}

// Parse grid-template-areas

let DOTS = /^\.+$/

function track(start, end) {
  return { start, end, span: end - start }
}

function getColumns(line) {
  return line.trim().split(/\s+/g)
}

exports.parseGridAreas = parseGridAreas

function parseGridAreas({ rows, gap }) {
  return rows.reduce((areas, line, rowIndex) => {
    if (gap.row) rowIndex *= 2

    if (line.trim() === '') return areas

    getColumns(line).forEach((area, columnIndex) => {
      if (DOTS.test(area)) return

      if (gap.column) columnIndex *= 2

      if (typeof areas[area] === 'undefined') {
        areas[area] = {
          column: track(columnIndex + 1, columnIndex + 2),
          row: track(rowIndex + 1, rowIndex + 2)
        }
      } else {
        let { column, row } = areas[area]

        column.start = Math.min(column.start, columnIndex + 1)
        column.end = Math.max(column.end, columnIndex + 2)
        column.span = column.end - column.start

        row.start = Math.min(row.start, rowIndex + 1)
        row.end = Math.max(row.end, rowIndex + 2)
        row.span = row.end - row.start
      }
    })

    return areas
  }, {})
}

// Parse grid-template

function testTrack(node) {
  return node.type === 'word' && /^\[.+]$/.test(node.value)
}

function verifyRowSize(result) {
  if (result.areas.length > result.rows.length) {
    result.rows.push('auto')
  }
  return result
}

exports.parseTemplate = parseTemplate

function parseTemplate({ decl, gap }) {
  let gridTemplate = parser(decl.value).nodes.reduce(
    (result, node) => {
      let { type, value } = node

      if (testTrack(node) || type === 'space') return result

      // area
      if (type === 'string') {
        result = verifyRowSize(result)
        result.areas.push(value)
      }

      // values and function
      if (type === 'word' || type === 'function') {
        result[result.key].push(parser.stringify(node))
      }

      // divider(/)
      if (type === 'div' && value === '/') {
        result.key = 'columns'
        result = verifyRowSize(result)
      }

      return result
    },
    {
      key: 'rows',
      columns: [],
      rows: [],
      areas: []
    }
  )

  return {
    areas: parseGridAreas({
      rows: gridTemplate.areas,
      gap
    }),
    columns: prefixTrackValue({
      value: gridTemplate.columns.join(' '),
      gap: gap.column
    }),
    rows: prefixTrackValue({
      value: gridTemplate.rows.join(' '),
      gap: gap.row
    })
  }
}

// Insert parsed grid areas

/**
 * Get an array of -ms- prefixed props and values
 * @param  {Object} [area] area object with column and row data
 * @param  {Boolean} [addRowSpan] should we add grid-column-row value?
 * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?
 * @return {Array<Object>}
 */
function getMSDecls(area, addRowSpan = false, addColumnSpan = false) {
  let result = [
    {
      prop: '-ms-grid-row',
      value: String(area.row.start)
    }
  ]
  if (area.row.span > 1 || addRowSpan) {
    result.push({
      prop: '-ms-grid-row-span',
      value: String(area.row.span)
    })
  }
  result.push({
    prop: '-ms-grid-column',
    value: String(area.column.start)
  })
  if (area.column.span > 1 || addColumnSpan) {
    result.push({
      prop: '-ms-grid-column-span',
      value: String(area.column.span)
    })
  }
  return result
}

function getParentMedia(parent) {
  if (parent.type === 'atrule' && parent.name === 'media') {
    return parent
  }
  if (!parent.parent) {
    return false
  }
  return getParentMedia(parent.parent)
}

/**
 * change selectors for rules with duplicate grid-areas.
 * @param  {Array<Rule>} rules
 * @param  {Array<String>} templateSelectors
 * @return {Array<Rule>} rules with changed selectors
 */
function changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {
  ruleSelectors = ruleSelectors.map(selector => {
    let selectorBySpace = list.space(selector)
    let selectorByComma = list.comma(selector)

    if (selectorBySpace.length > selectorByComma.length) {
      selector = selectorBySpace.slice(-1).join('')
    }
    return selector
  })

  return ruleSelectors.map(ruleSelector => {
    let newSelector = templateSelectors.map((tplSelector, index) => {
      let space = index === 0 ? '' : ' '
      return `${space}${tplSelector} > ${ruleSelector}`
    })

    return newSelector
  })
}

/**
 * check if selector of rules are equal
 * @param  {Rule} ruleA
 * @param  {Rule} ruleB
 * @return {Boolean}
 */
function selectorsEqual(ruleA, ruleB) {
  return ruleA.selectors.some(sel => {
    return ruleB.selectors.includes(sel)
  })
}

/**
 * Parse data from all grid-template(-areas) declarations
 * @param  {Root} css css root
 * @return {Object} parsed data
 */
function parseGridTemplatesData(css) {
  let parsed = []

  // we walk through every grid-template(-areas) declaration and store
  // data with the same area names inside the item
  css.walkDecls(/grid-template(-areas)?$/, d => {
    let rule = d.parent
    let media = getParentMedia(rule)
    let gap = getGridGap(d)
    let inheritedGap = inheritGridGap(d, gap)
    let { areas } = parseTemplate({ decl: d, gap: inheritedGap || gap })
    let areaNames = Object.keys(areas)

    // skip node if it doesn't have areas
    if (areaNames.length === 0) {
      return true
    }

    // check parsed array for item that include the same area names
    // return index of that item
    let index = parsed.reduce((acc, { allAreas }, idx) => {
      let hasAreas = allAreas && areaNames.some(area => allAreas.includes(area))
      return hasAreas ? idx : acc
    }, null)

    if (index !== null) {
      // index is found, add the grid-template data to that item
      let { allAreas, rules } = parsed[index]

      // check if rule has no duplicate area names
      let hasNoDuplicates = rules.some(r => {
        return r.hasDuplicates === false && selectorsEqual(r, rule)
      })

      let duplicatesFound = false

      // check need to gather all duplicate area names
      let duplicateAreaNames = rules.reduce((acc, r) => {
        if (!r.params && selectorsEqual(r, rule)) {
          duplicatesFound = true
          return r.duplicateAreaNames
        }
        if (!duplicatesFound) {
          areaNames.forEach(name => {
            if (r.areas[name]) {
              acc.push(name)
            }
          })
        }
        return uniq(acc)
      }, [])

      // update grid-row/column-span values for areas with duplicate
      // area names. @see #1084 and #1146
      rules.forEach(r => {
        areaNames.forEach(name => {
          let area = r.areas[name]
          if (area && area.row.span !== areas[name].row.span) {
            areas[name].row.updateSpan = true
          }

          if (area && area.column.span !== areas[name].column.span) {
            areas[name].column.updateSpan = true
          }
        })
      })

      parsed[index].allAreas = uniq([...allAreas, ...areaNames])
      parsed[index].rules.push({
        hasDuplicates: !hasNoDuplicates,
        params: media.params,
        selectors: rule.selectors,
        node: rule,
        duplicateAreaNames,
        areas
      })
    } else {
      // index is NOT found, push the new item to the parsed array
      parsed.push({
        allAreas: areaNames,
        areasCount: 0,
        rules: [
          {
            hasDuplicates: false,
            duplicateRules: [],
            params: media.params,
            selectors: rule.selectors,
            node: rule,
            duplicateAreaNames: [],
            areas
          }
        ]
      })
    }

    return undefined
  })

  return parsed
}

/**
 * insert prefixed grid-area declarations
 * @param  {Root}  css css root
 * @param  {Function} isDisabled check if the rule is disabled
 * @return {void}
 */
exports.insertAreas = insertAreas

function insertAreas(css, isDisabled) {
  // parse grid-template declarations
  let gridTemplatesData = parseGridTemplatesData(css)

  // return undefined if no declarations found
  if (gridTemplatesData.length === 0) {
    return undefined
  }

  // we need to store the rules that we will insert later
  let rulesToInsert = {}

  css.walkDecls('grid-area', gridArea => {
    let gridAreaRule = gridArea.parent
    let hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row'
    let gridAreaMedia = getParentMedia(gridAreaRule)

    if (isDisabled(gridArea)) {
      return undefined
    }

    let gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule)

    let value = gridArea.value
    // found the data that matches grid-area identifier
    let data = gridTemplatesData.filter(d => d.allAreas.includes(value))[0]

    if (!data) {
      return true
    }

    let lastArea = data.allAreas[data.allAreas.length - 1]
    let selectorBySpace = list.space(gridAreaRule.selector)
    let selectorByComma = list.comma(gridAreaRule.selector)
    let selectorIsComplex =
      selectorBySpace.length > 1 &&
      selectorBySpace.length > selectorByComma.length

    // prevent doubling of prefixes
    if (hasPrefixedRow) {
      return false
    }

    // create the empty object with the key as the last area name
    // e.g if we have templates with "a b c" values, "c" will be the last area
    if (!rulesToInsert[lastArea]) {
      rulesToInsert[lastArea] = {}
    }

    let lastRuleIsSet = false

    // walk through every grid-template rule data
    for (let rule of data.rules) {
      let area = rule.areas[value]
      let hasDuplicateName = rule.duplicateAreaNames.includes(value)

      // if we can't find the area name, update lastRule and continue
      if (!area) {
        let lastRule = rulesToInsert[lastArea].lastRule
        let lastRuleIndex
        if (lastRule) {
          lastRuleIndex = css.index(lastRule)
        } else {
          /* istanbul ignore next */
          lastRuleIndex = -1
        }

        if (gridAreaRuleIndex > lastRuleIndex) {
          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule
        }
        continue
      }

      // for grid-templates inside media rule we need to create empty
      // array to push prefixed grid-area rules later
      if (rule.params && !rulesToInsert[lastArea][rule.params]) {
        rulesToInsert[lastArea][rule.params] = []
      }

      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {
        // grid-template has no duplicates and not inside media rule

        getMSDecls(area, false, false)
          .reverse()
          .forEach(i =>
            gridAreaRule.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )

        rulesToInsert[lastArea].lastRule = gridAreaRule
        lastRuleIsSet = true
      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {
        // grid-template has duplicates and not inside media rule
        let cloned = gridAreaRule.clone()
        cloned.removeAll()

        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =>
            cloned.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )

        cloned.selectors = changeDuplicateAreaSelectors(
          cloned.selectors,
          rule.selectors
        )

        if (rulesToInsert[lastArea].lastRule) {
          rulesToInsert[lastArea].lastRule.after(cloned)
        }
        rulesToInsert[lastArea].lastRule = cloned
        lastRuleIsSet = true
      } else if (
        rule.hasDuplicates &&
        !rule.params &&
        selectorIsComplex &&
        gridAreaRule.selector.includes(rule.selectors[0])
      ) {
        // grid-template has duplicates and not inside media rule
        // and the selector is complex
        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, d => d.remove())
        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =>
            gridAreaRule.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )
      } else if (rule.params) {
        // grid-template is inside media rule
        // if we're inside media rule, we need to store prefixed rules
        // inside rulesToInsert object to be able to preserve the order of media
        // rules and merge them easily
        let cloned = gridAreaRule.clone()
        cloned.removeAll()

        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =>
            cloned.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )

        if (rule.hasDuplicates && hasDuplicateName) {
          cloned.selectors = changeDuplicateAreaSelectors(
            cloned.selectors,
            rule.selectors
          )
        }

        cloned.raws = rule.node.raws

        if (css.index(rule.node.parent) > gridAreaRuleIndex) {
          // append the prefixed rules right inside media rule
          // with grid-template
          rule.node.parent.append(cloned)
        } else {
          // store the rule to insert later
          rulesToInsert[lastArea][rule.params].push(cloned)
        }

        // set new rule as last rule ONLY if we didn't set lastRule for
        // this grid-area before
        if (!lastRuleIsSet) {
          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule
        }
      }
    }

    return undefined
  })

  // append stored rules inside the media rules
  Object.keys(rulesToInsert).forEach(area => {
    let data = rulesToInsert[area]
    let lastRule = data.lastRule
    Object.keys(data)
      .reverse()
      .filter(p => p !== 'lastRule')
      .forEach(params => {
        if (data[params].length > 0 && lastRule) {
          lastRule.after({ name: 'media', params })
          lastRule.next().append(data[params])
        }
      })
  })

  return undefined
}

/**
 * Warn user if grid area identifiers are not found
 * @param  {Object} areas
 * @param  {Declaration} decl
 * @param  {Result} result
 * @return {void}
 */
exports.warnMissedAreas = warnMissedAreas

function warnMissedAreas(areas, decl, result) {
  let missed = Object.keys(areas)

  decl.root().walkDecls('grid-area', gridArea => {
    missed = missed.filter(e => e !== gridArea.value)
  })

  if (missed.length > 0) {
    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '))
  }

  return undefined
}

/**
 * compare selectors with grid-area rule and grid-template rule
 * show warning if grid-template selector is not found
 * (this function used for grid-area rule)
 * @param  {Declaration} decl
 * @param  {Result} result
 * @return {void}
 */
exports.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound

function warnTemplateSelectorNotFound(decl, result) {
  let rule = decl.parent
  let root = decl.root()
  let duplicatesFound = false

  // slice selector array. Remove the last part (for comparison)
  let slicedSelectorArr = list
    .space(rule.selector)
    .filter(str => str !== '>')
    .slice(0, -1)

  // we need to compare only if selector is complex.
  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex
  if (slicedSelectorArr.length > 0) {
    let gridTemplateFound = false
    let foundAreaSelector = null

    root.walkDecls(/grid-template(-areas)?$/, d => {
      let parent = d.parent
      let templateSelectors = parent.selectors

      let { areas } = parseTemplate({ decl: d, gap: getGridGap(d) })
      let hasArea = areas[decl.value]

      // find the the matching selectors
      for (let tplSelector of templateSelectors) {
        if (gridTemplateFound) {
          break
        }
        let tplSelectorArr = list.space(tplSelector).filter(str => str !== '>')

        gridTemplateFound = tplSelectorArr.every(
          (item, idx) => item === slicedSelectorArr[idx]
        )
      }

      if (gridTemplateFound || !hasArea) {
        return true
      }

      if (!foundAreaSelector) {
        foundAreaSelector = parent.selector
      }

      // if we found the duplicate area with different selector
      if (foundAreaSelector && foundAreaSelector !== parent.selector) {
        duplicatesFound = true
      }

      return undefined
    })

    // warn user if we didn't find template
    if (!gridTemplateFound && duplicatesFound) {
      decl.warn(
        result,
        'Autoprefixer cannot find a grid-template ' +
          `containing the duplicate grid-area "${decl.value}" ` +
          `with full selector matching: ${slicedSelectorArr.join(' ')}`
      )
    }
  }
}

/**
 * warn user if both grid-area and grid-(row|column)
 * declarations are present in the same rule
 * @param  {Declaration} decl
 * @param  {Result} result
 * @return {void}
 */
exports.warnIfGridRowColumnExists = warnIfGridRowColumnExists

function warnIfGridRowColumnExists(decl, result) {
  let rule = decl.parent
  let decls = []
  rule.walkDecls(/^grid-(row|column)/, d => {
    if (
      !d.prop.endsWith('-end') &&
      !d.value.startsWith('span') &&
      !d.prop.endsWith('-gap')
    ) {
      decls.push(d)
    }
  })
  if (decls.length > 0) {
    decls.forEach(d => {
      d.warn(
        result,
        'You already have a grid-area declaration present in the rule. ' +
          `You should use either grid-area or ${d.prop}, not both`
      )
    })
  }

  return undefined
}

// Gap utils

exports.getGridGap = getGridGap

function getGridGap(decl) {
  let gap = {}

  // try to find gap
  let testGap = /^(grid-)?((row|column)-)?gap$/
  decl.parent.walkDecls(testGap, ({ prop, value }) => {
    if (/^(grid-)?gap$/.test(prop)) {
      let [row, , column] = parser(value).nodes

      gap.row = row && parser.stringify(row)
      gap.column = column ? parser.stringify(column) : gap.row
    }
    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value
    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value
  })

  return gap
}

/**
 * parse media parameters (for example 'min-width: 500px')
 * @param  {String} params parameter to parse
 * @return {}
 */
function parseMediaParams(params) {
  if (!params) {
    return []
  }
  let parsed = parser(params)
  let prop
  let value

  parsed.walk(node => {
    if (node.type === 'word' && /min|max/g.test(node.value)) {
      prop = node.value
    } else if (node.value.includes('px')) {
      value = parseInt(node.value.replace(/\D/g, ''))
    }
  })

  return [prop, value]
}

/**
 * Compare the selectors and decide if we
 * need to inherit gap from compared selector or not.
 * @type {String} selA
 * @type {String} selB
 * @return {Boolean}
 */
function shouldInheritGap(selA, selB) {
  let result

  // get arrays of selector split in 3-deep array
  let splitSelectorArrA = splitSelector(selA)
  let splitSelectorArrB = splitSelector(selB)

  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {
    // abort if selectorA has lower descendant specificity then selectorB
    // (e.g '.grid' and '.hello .world .grid')
    return false
  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {
    // if selectorA has higher descendant specificity then selectorB
    // (e.g '.foo .bar .grid' and '.grid')

    let idx = splitSelectorArrA[0].reduce((res, [item], index) => {
      let firstSelectorPart = splitSelectorArrB[0][0][0]
      if (item === firstSelectorPart) {
        return index
      }
      return false
    }, false)

    if (idx) {
      result = splitSelectorArrB[0].every((arr, index) => {
        return arr.every(
          (part, innerIndex) =>
            // because selectorA has more space elements, we need to slice
            // selectorA array by 'idx' number to compare them
            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part
        )
      })
    }
  } else {
    // if selectorA has the same descendant specificity as selectorB
    // this condition covers cases such as: '.grid.foo.bar' and '.grid'
    result = splitSelectorArrB.some(byCommaArr => {
      return byCommaArr.every((bySpaceArr, index) => {
        return bySpaceArr.every(
          (part, innerIndex) => splitSelectorArrA[0][index][innerIndex] === part
        )
      })
    })
  }

  return result
}
/**
 * inherit grid gap values from the closest rule above
 * with the same selector
 * @param  {Declaration} decl
 * @param  {Object} gap gap values
 * @return {Object | Boolean} return gap values or false (if not found)
 */
exports.inheritGridGap = inheritGridGap

function inheritGridGap(decl, gap) {
  let rule = decl.parent
  let mediaRule = getParentMedia(rule)
  let root = rule.root()

  // get an array of selector split in 3-deep array
  let splitSelectorArr = splitSelector(rule.selector)

  // abort if the rule already has gaps
  if (Object.keys(gap).length > 0) {
    return false
  }

  // e.g ['min-width']
  let [prop] = parseMediaParams(mediaRule.params)

  let lastBySpace = splitSelectorArr[0]

  // get escaped value from the selector
  // if we have '.grid-2.foo.bar' selector, will be '\.grid\-2'
  let escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0])

  let regexp = new RegExp(`(${escaped}$)|(${escaped}[,.])`)

  // find the closest rule with the same selector
  let closestRuleGap
  root.walkRules(regexp, r => {
    let gridGap

    // abort if are checking the same rule
    if (rule.toString() === r.toString()) {
      return false
    }

    // find grid-gap values
    r.walkDecls('grid-gap', d => (gridGap = getGridGap(d)))

    // skip rule without gaps
    if (!gridGap || Object.keys(gridGap).length === 0) {
      return true
    }

    // skip rules that should not be inherited from
    if (!shouldInheritGap(rule.selector, r.selector)) {
      return true
    }

    let media = getParentMedia(r)
    if (media) {
      // if we are inside media, we need to check that media props match
      // e.g ('min-width' === 'min-width')
      let propToCompare = parseMediaParams(media.params)[0]
      if (propToCompare === prop) {
        closestRuleGap = gridGap
        return true
      }
    } else {
      closestRuleGap = gridGap
      return true
    }

    return undefined
  })

  // if we find the closest gap object
  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {
    return closestRuleGap
  }
  return false
}

exports.warnGridGap = warnGridGap

function warnGridGap({ gap, hasColumns, decl, result }) {
  let hasBothGaps = gap.row && gap.column
  if (!hasColumns && (hasBothGaps || (gap.column && !gap.row))) {
    delete gap.column
    decl.warn(
      result,
      'Can not implement grid-gap without grid-template-columns'
    )
  }
}

/**
 * normalize the grid-template-rows/columns values
 * @param  {String} str grid-template-rows/columns value
 * @return {Array} normalized array with values
 * @example
 * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')
 * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']
 */
function normalizeRowColumn(str) {
  let normalized = parser(str).nodes.reduce((result, node) => {
    if (node.type === 'function' && node.value === 'repeat') {
      let key = 'count'

      let [count, value] = node.nodes.reduce(
        (acc, n) => {
          if (n.type === 'word' && key === 'count') {
            acc[0] = Math.abs(parseInt(n.value))
            return acc
          }
          if (n.type === 'div' && n.value === ',') {
            key = 'value'
            return acc
          }
          if (key === 'value') {
            acc[1] += parser.stringify(n)
          }
          return acc
        },
        [0, '']
      )

      if (count) {
        for (let i = 0; i < count; i++) {
          result.push(value)
        }
      }

      return result
    }
    if (node.type === 'space') {
      return result
    }
    return result.concat(parser.stringify(node))
  }, [])

  return normalized
}

exports.autoplaceGridItems = autoplaceGridItems

/**
 * Autoplace grid items
 * @param {Declaration} decl
 * @param {Result} result
 * @param {Object} gap gap values
 * @param {String} autoflowValue grid-auto-flow value
 * @return {void}
 * @see https://github.com/postcss/autoprefixer/issues/1148
 */
function autoplaceGridItems(decl, result, gap, autoflowValue = 'row') {
  let { parent } = decl

  let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows')
  let rows = normalizeRowColumn(rowDecl.value)
  let columns = normalizeRowColumn(decl.value)

  // Build array of area names with dummy values. If we have 3 columns and
  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']
  let filledRows = rows.map((_, rowIndex) => {
    return Array.from(
      { length: columns.length },
      (v, k) => k + rowIndex * columns.length + 1
    ).join(' ')
  })

  let areas = parseGridAreas({ rows: filledRows, gap })
  let keys = Object.keys(areas)
  let items = keys.map(i => areas[i])

  // Change the order of cells if grid-auto-flow value is 'column'
  if (autoflowValue.includes('column')) {
    items = items.sort((a, b) => a.column.start - b.column.start)
  }

  // Insert new rules
  items.reverse().forEach((item, index) => {
    let { column, row } = item
    let nodeSelector = parent.selectors
      .map(sel => sel + ` > *:nth-child(${keys.length - index})`)
      .join(', ')

    // create new rule
    let node = parent.clone().removeAll()

    // change rule selector
    node.selector = nodeSelector

    // insert prefixed row/column values
    node.append({ prop: '-ms-grid-row', value: row.start })
    node.append({ prop: '-ms-grid-column', value: column.start })

    // insert rule
    parent.after(node)
  })

  return undefined
}


/***/ }),

/***/ 27453:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class ImageRendering extends Declaration {
  /**
   * Add hack only for crisp-edges
   */
  check(decl) {
    return decl.value === 'pixelated'
  }

  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    if (prefix === '-ms-') {
      return '-ms-interpolation-mode'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Change property and value for IE
   */
  set(decl, prefix) {
    if (prefix !== '-ms-') return super.set(decl, prefix)
    decl.prop = '-ms-interpolation-mode'
    decl.value = 'nearest-neighbor'
    return decl
  }

  /**
   * Return property name by spec
   */
  normalize() {
    return 'image-rendering'
  }

  /**
   * Warn on old value
   */
  process(node, result) {
    return super.process(node, result)
  }
}

ImageRendering.names = ['image-rendering', 'interpolation-mode']

module.exports = ImageRendering


/***/ }),

/***/ 93812:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Value = __nccwpck_require__(52530)

class ImageSet extends Value {
  /**
   * Use non-standard name for WebKit and Firefox
   */
  replace(string, prefix) {
    let fixed = super.replace(string, prefix)
    if (prefix === '-webkit-') {
      fixed = fixed.replace(/("[^"]+"|'[^']+')(\s+\d+\w)/gi, 'url($1)$2')
    }
    return fixed
  }
}

ImageSet.names = ['image-set']

module.exports = ImageSet


/***/ }),

/***/ 10330:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class InlineLogical extends Declaration {
  /**
   * Use old syntax for -moz- and -webkit-
   */
  prefixed(prop, prefix) {
    return prefix + prop.replace('-inline', '')
  }

  /**
   * Return property name by spec
   */
  normalize(prop) {
    return prop.replace(/(margin|padding|border)-(start|end)/, '$1-inline-$2')
  }
}

InlineLogical.names = [
  'border-inline-start',
  'border-inline-end',
  'margin-inline-start',
  'margin-inline-end',
  'padding-inline-start',
  'padding-inline-end',
  'border-start',
  'border-end',
  'margin-start',
  'margin-end',
  'padding-start',
  'padding-end'
]

module.exports = InlineLogical


/***/ }),

/***/ 10325:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let OldValue = __nccwpck_require__(86029)
let Value = __nccwpck_require__(52530)

function regexp(name) {
  return new RegExp(`(^|[\\s,(])(${name}($|[\\s),]))`, 'gi')
}

class Intrinsic extends Value {
  regexp() {
    if (!this.regexpCache) this.regexpCache = regexp(this.name)
    return this.regexpCache
  }

  isStretch() {
    return (
      this.name === 'stretch' ||
      this.name === 'fill' ||
      this.name === 'fill-available'
    )
  }

  replace(string, prefix) {
    if (prefix === '-moz-' && this.isStretch()) {
      return string.replace(this.regexp(), '$1-moz-available$3')
    }
    if (prefix === '-webkit-' && this.isStretch()) {
      return string.replace(this.regexp(), '$1-webkit-fill-available$3')
    }
    return super.replace(string, prefix)
  }

  old(prefix) {
    let prefixed = prefix + this.name
    if (this.isStretch()) {
      if (prefix === '-moz-') {
        prefixed = '-moz-available'
      } else if (prefix === '-webkit-') {
        prefixed = '-webkit-fill-available'
      }
    }
    return new OldValue(this.name, prefixed, prefixed, regexp(prefixed))
  }

  add(decl, prefix) {
    if (decl.prop.includes('grid') && prefix !== '-webkit-') {
      return undefined
    }
    return super.add(decl, prefix)
  }
}

Intrinsic.names = [
  'max-content',
  'min-content',
  'fit-content',
  'fill',
  'fill-available',
  'stretch'
]

module.exports = Intrinsic


/***/ }),

/***/ 82845:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class JustifyContent extends Declaration {
  /**
   * Change property name for 2009 and 2012 specs
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return prefix + 'box-pack'
    }
    if (spec === 2012) {
      return prefix + 'flex-pack'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'justify-content'
  }

  /**
   * Change value for 2009 and 2012 specs
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2009 || spec === 2012) {
      let value = JustifyContent.oldValues[decl.value] || decl.value
      decl.value = value
      if (spec !== 2009 || value !== 'distribute') {
        return super.set(decl, prefix)
      }
    } else if (spec === 'final') {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

JustifyContent.names = ['justify-content', 'flex-pack', 'box-pack']

JustifyContent.oldValues = {
  'flex-end': 'end',
  'flex-start': 'start',
  'space-between': 'justify',
  'space-around': 'distribute'
}

module.exports = JustifyContent


/***/ }),

/***/ 28244:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class MaskBorder extends Declaration {
  /**
   * Return property name by final spec
   */
  normalize() {
    return this.name.replace('box-image', 'border')
  }

  /**
   * Return flex property for 2012 spec
   */
  prefixed(prop, prefix) {
    let result = super.prefixed(prop, prefix)
    if (prefix === '-webkit-') {
      result = result.replace('border', 'box-image')
    }
    return result
  }
}

MaskBorder.names = [
  'mask-border',
  'mask-border-source',
  'mask-border-slice',
  'mask-border-width',
  'mask-border-outset',
  'mask-border-repeat',
  'mask-box-image',
  'mask-box-image-source',
  'mask-box-image-slice',
  'mask-box-image-width',
  'mask-box-image-outset',
  'mask-box-image-repeat'
]

module.exports = MaskBorder


/***/ }),

/***/ 67491:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class MaskComposite extends Declaration {
  /**
   * Prefix mask-composite for webkit
   */
  insert(decl, prefix, prefixes) {
    let isCompositeProp = decl.prop === 'mask-composite'

    let compositeValues

    if (isCompositeProp) {
      compositeValues = decl.value.split(',')
    } else {
      compositeValues = decl.value.match(MaskComposite.regexp) || []
    }

    compositeValues = compositeValues.map(el => el.trim()).filter(el => el)
    let hasCompositeValues = compositeValues.length

    let compositeDecl

    if (hasCompositeValues) {
      compositeDecl = this.clone(decl)
      compositeDecl.value = compositeValues
        .map(value => MaskComposite.oldValues[value] || value)
        .join(', ')

      if (compositeValues.includes('intersect')) {
        compositeDecl.value += ', xor'
      }

      compositeDecl.prop = prefix + 'mask-composite'
    }

    if (isCompositeProp) {
      if (!hasCompositeValues) {
        return undefined
      }

      if (this.needCascade(decl)) {
        compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix)
      }

      return decl.parent.insertBefore(decl, compositeDecl)
    }

    let cloned = this.clone(decl)
    cloned.prop = prefix + cloned.prop

    if (hasCompositeValues) {
      cloned.value = cloned.value.replace(MaskComposite.regexp, '')
    }

    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }

    decl.parent.insertBefore(decl, cloned)

    if (!hasCompositeValues) {
      return decl
    }

    if (this.needCascade(decl)) {
      compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    return decl.parent.insertBefore(decl, compositeDecl)
  }
}

MaskComposite.names = ['mask', 'mask-composite']

MaskComposite.oldValues = {
  add: 'source-over',
  subtract: 'source-out',
  intersect: 'source-in',
  exclude: 'xor'
}

MaskComposite.regexp = new RegExp(
  `\\s+(${Object.keys(MaskComposite.oldValues).join(
    '|'
  )})\\b(?!\\))\\s*(?=[,])`,
  'ig'
)

module.exports = MaskComposite


/***/ }),

/***/ 72844:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class Order extends Declaration {
  /**
   * Change property name for 2009 and 2012 specs
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return prefix + 'box-ordinal-group'
    }
    if (spec === 2012) {
      return prefix + 'flex-order'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'order'
  }

  /**
   * Fix value for 2009 spec
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2009 && /\d/.test(decl.value)) {
      decl.value = (parseInt(decl.value) + 1).toString()
      return super.set(decl, prefix)
    }
    return super.set(decl, prefix)
  }
}

Order.names = ['order', 'flex-order', 'box-ordinal-group']

module.exports = Order


/***/ }),

/***/ 27879:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class OverscrollBehavior extends Declaration {
  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    return prefix + 'scroll-chaining'
  }

  /**
   * Return property name by spec
   */
  normalize() {
    return 'overscroll-behavior'
  }

  /**
   * Change value for IE
   */
  set(decl, prefix) {
    if (decl.value === 'auto') {
      decl.value = 'chained'
    } else if (decl.value === 'none' || decl.value === 'contain') {
      decl.value = 'none'
    }
    return super.set(decl, prefix)
  }
}

OverscrollBehavior.names = ['overscroll-behavior', 'scroll-chaining']

module.exports = OverscrollBehavior


/***/ }),

/***/ 99683:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let OldValue = __nccwpck_require__(86029)
let Value = __nccwpck_require__(52530)

class Pixelated extends Value {
  /**
   * Use non-standard name for WebKit and Firefox
   */
  replace(string, prefix) {
    if (prefix === '-webkit-') {
      return string.replace(this.regexp(), '$1-webkit-optimize-contrast')
    }
    if (prefix === '-moz-') {
      return string.replace(this.regexp(), '$1-moz-crisp-edges')
    }
    return super.replace(string, prefix)
  }

  /**
   * Different name for WebKit and Firefox
   */
  old(prefix) {
    if (prefix === '-webkit-') {
      return new OldValue(this.name, '-webkit-optimize-contrast')
    }
    if (prefix === '-moz-') {
      return new OldValue(this.name, '-moz-crisp-edges')
    }
    return super.old(prefix)
  }
}

Pixelated.names = ['pixelated']

module.exports = Pixelated


/***/ }),

/***/ 99178:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(73398)

class PlaceSelf extends Declaration {
  /**
   * Translate place-self to separate -ms- prefixed properties
   */
  insert(decl, prefix, prefixes) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    // prevent doubling of prefixes
    if (decl.parent.some(i => i.prop === '-ms-grid-row-align')) {
      return undefined
    }

    let [[first, second]] = utils.parse(decl)

    if (second) {
      utils.insertDecl(decl, 'grid-row-align', first)
      utils.insertDecl(decl, 'grid-column-align', second)
    } else {
      utils.insertDecl(decl, 'grid-row-align', first)
      utils.insertDecl(decl, 'grid-column-align', first)
    }

    return undefined
  }
}

PlaceSelf.names = ['place-self']

module.exports = PlaceSelf


/***/ }),

/***/ 69392:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Selector = __nccwpck_require__(52098)

class PlaceholderShown extends Selector {
  /**
   * Return different selectors depend on prefix
   */
  prefixed(prefix) {
    if (prefix === '-ms-') {
      return ':-ms-input-placeholder'
    }
    return `:${prefix}placeholder-shown`
  }
}

PlaceholderShown.names = [':placeholder-shown']

module.exports = PlaceholderShown


/***/ }),

/***/ 66470:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Selector = __nccwpck_require__(52098)

class Placeholder extends Selector {
  /**
   * Add old mozilla to possible prefixes
   */
  possible() {
    return super.possible().concat(['-moz- old', '-ms- old'])
  }

  /**
   * Return different selectors depend on prefix
   */
  prefixed(prefix) {
    if (prefix === '-webkit-') {
      return '::-webkit-input-placeholder'
    }
    if (prefix === '-ms-') {
      return '::-ms-input-placeholder'
    }
    if (prefix === '-ms- old') {
      return ':-ms-input-placeholder'
    }
    if (prefix === '-moz- old') {
      return ':-moz-placeholder'
    }
    return `::${prefix}placeholder`
  }
}

Placeholder.names = ['::placeholder']

module.exports = Placeholder


/***/ }),

/***/ 12550:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class TextDecorationSkipInk extends Declaration {
  /**
   * Change prefix for ink value
   */
  set(decl, prefix) {
    if (decl.prop === 'text-decoration-skip-ink' && decl.value === 'auto') {
      decl.prop = prefix + 'text-decoration-skip'
      decl.value = 'ink'
      return decl
    } else {
      return super.set(decl, prefix)
    }
  }
}

TextDecorationSkipInk.names = [
  'text-decoration-skip-ink',
  'text-decoration-skip'
]

module.exports = TextDecorationSkipInk


/***/ }),

/***/ 43351:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

const BASIC = [
  'none',
  'underline',
  'overline',
  'line-through',
  'blink',
  'inherit',
  'initial',
  'unset'
]

class TextDecoration extends Declaration {
  /**
   * Do not add prefixes for basic values.
   */
  check(decl) {
    return decl.value.split(/\s+/).some(i => !BASIC.includes(i))
  }
}

TextDecoration.names = ['text-decoration']

module.exports = TextDecoration


/***/ }),

/***/ 60639:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class TextEmphasisPosition extends Declaration {
  set(decl, prefix) {
    if (prefix === '-webkit-') {
      decl.value = decl.value.replace(/\s*(right|left)\s*/i, '')
    }
    return super.set(decl, prefix)
  }
}

TextEmphasisPosition.names = ['text-emphasis-position']

module.exports = TextEmphasisPosition


/***/ }),

/***/ 2589:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class TransformDecl extends Declaration {
  /**
   * Recursively check all parents for @keyframes
   */
  keyframeParents(decl) {
    let { parent } = decl
    while (parent) {
      if (parent.type === 'atrule' && parent.name === 'keyframes') {
        return true
      }
      ;({ parent } = parent)
    }
    return false
  }

  /**
   * Is transform contain 3D commands
   */
  contain3d(decl) {
    if (decl.prop === 'transform-origin') {
      return false
    }

    for (let func of TransformDecl.functions3d) {
      if (decl.value.includes(`${func}(`)) {
        return true
      }
    }

    return false
  }

  /**
   * Replace rotateZ to rotate for IE 9
   */
  set(decl, prefix) {
    decl = super.set(decl, prefix)
    if (prefix === '-ms-') {
      decl.value = decl.value.replace(/rotatez/gi, 'rotate')
    }
    return decl
  }

  /**
   * Don't add prefix for IE in keyframes
   */
  insert(decl, prefix, prefixes) {
    if (prefix === '-ms-') {
      if (!this.contain3d(decl) && !this.keyframeParents(decl)) {
        return super.insert(decl, prefix, prefixes)
      }
    } else if (prefix === '-o-') {
      if (!this.contain3d(decl)) {
        return super.insert(decl, prefix, prefixes)
      }
    } else {
      return super.insert(decl, prefix, prefixes)
    }
    return undefined
  }
}

TransformDecl.names = ['transform', 'transform-origin']

TransformDecl.functions3d = [
  'matrix3d',
  'translate3d',
  'translateZ',
  'scale3d',
  'scaleZ',
  'rotate3d',
  'rotateX',
  'rotateY',
  'perspective'
]

module.exports = TransformDecl


/***/ }),

/***/ 60797:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class UserSelect extends Declaration {
  /**
   * Change prefixed value for IE
   */
  set(decl, prefix) {
    if (prefix === '-ms-' && decl.value === 'contain') {
      decl.value = 'element'
    }
    return super.set(decl, prefix)
  }

  /**
   * Avoid prefixing all in IE
   */
  insert(decl, prefix, prefixes) {
    if (decl.value === 'all' && prefix === '-ms-') {
      return undefined
    } else {
      return super.insert(decl, prefix, prefixes)
    }
  }
}

UserSelect.names = ['user-select']

module.exports = UserSelect


/***/ }),

/***/ 99051:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class WritingMode extends Declaration {
  insert(decl, prefix, prefixes) {
    if (prefix === '-ms-') {
      let cloned = this.set(this.clone(decl), prefix)

      if (this.needCascade(decl)) {
        cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
      }
      let direction = 'ltr'

      decl.parent.nodes.forEach(i => {
        if (i.prop === 'direction') {
          if (i.value === 'rtl' || i.value === 'ltr') direction = i.value
        }
      })

      cloned.value = WritingMode.msValues[direction][decl.value] || decl.value
      return decl.parent.insertBefore(decl, cloned)
    }

    return super.insert(decl, prefix, prefixes)
  }
}

WritingMode.names = ['writing-mode']

WritingMode.msValues = {
  ltr: {
    'horizontal-tb': 'lr-tb',
    'vertical-rl': 'tb-rl',
    'vertical-lr': 'tb-lr'
  },
  rtl: {
    'horizontal-tb': 'rl-tb',
    'vertical-rl': 'bt-rl',
    'vertical-lr': 'bt-lr'
  }
}

module.exports = WritingMode


/***/ }),

/***/ 83028:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let browserslist = __nccwpck_require__(55478)

function capitalize(str) {
  return str.slice(0, 1).toUpperCase() + str.slice(1)
}

const NAMES = {
  ie: 'IE',
  ie_mob: 'IE Mobile',
  ios_saf: 'iOS Safari',
  op_mini: 'Opera Mini',
  op_mob: 'Opera Mobile',
  and_chr: 'Chrome for Android',
  and_ff: 'Firefox for Android',
  and_uc: 'UC for Android',
  and_qq: 'QQ Browser',
  kaios: 'KaiOS Browser',
  baidu: 'Baidu Browser',
  samsung: 'Samsung Internet'
}

function prefix(name, prefixes, note) {
  let out = `  ${name}`
  if (note) out += ' *'
  out += ': '
  out += prefixes.map(i => i.replace(/^-(.*)-$/g, '$1')).join(', ')
  out += '\n'
  return out
}

module.exports = function (prefixes) {
  if (prefixes.browsers.selected.length === 0) {
    return 'No browsers selected'
  }

  let versions = {}
  for (let browser of prefixes.browsers.selected) {
    let parts = browser.split(' ')
    let name = parts[0]
    let version = parts[1]

    name = NAMES[name] || capitalize(name)
    if (versions[name]) {
      versions[name].push(version)
    } else {
      versions[name] = [version]
    }
  }

  let out = 'Browsers:\n'
  for (let browser in versions) {
    let list = versions[browser]
    list = list.sort((a, b) => parseFloat(b) - parseFloat(a))
    out += `  ${browser}: ${list.join(', ')}\n`
  }

  let coverage = browserslist.coverage(prefixes.browsers.selected)
  let round = Math.round(coverage * 100) / 100.0
  out += `\nThese browsers account for ${round}% of all users globally\n`

  let atrules = []
  for (let name in prefixes.add) {
    let data = prefixes.add[name]
    if (name[0] === '@' && data.prefixes) {
      atrules.push(prefix(name, data.prefixes))
    }
  }
  if (atrules.length > 0) {
    out += `\nAt-Rules:\n${atrules.sort().join('')}`
  }

  let selectors = []
  for (let selector of prefixes.add.selectors) {
    if (selector.prefixes) {
      selectors.push(prefix(selector.name, selector.prefixes))
    }
  }
  if (selectors.length > 0) {
    out += `\nSelectors:\n${selectors.sort().join('')}`
  }

  let values = []
  let props = []
  let hadGrid = false
  for (let name in prefixes.add) {
    let data = prefixes.add[name]
    if (name[0] !== '@' && data.prefixes) {
      let grid = name.indexOf('grid-') === 0
      if (grid) hadGrid = true
      props.push(prefix(name, data.prefixes, grid))
    }

    if (!Array.isArray(data.values)) {
      continue
    }
    for (let value of data.values) {
      let grid = value.name.includes('grid')
      if (grid) hadGrid = true
      let string = prefix(value.name, value.prefixes, grid)
      if (!values.includes(string)) {
        values.push(string)
      }
    }
  }

  if (props.length > 0) {
    out += `\nProperties:\n${props.sort().join('')}`
  }
  if (values.length > 0) {
    out += `\nValues:\n${values.sort().join('')}`
  }
  if (hadGrid) {
    out += '\n* - Prefixes will be added only on grid: true option.\n'
  }

  if (!atrules.length && !selectors.length && !props.length && !values.length) {
    out +=
      "\nAwesome! Your browsers don't require any vendor prefixes." +
      '\nNow you can remove Autoprefixer from build steps.'
  }

  return out
}


/***/ }),

/***/ 87964:
/***/ ((module) => {

class OldSelector {
  constructor(selector, prefix) {
    this.prefix = prefix
    this.prefixed = selector.prefixed(this.prefix)
    this.regexp = selector.regexp(this.prefix)

    this.prefixeds = selector
      .possible()
      .map(x => [selector.prefixed(x), selector.regexp(x)])

    this.unprefixed = selector.name
    this.nameRegexp = selector.regexp()
  }

  /**
   * Is rule a hack without unprefixed version bottom
   */
  isHack(rule) {
    let index = rule.parent.index(rule) + 1
    let rules = rule.parent.nodes

    while (index < rules.length) {
      let before = rules[index].selector
      if (!before) {
        return true
      }

      if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {
        return false
      }

      let some = false
      for (let [string, regexp] of this.prefixeds) {
        if (before.includes(string) && before.match(regexp)) {
          some = true
          break
        }
      }

      if (!some) {
        return true
      }

      index += 1
    }

    return true
  }

  /**
   * Does rule contain an unnecessary prefixed selector
   */
  check(rule) {
    if (!rule.selector.includes(this.prefixed)) {
      return false
    }
    if (!rule.selector.match(this.regexp)) {
      return false
    }
    if (this.isHack(rule)) {
      return false
    }
    return true
  }
}

module.exports = OldSelector


/***/ }),

/***/ 86029:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let utils = __nccwpck_require__(96584)

class OldValue {
  constructor(unprefixed, prefixed, string, regexp) {
    this.unprefixed = unprefixed
    this.prefixed = prefixed
    this.string = string || prefixed
    this.regexp = regexp || utils.regexp(prefixed)
  }

  /**
   * Check, that value contain old value
   */
  check(value) {
    if (value.includes(this.string)) {
      return !!value.match(this.regexp)
    }
    return false
  }
}

module.exports = OldValue


/***/ }),

/***/ 26579:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Browsers = __nccwpck_require__(50931)
let vendor = __nccwpck_require__(62667)
let utils = __nccwpck_require__(96584)

/**
 * Recursively clone objects
 */
function clone(obj, parent) {
  let cloned = new obj.constructor()

  for (let i of Object.keys(obj || {})) {
    let value = obj[i]
    if (i === 'parent' && typeof value === 'object') {
      if (parent) {
        cloned[i] = parent
      }
    } else if (i === 'source' || i === null) {
      cloned[i] = value
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(x => clone(x, cloned))
    } else if (
      i !== '_autoprefixerPrefix' &&
      i !== '_autoprefixerValues' &&
      i !== 'proxyCache'
    ) {
      if (typeof value === 'object' && value !== null) {
        value = clone(value, cloned)
      }
      cloned[i] = value
    }
  }

  return cloned
}

class Prefixer {
  /**
   * Add hack to selected names
   */
  static hack(klass) {
    if (!this.hacks) {
      this.hacks = {}
    }
    return klass.names.map(name => {
      this.hacks[name] = klass
      return this.hacks[name]
    })
  }

  /**
   * Load hacks for some names
   */
  static load(name, prefixes, all) {
    let Klass = this.hacks && this.hacks[name]
    if (Klass) {
      return new Klass(name, prefixes, all)
    } else {
      return new this(name, prefixes, all)
    }
  }

  /**
   * Clone node and clean autprefixer custom caches
   */
  static clone(node, overrides) {
    let cloned = clone(node)
    for (let name in overrides) {
      cloned[name] = overrides[name]
    }
    return cloned
  }

  constructor(name, prefixes, all) {
    this.prefixes = prefixes
    this.name = name
    this.all = all
  }

  /**
   * Find prefix in node parents
   */
  parentPrefix(node) {
    let prefix

    if (typeof node._autoprefixerPrefix !== 'undefined') {
      prefix = node._autoprefixerPrefix
    } else if (node.type === 'decl' && node.prop[0] === '-') {
      prefix = vendor.prefix(node.prop)
    } else if (node.type === 'root') {
      prefix = false
    } else if (
      node.type === 'rule' &&
      node.selector.includes(':-') &&
      /:(-\w+-)/.test(node.selector)
    ) {
      prefix = node.selector.match(/:(-\w+-)/)[1]
    } else if (node.type === 'atrule' && node.name[0] === '-') {
      prefix = vendor.prefix(node.name)
    } else {
      prefix = this.parentPrefix(node.parent)
    }

    if (!Browsers.prefixes().includes(prefix)) {
      prefix = false
    }

    node._autoprefixerPrefix = prefix

    return node._autoprefixerPrefix
  }

  /**
   * Clone node with prefixes
   */
  process(node, result) {
    if (!this.check(node)) {
      return undefined
    }

    let parent = this.parentPrefix(node)

    let prefixes = this.prefixes.filter(
      prefix => !parent || parent === utils.removeNote(prefix)
    )

    let added = []
    for (let prefix of prefixes) {
      if (this.add(node, prefix, added.concat([prefix]), result)) {
        added.push(prefix)
      }
    }

    return added
  }

  /**
   * Shortcut for Prefixer.clone
   */
  clone(node, overrides) {
    return Prefixer.clone(node, overrides)
  }
}

module.exports = Prefixer


/***/ }),

/***/ 25396:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let vendor = __nccwpck_require__(62667)
let Declaration = __nccwpck_require__(69011)
let Resolution = __nccwpck_require__(21675)
let Transition = __nccwpck_require__(20960)
let Processor = __nccwpck_require__(54108)
let Supports = __nccwpck_require__(56689)
let Browsers = __nccwpck_require__(50931)
let Selector = __nccwpck_require__(52098)
let AtRule = __nccwpck_require__(87170)
let Value = __nccwpck_require__(52530)
let utils = __nccwpck_require__(96584)
let hackFullscreen = __nccwpck_require__(55233)
let hackPlaceholder = __nccwpck_require__(66470)
let hackPlaceholderShown = __nccwpck_require__(69392)
let hackFileSelectorButton = __nccwpck_require__(35407)
let hackFlex = __nccwpck_require__(84190)
let hackOrder = __nccwpck_require__(72844)
let hackFilter = __nccwpck_require__(46437)
let hackGridEnd = __nccwpck_require__(6307)
let hackAnimation = __nccwpck_require__(57508)
let hackFlexFlow = __nccwpck_require__(99225)
let hackFlexGrow = __nccwpck_require__(11708)
let hackFlexWrap = __nccwpck_require__(44910)
let hackGridArea = __nccwpck_require__(85159)
let hackPlaceSelf = __nccwpck_require__(99178)
let hackGridStart = __nccwpck_require__(57526)
let hackAlignSelf = __nccwpck_require__(70119)
let hackAppearance = __nccwpck_require__(53397)
let hackFlexBasis = __nccwpck_require__(33962)
let hackMaskBorder = __nccwpck_require__(28244)
let hackMaskComposite = __nccwpck_require__(67491)
let hackAlignItems = __nccwpck_require__(92478)
let hackUserSelect = __nccwpck_require__(60797)
let hackFlexShrink = __nccwpck_require__(61945)
let hackBreakProps = __nccwpck_require__(26946)
let hackColorAdjust = __nccwpck_require__(8527)
let hackWritingMode = __nccwpck_require__(99051)
let hackBorderImage = __nccwpck_require__(92212)
let hackAlignContent = __nccwpck_require__(46788)
let hackBorderRadius = __nccwpck_require__(80189)
let hackBlockLogical = __nccwpck_require__(51447)
let hackGridTemplate = __nccwpck_require__(10304)
let hackInlineLogical = __nccwpck_require__(10330)
let hackGridRowAlign = __nccwpck_require__(85565)
let hackTransformDecl = __nccwpck_require__(2589)
let hackFlexDirection = __nccwpck_require__(58440)
let hackImageRendering = __nccwpck_require__(27453)
let hackBackdropFilter = __nccwpck_require__(46667)
let hackBackgroundClip = __nccwpck_require__(32781)
let hackTextDecoration = __nccwpck_require__(43351)
let hackJustifyContent = __nccwpck_require__(82845)
let hackBackgroundSize = __nccwpck_require__(17397)
let hackGridRowColumn = __nccwpck_require__(98041)
let hackGridRowsColumns = __nccwpck_require__(39572)
let hackGridColumnAlign = __nccwpck_require__(4621)
let hackOverscrollBehavior = __nccwpck_require__(27879)
let hackGridTemplateAreas = __nccwpck_require__(10577)
let hackTextEmphasisPosition = __nccwpck_require__(60639)
let hackTextDecorationSkipInk = __nccwpck_require__(12550)
let hackGradient = __nccwpck_require__(29864)
let hackIntrinsic = __nccwpck_require__(10325)
let hackPixelated = __nccwpck_require__(99683)
let hackImageSet = __nccwpck_require__(93812)
let hackCrossFade = __nccwpck_require__(52315)
let hackDisplayFlex = __nccwpck_require__(69470)
let hackDisplayGrid = __nccwpck_require__(35643)
let hackFilterValue = __nccwpck_require__(56122)

Selector.hack(hackFullscreen)
Selector.hack(hackPlaceholder)
Selector.hack(hackPlaceholderShown)
Selector.hack(hackFileSelectorButton)
Declaration.hack(hackFlex)
Declaration.hack(hackOrder)
Declaration.hack(hackFilter)
Declaration.hack(hackGridEnd)
Declaration.hack(hackAnimation)
Declaration.hack(hackFlexFlow)
Declaration.hack(hackFlexGrow)
Declaration.hack(hackFlexWrap)
Declaration.hack(hackGridArea)
Declaration.hack(hackPlaceSelf)
Declaration.hack(hackGridStart)
Declaration.hack(hackAlignSelf)
Declaration.hack(hackAppearance)
Declaration.hack(hackFlexBasis)
Declaration.hack(hackMaskBorder)
Declaration.hack(hackMaskComposite)
Declaration.hack(hackAlignItems)
Declaration.hack(hackUserSelect)
Declaration.hack(hackFlexShrink)
Declaration.hack(hackBreakProps)
Declaration.hack(hackColorAdjust)
Declaration.hack(hackWritingMode)
Declaration.hack(hackBorderImage)
Declaration.hack(hackAlignContent)
Declaration.hack(hackBorderRadius)
Declaration.hack(hackBlockLogical)
Declaration.hack(hackGridTemplate)
Declaration.hack(hackInlineLogical)
Declaration.hack(hackGridRowAlign)
Declaration.hack(hackTransformDecl)
Declaration.hack(hackFlexDirection)
Declaration.hack(hackImageRendering)
Declaration.hack(hackBackdropFilter)
Declaration.hack(hackBackgroundClip)
Declaration.hack(hackTextDecoration)
Declaration.hack(hackJustifyContent)
Declaration.hack(hackBackgroundSize)
Declaration.hack(hackGridRowColumn)
Declaration.hack(hackGridRowsColumns)
Declaration.hack(hackGridColumnAlign)
Declaration.hack(hackOverscrollBehavior)
Declaration.hack(hackGridTemplateAreas)
Declaration.hack(hackTextEmphasisPosition)
Declaration.hack(hackTextDecorationSkipInk)
Value.hack(hackGradient)
Value.hack(hackIntrinsic)
Value.hack(hackPixelated)
Value.hack(hackImageSet)
Value.hack(hackCrossFade)
Value.hack(hackDisplayFlex)
Value.hack(hackDisplayGrid)
Value.hack(hackFilterValue)

let declsCache = new Map()

class Prefixes {
  constructor(data, browsers, options = {}) {
    this.data = data
    this.browsers = browsers
    this.options = options
    ;[this.add, this.remove] = this.preprocess(this.select(this.data))
    this.transition = new Transition(this)
    this.processor = new Processor(this)
  }

  /**
   * Return clone instance to remove all prefixes
   */
  cleaner() {
    if (this.cleanerCache) {
      return this.cleanerCache
    }

    if (this.browsers.selected.length) {
      let empty = new Browsers(this.browsers.data, [])
      this.cleanerCache = new Prefixes(this.data, empty, this.options)
    } else {
      return this
    }

    return this.cleanerCache
  }

  /**
   * Select prefixes from data, which is necessary for selected browsers
   */
  select(list) {
    let selected = { add: {}, remove: {} }

    for (let name in list) {
      let data = list[name]
      let add = data.browsers.map(i => {
        let params = i.split(' ')
        return {
          browser: `${params[0]} ${params[1]}`,
          note: params[2]
        }
      })

      let notes = add
        .filter(i => i.note)
        .map(i => `${this.browsers.prefix(i.browser)} ${i.note}`)
      notes = utils.uniq(notes)

      add = add
        .filter(i => this.browsers.isSelected(i.browser))
        .map(i => {
          let prefix = this.browsers.prefix(i.browser)
          if (i.note) {
            return `${prefix} ${i.note}`
          } else {
            return prefix
          }
        })
      add = this.sort(utils.uniq(add))

      if (this.options.flexbox === 'no-2009') {
        add = add.filter(i => !i.includes('2009'))
      }

      let all = data.browsers.map(i => this.browsers.prefix(i))
      if (data.mistakes) {
        all = all.concat(data.mistakes)
      }
      all = all.concat(notes)
      all = utils.uniq(all)

      if (add.length) {
        selected.add[name] = add
        if (add.length < all.length) {
          selected.remove[name] = all.filter(i => !add.includes(i))
        }
      } else {
        selected.remove[name] = all
      }
    }

    return selected
  }

  /**
   * Sort vendor prefixes
   */
  sort(prefixes) {
    return prefixes.sort((a, b) => {
      let aLength = utils.removeNote(a).length
      let bLength = utils.removeNote(b).length

      if (aLength === bLength) {
        return b.length - a.length
      } else {
        return bLength - aLength
      }
    })
  }

  /**
   * Cache prefixes data to fast CSS processing
   */
  preprocess(selected) {
    let add = {
      'selectors': [],
      '@supports': new Supports(Prefixes, this)
    }
    for (let name in selected.add) {
      let prefixes = selected.add[name]
      if (name === '@keyframes' || name === '@viewport') {
        add[name] = new AtRule(name, prefixes, this)
      } else if (name === '@resolution') {
        add[name] = new Resolution(name, prefixes, this)
      } else if (this.data[name].selector) {
        add.selectors.push(Selector.load(name, prefixes, this))
      } else {
        let props = this.data[name].props

        if (props) {
          let value = Value.load(name, prefixes, this)
          for (let prop of props) {
            if (!add[prop]) {
              add[prop] = { values: [] }
            }
            add[prop].values.push(value)
          }
        } else {
          let values = (add[name] && add[name].values) || []
          add[name] = Declaration.load(name, prefixes, this)
          add[name].values = values
        }
      }
    }

    let remove = { selectors: [] }
    for (let name in selected.remove) {
      let prefixes = selected.remove[name]
      if (this.data[name].selector) {
        let selector = Selector.load(name, prefixes)
        for (let prefix of prefixes) {
          remove.selectors.push(selector.old(prefix))
        }
      } else if (name === '@keyframes' || name === '@viewport') {
        for (let prefix of prefixes) {
          let prefixed = `@${prefix}${name.slice(1)}`
          remove[prefixed] = { remove: true }
        }
      } else if (name === '@resolution') {
        remove[name] = new Resolution(name, prefixes, this)
      } else {
        let props = this.data[name].props
        if (props) {
          let value = Value.load(name, [], this)
          for (let prefix of prefixes) {
            let old = value.old(prefix)
            if (old) {
              for (let prop of props) {
                if (!remove[prop]) {
                  remove[prop] = {}
                }
                if (!remove[prop].values) {
                  remove[prop].values = []
                }
                remove[prop].values.push(old)
              }
            }
          }
        } else {
          for (let p of prefixes) {
            let olds = this.decl(name).old(name, p)
            if (name === 'align-self') {
              let a = add[name] && add[name].prefixes
              if (a) {
                if (p === '-webkit- 2009' && a.includes('-webkit-')) {
                  continue
                } else if (p === '-webkit-' && a.includes('-webkit- 2009')) {
                  continue
                }
              }
            }
            for (let prefixed of olds) {
              if (!remove[prefixed]) {
                remove[prefixed] = {}
              }
              remove[prefixed].remove = true
            }
          }
        }
      }
    }

    return [add, remove]
  }

  /**
   * Declaration loader with caching
   */
  decl(prop) {
    if (!declsCache.has(prop)) {
      declsCache.set(prop, Declaration.load(prop))
    }

    return declsCache.get(prop)
  }

  /**
   * Return unprefixed version of property
   */
  unprefixed(prop) {
    let value = this.normalize(vendor.unprefixed(prop))
    if (value === 'flex-direction') {
      value = 'flex-flow'
    }
    return value
  }

  /**
   * Normalize prefix for remover
   */
  normalize(prop) {
    return this.decl(prop).normalize(prop)
  }

  /**
   * Return prefixed version of property
   */
  prefixed(prop, prefix) {
    prop = vendor.unprefixed(prop)
    return this.decl(prop).prefixed(prop, prefix)
  }

  /**
   * Return values, which must be prefixed in selected property
   */
  values(type, prop) {
    let data = this[type]

    let global = data['*'] && data['*'].values
    let values = data[prop] && data[prop].values

    if (global && values) {
      return utils.uniq(global.concat(values))
    } else {
      return global || values || []
    }
  }

  /**
   * Group declaration by unprefixed property to check them
   */
  group(decl) {
    let rule = decl.parent
    let index = rule.index(decl)
    let { length } = rule.nodes
    let unprefixed = this.unprefixed(decl.prop)

    let checker = (step, callback) => {
      index += step
      while (index >= 0 && index < length) {
        let other = rule.nodes[index]
        if (other.type === 'decl') {
          if (step === -1 && other.prop === unprefixed) {
            if (!Browsers.withPrefix(other.value)) {
              break
            }
          }

          if (this.unprefixed(other.prop) !== unprefixed) {
            break
          } else if (callback(other) === true) {
            return true
          }

          if (step === +1 && other.prop === unprefixed) {
            if (!Browsers.withPrefix(other.value)) {
              break
            }
          }
        }

        index += step
      }
      return false
    }

    return {
      up(callback) {
        return checker(-1, callback)
      },
      down(callback) {
        return checker(+1, callback)
      }
    }
  }
}

module.exports = Prefixes


/***/ }),

/***/ 54108:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let parser = __nccwpck_require__(19285)

let Value = __nccwpck_require__(52530)
let insertAreas = __nccwpck_require__(73398).insertAreas

const OLD_LINEAR = /(^|[^-])linear-gradient\(\s*(top|left|right|bottom)/i
const OLD_RADIAL = /(^|[^-])radial-gradient\(\s*\d+(\w*|%)\s+\d+(\w*|%)\s*,/i
const IGNORE_NEXT = /(!\s*)?autoprefixer:\s*ignore\s+next/i
const GRID_REGEX = /(!\s*)?autoprefixer\s*grid:\s*(on|off|(no-)?autoplace)/i

const SIZES = [
  'width',
  'height',
  'min-width',
  'max-width',
  'min-height',
  'max-height',
  'inline-size',
  'min-inline-size',
  'max-inline-size',
  'block-size',
  'min-block-size',
  'max-block-size'
]

function hasGridTemplate(decl) {
  return decl.parent.some(
    i => i.prop === 'grid-template' || i.prop === 'grid-template-areas'
  )
}

function hasRowsAndColumns(decl) {
  let hasRows = decl.parent.some(i => i.prop === 'grid-template-rows')
  let hasColumns = decl.parent.some(i => i.prop === 'grid-template-columns')
  return hasRows && hasColumns
}

class Processor {
  constructor(prefixes) {
    this.prefixes = prefixes
  }

  /**
   * Add necessary prefixes
   */
  add(css, result) {
    // At-rules
    let resolution = this.prefixes.add['@resolution']
    let keyframes = this.prefixes.add['@keyframes']
    let viewport = this.prefixes.add['@viewport']
    let supports = this.prefixes.add['@supports']

    css.walkAtRules(rule => {
      if (rule.name === 'keyframes') {
        if (!this.disabled(rule, result)) {
          return keyframes && keyframes.process(rule)
        }
      } else if (rule.name === 'viewport') {
        if (!this.disabled(rule, result)) {
          return viewport && viewport.process(rule)
        }
      } else if (rule.name === 'supports') {
        if (
          this.prefixes.options.supports !== false &&
          !this.disabled(rule, result)
        ) {
          return supports.process(rule)
        }
      } else if (rule.name === 'media' && rule.params.includes('-resolution')) {
        if (!this.disabled(rule, result)) {
          return resolution && resolution.process(rule)
        }
      }

      return undefined
    })

    // Selectors
    css.walkRules(rule => {
      if (this.disabled(rule, result)) return undefined

      return this.prefixes.add.selectors.map(selector => {
        return selector.process(rule, result)
      })
    })

    function insideGrid(decl) {
      return decl.parent.nodes.some(node => {
        if (node.type !== 'decl') return false
        let displayGrid =
          node.prop === 'display' && /(inline-)?grid/.test(node.value)
        let gridTemplate = node.prop.startsWith('grid-template')
        let gridGap = /^grid-([A-z]+-)?gap/.test(node.prop)
        return displayGrid || gridTemplate || gridGap
      })
    }
    function insideFlex(decl) {
      return decl.parent.some(node => {
        return node.prop === 'display' && /(inline-)?flex/.test(node.value)
      })
    }

    let gridPrefixes =
      this.gridStatus(css, result) &&
      this.prefixes.add['grid-area'] &&
      this.prefixes.add['grid-area'].prefixes

    css.walkDecls(decl => {
      if (this.disabledDecl(decl, result)) return undefined

      let parent = decl.parent
      let prop = decl.prop
      let value = decl.value

      if (prop === 'grid-row-span') {
        result.warn(
          'grid-row-span is not part of final Grid Layout. Use grid-row.',
          { node: decl }
        )
        return undefined
      } else if (prop === 'grid-column-span') {
        result.warn(
          'grid-column-span is not part of final Grid Layout. Use grid-column.',
          { node: decl }
        )
        return undefined
      } else if (prop === 'display' && value === 'box') {
        result.warn(
          'You should write display: flex by final spec ' +
            'instead of display: box',
          { node: decl }
        )
        return undefined
      } else if (prop === 'text-emphasis-position') {
        if (value === 'under' || value === 'over') {
          result.warn(
            'You should use 2 values for text-emphasis-position ' +
              'For example, `under left` instead of just `under`.',
            { node: decl }
          )
        }
      } else if (
        /^(align|justify|place)-(items|content)$/.test(prop) &&
        insideFlex(decl)
      ) {
        if (value === 'start' || value === 'end') {
          result.warn(
            `${value} value has mixed support, consider using ` +
              `flex-${value} instead`,
            { node: decl }
          )
        }
      } else if (prop === 'text-decoration-skip' && value === 'ink') {
        result.warn(
          'Replace text-decoration-skip: ink to ' +
            'text-decoration-skip-ink: auto, because spec had been changed',
          { node: decl }
        )
      } else {
        if (gridPrefixes && this.gridStatus(decl, result)) {
          if (decl.value === 'subgrid') {
            result.warn('IE does not support subgrid', { node: decl })
          }
          if (/^(align|justify|place)-items$/.test(prop) && insideGrid(decl)) {
            let fixed = prop.replace('-items', '-self')
            result.warn(
              `IE does not support ${prop} on grid containers. ` +
                `Try using ${fixed} on child elements instead: ` +
                `${decl.parent.selector} > * { ${fixed}: ${decl.value} }`,
              { node: decl }
            )
          } else if (
            /^(align|justify|place)-content$/.test(prop) &&
            insideGrid(decl)
          ) {
            result.warn(`IE does not support ${decl.prop} on grid containers`, {
              node: decl
            })
          } else if (prop === 'display' && decl.value === 'contents') {
            result.warn(
              'Please do not use display: contents; ' +
                'if you have grid setting enabled',
              { node: decl }
            )
            return undefined
          } else if (decl.prop === 'grid-gap') {
            let status = this.gridStatus(decl, result)
            if (
              status === 'autoplace' &&
              !hasRowsAndColumns(decl) &&
              !hasGridTemplate(decl)
            ) {
              result.warn(
                'grid-gap only works if grid-template(-areas) is being ' +
                  'used or both rows and columns have been declared ' +
                  'and cells have not been manually ' +
                  'placed inside the explicit grid',
                { node: decl }
              )
            } else if (
              (status === true || status === 'no-autoplace') &&
              !hasGridTemplate(decl)
            ) {
              result.warn(
                'grid-gap only works if grid-template(-areas) is being used',
                { node: decl }
              )
            }
          } else if (prop === 'grid-auto-columns') {
            result.warn('grid-auto-columns is not supported by IE', {
              node: decl
            })
            return undefined
          } else if (prop === 'grid-auto-rows') {
            result.warn('grid-auto-rows is not supported by IE', { node: decl })
            return undefined
          } else if (prop === 'grid-auto-flow') {
            let hasRows = parent.some(i => i.prop === 'grid-template-rows')
            let hasCols = parent.some(i => i.prop === 'grid-template-columns')

            if (hasGridTemplate(decl)) {
              result.warn('grid-auto-flow is not supported by IE', {
                node: decl
              })
            } else if (value.includes('dense')) {
              result.warn('grid-auto-flow: dense is not supported by IE', {
                node: decl
              })
            } else if (!hasRows && !hasCols) {
              result.warn(
                'grid-auto-flow works only if grid-template-rows and ' +
                  'grid-template-columns are present in the same rule',
                { node: decl }
              )
            }
            return undefined
          } else if (value.includes('auto-fit')) {
            result.warn('auto-fit value is not supported by IE', {
              node: decl,
              word: 'auto-fit'
            })
            return undefined
          } else if (value.includes('auto-fill')) {
            result.warn('auto-fill value is not supported by IE', {
              node: decl,
              word: 'auto-fill'
            })
            return undefined
          } else if (prop.startsWith('grid-template') && value.includes('[')) {
            result.warn(
              'Autoprefixer currently does not support line names. ' +
                'Try using grid-template-areas instead.',
              { node: decl, word: '[' }
            )
          }
        }
        if (value.includes('radial-gradient')) {
          if (OLD_RADIAL.test(decl.value)) {
            result.warn(
              'Gradient has outdated direction syntax. ' +
                'New syntax is like `closest-side at 0 0` ' +
                'instead of `0 0, closest-side`.',
              { node: decl }
            )
          } else {
            let ast = parser(value)

            for (let i of ast.nodes) {
              if (i.type === 'function' && i.value === 'radial-gradient') {
                for (let word of i.nodes) {
                  if (word.type === 'word') {
                    if (word.value === 'cover') {
                      result.warn(
                        'Gradient has outdated direction syntax. ' +
                          'Replace `cover` to `farthest-corner`.',
                        { node: decl }
                      )
                    } else if (word.value === 'contain') {
                      result.warn(
                        'Gradient has outdated direction syntax. ' +
                          'Replace `contain` to `closest-side`.',
                        { node: decl }
                      )
                    }
                  }
                }
              }
            }
          }
        }
        if (value.includes('linear-gradient')) {
          if (OLD_LINEAR.test(value)) {
            result.warn(
              'Gradient has outdated direction syntax. ' +
                'New syntax is like `to left` instead of `right`.',
              { node: decl }
            )
          }
        }
      }

      if (SIZES.includes(decl.prop)) {
        if (!decl.value.includes('-fill-available')) {
          if (decl.value.includes('fill-available')) {
            result.warn(
              'Replace fill-available to stretch, ' +
                'because spec had been changed',
              { node: decl }
            )
          } else if (decl.value.includes('fill')) {
            let ast = parser(value)
            if (ast.nodes.some(i => i.type === 'word' && i.value === 'fill')) {
              result.warn(
                'Replace fill to stretch, because spec had been changed',
                { node: decl }
              )
            }
          }
        }
      }

      let prefixer

      if (decl.prop === 'transition' || decl.prop === 'transition-property') {
        // Transition
        return this.prefixes.transition.add(decl, result)
      } else if (decl.prop === 'align-self') {
        // align-self flexbox or grid
        let display = this.displayType(decl)
        if (display !== 'grid' && this.prefixes.options.flexbox !== false) {
          prefixer = this.prefixes.add['align-self']
          if (prefixer && prefixer.prefixes) {
            prefixer.process(decl)
          }
        }
        if (this.gridStatus(decl, result) !== false) {
          prefixer = this.prefixes.add['grid-row-align']
          if (prefixer && prefixer.prefixes) {
            return prefixer.process(decl, result)
          }
        }
      } else if (decl.prop === 'justify-self') {
        // justify-self flexbox or grid
        if (this.gridStatus(decl, result) !== false) {
          prefixer = this.prefixes.add['grid-column-align']
          if (prefixer && prefixer.prefixes) {
            return prefixer.process(decl, result)
          }
        }
      } else if (decl.prop === 'place-self') {
        prefixer = this.prefixes.add['place-self']
        if (
          prefixer &&
          prefixer.prefixes &&
          this.gridStatus(decl, result) !== false
        ) {
          return prefixer.process(decl, result)
        }
      } else {
        // Properties
        prefixer = this.prefixes.add[decl.prop]
        if (prefixer && prefixer.prefixes) {
          return prefixer.process(decl, result)
        }
      }

      return undefined
    })

    // Insert grid-area prefixes. We need to be able to store the different
    // rules as a data and hack API is not enough for this
    if (this.gridStatus(css, result)) {
      insertAreas(css, this.disabled)
    }

    // Values
    return css.walkDecls(decl => {
      if (this.disabledValue(decl, result)) return

      let unprefixed = this.prefixes.unprefixed(decl.prop)
      let list = this.prefixes.values('add', unprefixed)
      if (Array.isArray(list)) {
        for (let value of list) {
          if (value.process) value.process(decl, result)
        }
      }
      Value.save(this.prefixes, decl)
    })
  }

  /**
   * Remove unnecessary pefixes
   */
  remove(css, result) {
    // At-rules
    let resolution = this.prefixes.remove['@resolution']

    css.walkAtRules((rule, i) => {
      if (this.prefixes.remove[`@${rule.name}`]) {
        if (!this.disabled(rule, result)) {
          rule.parent.removeChild(i)
        }
      } else if (
        rule.name === 'media' &&
        rule.params.includes('-resolution') &&
        resolution
      ) {
        resolution.clean(rule)
      }
    })

    // Selectors
    for (let checker of this.prefixes.remove.selectors) {
      css.walkRules((rule, i) => {
        if (checker.check(rule)) {
          if (!this.disabled(rule, result)) {
            rule.parent.removeChild(i)
          }
        }
      })
    }

    return css.walkDecls((decl, i) => {
      if (this.disabled(decl, result)) return

      let rule = decl.parent
      let unprefixed = this.prefixes.unprefixed(decl.prop)

      // Transition
      if (decl.prop === 'transition' || decl.prop === 'transition-property') {
        this.prefixes.transition.remove(decl)
      }

      // Properties
      if (
        this.prefixes.remove[decl.prop] &&
        this.prefixes.remove[decl.prop].remove
      ) {
        let notHack = this.prefixes.group(decl).down(other => {
          return this.prefixes.normalize(other.prop) === unprefixed
        })

        if (unprefixed === 'flex-flow') {
          notHack = true
        }

        if (decl.prop === '-webkit-box-orient') {
          let hacks = { 'flex-direction': true, 'flex-flow': true }
          if (!decl.parent.some(j => hacks[j.prop])) return
        }

        if (notHack && !this.withHackValue(decl)) {
          if (decl.raw('before').includes('\n')) {
            this.reduceSpaces(decl)
          }
          rule.removeChild(i)
          return
        }
      }

      // Values
      for (let checker of this.prefixes.values('remove', unprefixed)) {
        if (!checker.check) continue
        if (!checker.check(decl.value)) continue

        unprefixed = checker.unprefixed
        let notHack = this.prefixes.group(decl).down(other => {
          return other.value.includes(unprefixed)
        })

        if (notHack) {
          rule.removeChild(i)
          return
        }
      }
    })
  }

  /**
   * Some rare old values, which is not in standard
   */
  withHackValue(decl) {
    return decl.prop === '-webkit-background-clip' && decl.value === 'text'
  }

  /**
   * Check for grid/flexbox options.
   */
  disabledValue(node, result) {
    if (this.gridStatus(node, result) === false && node.type === 'decl') {
      if (node.prop === 'display' && node.value.includes('grid')) {
        return true
      }
    }
    if (this.prefixes.options.flexbox === false && node.type === 'decl') {
      if (node.prop === 'display' && node.value.includes('flex')) {
        return true
      }
    }
    if (node.type === 'decl' && node.prop === 'content') {
      return true
    }

    return this.disabled(node, result)
  }

  /**
   * Check for grid/flexbox options.
   */
  disabledDecl(node, result) {
    if (this.gridStatus(node, result) === false && node.type === 'decl') {
      if (node.prop.includes('grid') || node.prop === 'justify-items') {
        return true
      }
    }
    if (this.prefixes.options.flexbox === false && node.type === 'decl') {
      let other = ['order', 'justify-content', 'align-items', 'align-content']
      if (node.prop.includes('flex') || other.includes(node.prop)) {
        return true
      }
    }

    return this.disabled(node, result)
  }

  /**
   * Check for control comment and global options
   */
  disabled(node, result) {
    if (!node) return false

    if (node._autoprefixerDisabled !== undefined) {
      return node._autoprefixerDisabled
    }

    if (node.parent) {
      let p = node.prev()
      if (p && p.type === 'comment' && IGNORE_NEXT.test(p.text)) {
        node._autoprefixerDisabled = true
        node._autoprefixerSelfDisabled = true
        return true
      }
    }

    let value = null
    if (node.nodes) {
      let status
      node.each(i => {
        if (i.type !== 'comment') return
        if (/(!\s*)?autoprefixer:\s*(off|on)/i.test(i.text)) {
          if (typeof status !== 'undefined') {
            result.warn(
              'Second Autoprefixer control comment ' +
                'was ignored. Autoprefixer applies control ' +
                'comment to whole block, not to next rules.',
              { node: i }
            )
          } else {
            status = /on/i.test(i.text)
          }
        }
      })

      if (status !== undefined) {
        value = !status
      }
    }
    if (!node.nodes || value === null) {
      if (node.parent) {
        let isParentDisabled = this.disabled(node.parent, result)
        if (node.parent._autoprefixerSelfDisabled === true) {
          value = false
        } else {
          value = isParentDisabled
        }
      } else {
        value = false
      }
    }
    node._autoprefixerDisabled = value
    return value
  }

  /**
   * Normalize spaces in cascade declaration group
   */
  reduceSpaces(decl) {
    let stop = false
    this.prefixes.group(decl).up(() => {
      stop = true
      return true
    })
    if (stop) {
      return
    }

    let parts = decl.raw('before').split('\n')
    let prevMin = parts[parts.length - 1].length
    let diff = false

    this.prefixes.group(decl).down(other => {
      parts = other.raw('before').split('\n')
      let last = parts.length - 1

      if (parts[last].length > prevMin) {
        if (diff === false) {
          diff = parts[last].length - prevMin
        }

        parts[last] = parts[last].slice(0, -diff)
        other.raws.before = parts.join('\n')
      }
    })
  }

  /**
   * Is it flebox or grid rule
   */
  displayType(decl) {
    for (let i of decl.parent.nodes) {
      if (i.prop !== 'display') {
        continue
      }

      if (i.value.includes('flex')) {
        return 'flex'
      }

      if (i.value.includes('grid')) {
        return 'grid'
      }
    }

    return false
  }

  /**
   * Set grid option via control comment
   */
  gridStatus(node, result) {
    if (!node) return false

    if (node._autoprefixerGridStatus !== undefined) {
      return node._autoprefixerGridStatus
    }

    let value = null
    if (node.nodes) {
      let status
      node.each(i => {
        if (i.type !== 'comment') return
        if (GRID_REGEX.test(i.text)) {
          let hasAutoplace = /:\s*autoplace/i.test(i.text)
          let noAutoplace = /no-autoplace/i.test(i.text)
          if (typeof status !== 'undefined') {
            result.warn(
              'Second Autoprefixer grid control comment was ' +
                'ignored. Autoprefixer applies control comments to the whole ' +
                'block, not to the next rules.',
              { node: i }
            )
          } else if (hasAutoplace) {
            status = 'autoplace'
          } else if (noAutoplace) {
            status = true
          } else {
            status = /on/i.test(i.text)
          }
        }
      })

      if (status !== undefined) {
        value = status
      }
    }

    if (node.type === 'atrule' && node.name === 'supports') {
      let params = node.params
      if (params.includes('grid') && params.includes('auto')) {
        value = false
      }
    }

    if (!node.nodes || value === null) {
      if (node.parent) {
        let isParentGrid = this.gridStatus(node.parent, result)
        if (node.parent._autoprefixerSelfDisabled === true) {
          value = false
        } else {
          value = isParentGrid
        }
      } else if (typeof this.prefixes.options.grid !== 'undefined') {
        value = this.prefixes.options.grid
      } else if (typeof process.env.AUTOPREFIXER_GRID !== 'undefined') {
        if (process.env.AUTOPREFIXER_GRID === 'autoplace') {
          value = 'autoplace'
        } else {
          value = true
        }
      } else {
        value = false
      }
    }

    node._autoprefixerGridStatus = value
    return value
  }
}

module.exports = Processor


/***/ }),

/***/ 21675:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let FractionJs = __nccwpck_require__(85729)

let Prefixer = __nccwpck_require__(26579)
let utils = __nccwpck_require__(96584)

const REGEXP = /(min|max)-resolution\s*:\s*\d*\.?\d+(dppx|dpcm|dpi|x)/gi
const SPLIT = /(min|max)-resolution(\s*:\s*)(\d*\.?\d+)(dppx|dpcm|dpi|x)/i

class Resolution extends Prefixer {
  /**
   * Return prefixed query name
   */
  prefixName(prefix, name) {
    if (prefix === '-moz-') {
      return name + '--moz-device-pixel-ratio'
    } else {
      return prefix + name + '-device-pixel-ratio'
    }
  }

  /**
   * Return prefixed query
   */
  prefixQuery(prefix, name, colon, value, units) {
    value = new FractionJs(value)

    // 1dpcm = 2.54dpi
    // 1dppx = 96dpi
    if (units === 'dpi') {
      value = value.div(96)
    } else if (units === 'dpcm') {
      value = value.mul(2.54).div(96)
    }
    value = value.simplify()

    if (prefix === '-o-') {
      value = value.n + '/' + value.d
    }
    return this.prefixName(prefix, name) + colon + value
  }

  /**
   * Remove prefixed queries
   */
  clean(rule) {
    if (!this.bad) {
      this.bad = []
      for (let prefix of this.prefixes) {
        this.bad.push(this.prefixName(prefix, 'min'))
        this.bad.push(this.prefixName(prefix, 'max'))
      }
    }

    rule.params = utils.editList(rule.params, queries => {
      return queries.filter(query => this.bad.every(i => !query.includes(i)))
    })
  }

  /**
   * Add prefixed queries
   */
  process(rule) {
    let parent = this.parentPrefix(rule)
    let prefixes = parent ? [parent] : this.prefixes

    rule.params = utils.editList(rule.params, (origin, prefixed) => {
      for (let query of origin) {
        if (
          !query.includes('min-resolution') &&
          !query.includes('max-resolution')
        ) {
          prefixed.push(query)
          continue
        }

        for (let prefix of prefixes) {
          let processed = query.replace(REGEXP, str => {
            let parts = str.match(SPLIT)
            return this.prefixQuery(
              prefix,
              parts[1],
              parts[2],
              parts[3],
              parts[4]
            )
          })
          prefixed.push(processed)
        }
        prefixed.push(query)
      }

      return utils.uniq(prefixed)
    })
  }
}

module.exports = Resolution


/***/ }),

/***/ 52098:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let { list } = __nccwpck_require__(77001)

let OldSelector = __nccwpck_require__(87964)
let Prefixer = __nccwpck_require__(26579)
let Browsers = __nccwpck_require__(50931)
let utils = __nccwpck_require__(96584)

class Selector extends Prefixer {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)
    this.regexpCache = new Map()
  }

  /**
   * Is rule selectors need to be prefixed
   */
  check(rule) {
    if (rule.selector.includes(this.name)) {
      return !!rule.selector.match(this.regexp())
    }

    return false
  }

  /**
   * Return prefixed version of selector
   */
  prefixed(prefix) {
    return this.name.replace(/^(\W*)/, `$1${prefix}`)
  }

  /**
   * Lazy loadRegExp for name
   */
  regexp(prefix) {
    if (!this.regexpCache.has(prefix)) {
      let name = prefix ? this.prefixed(prefix) : this.name
      this.regexpCache.set(
        prefix,
        new RegExp(`(^|[^:"'=])${utils.escapeRegexp(name)}`, 'gi')
      )
    }

    return this.regexpCache.get(prefix)
  }

  /**
   * All possible prefixes
   */
  possible() {
    return Browsers.prefixes()
  }

  /**
   * Return all possible selector prefixes
   */
  prefixeds(rule) {
    if (rule._autoprefixerPrefixeds) {
      if (rule._autoprefixerPrefixeds[this.name]) {
        return rule._autoprefixerPrefixeds
      }
    } else {
      rule._autoprefixerPrefixeds = {}
    }

    let prefixeds = {}
    if (rule.selector.includes(',')) {
      let ruleParts = list.comma(rule.selector)
      let toProcess = ruleParts.filter(el => el.includes(this.name))

      for (let prefix of this.possible()) {
        prefixeds[prefix] = toProcess
          .map(el => this.replace(el, prefix))
          .join(', ')
      }
    } else {
      for (let prefix of this.possible()) {
        prefixeds[prefix] = this.replace(rule.selector, prefix)
      }
    }

    rule._autoprefixerPrefixeds[this.name] = prefixeds
    return rule._autoprefixerPrefixeds
  }

  /**
   * Is rule already prefixed before
   */
  already(rule, prefixeds, prefix) {
    let index = rule.parent.index(rule) - 1

    while (index >= 0) {
      let before = rule.parent.nodes[index]

      if (before.type !== 'rule') {
        return false
      }

      let some = false
      for (let key in prefixeds[this.name]) {
        let prefixed = prefixeds[this.name][key]
        if (before.selector === prefixed) {
          if (prefix === key) {
            return true
          } else {
            some = true
            break
          }
        }
      }
      if (!some) {
        return false
      }

      index -= 1
    }

    return false
  }

  /**
   * Replace selectors by prefixed one
   */
  replace(selector, prefix) {
    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`)
  }

  /**
   * Clone and add prefixes for at-rule
   */
  add(rule, prefix) {
    let prefixeds = this.prefixeds(rule)

    if (this.already(rule, prefixeds, prefix)) {
      return
    }

    let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] })
    rule.parent.insertBefore(rule, cloned)
  }

  /**
   * Return function to fast find prefixed selector
   */
  old(prefix) {
    return new OldSelector(this, prefix)
  }
}

module.exports = Selector


/***/ }),

/***/ 56689:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let featureQueries = __nccwpck_require__(53231)
let { feature } = __nccwpck_require__(64006)
let { parse } = __nccwpck_require__(77001)

let Browsers = __nccwpck_require__(50931)
let brackets = __nccwpck_require__(59137)
let Value = __nccwpck_require__(52530)
let utils = __nccwpck_require__(96584)

let data = feature(featureQueries)

let supported = []
for (let browser in data.stats) {
  let versions = data.stats[browser]
  for (let version in versions) {
    let support = versions[version]
    if (/y/.test(support)) {
      supported.push(browser + ' ' + version)
    }
  }
}

class Supports {
  constructor(Prefixes, all) {
    this.Prefixes = Prefixes
    this.all = all
  }

  /**
   * Return prefixer only with @supports supported browsers
   */
  prefixer() {
    if (this.prefixerCache) {
      return this.prefixerCache
    }

    let filtered = this.all.browsers.selected.filter(i => {
      return supported.includes(i)
    })

    let browsers = new Browsers(
      this.all.browsers.data,
      filtered,
      this.all.options
    )
    this.prefixerCache = new this.Prefixes(
      this.all.data,
      browsers,
      this.all.options
    )
    return this.prefixerCache
  }

  /**
   * Parse string into declaration property and value
   */
  parse(str) {
    let parts = str.split(':')
    let prop = parts[0]
    let value = parts[1]
    if (!value) value = ''
    return [prop.trim(), value.trim()]
  }

  /**
   * Create virtual rule to process it by prefixer
   */
  virtual(str) {
    let [prop, value] = this.parse(str)
    let rule = parse('a{}').first
    rule.append({ prop, value, raws: { before: '' } })
    return rule
  }

  /**
   * Return array of Declaration with all necessary prefixes
   */
  prefixed(str) {
    let rule = this.virtual(str)
    if (this.disabled(rule.first)) {
      return rule.nodes
    }

    let result = { warn: () => null }

    let prefixer = this.prefixer().add[rule.first.prop]
    prefixer && prefixer.process && prefixer.process(rule.first, result)

    for (let decl of rule.nodes) {
      for (let value of this.prefixer().values('add', rule.first.prop)) {
        value.process(decl)
      }
      Value.save(this.all, decl)
    }

    return rule.nodes
  }

  /**
   * Return true if brackets node is "not" word
   */
  isNot(node) {
    return typeof node === 'string' && /not\s*/i.test(node)
  }

  /**
   * Return true if brackets node is "or" word
   */
  isOr(node) {
    return typeof node === 'string' && /\s*or\s*/i.test(node)
  }

  /**
   * Return true if brackets node is (prop: value)
   */
  isProp(node) {
    return (
      typeof node === 'object' &&
      node.length === 1 &&
      typeof node[0] === 'string'
    )
  }

  /**
   * Return true if prefixed property has no unprefixed
   */
  isHack(all, unprefixed) {
    let check = new RegExp(`(\\(|\\s)${utils.escapeRegexp(unprefixed)}:`)
    return !check.test(all)
  }

  /**
   * Return true if we need to remove node
   */
  toRemove(str, all) {
    let [prop, value] = this.parse(str)
    let unprefixed = this.all.unprefixed(prop)

    let cleaner = this.all.cleaner()

    if (
      cleaner.remove[prop] &&
      cleaner.remove[prop].remove &&
      !this.isHack(all, unprefixed)
    ) {
      return true
    }

    for (let checker of cleaner.values('remove', unprefixed)) {
      if (checker.check(value)) {
        return true
      }
    }

    return false
  }

  /**
   * Remove all unnecessary prefixes
   */
  remove(nodes, all) {
    let i = 0
    while (i < nodes.length) {
      if (
        !this.isNot(nodes[i - 1]) &&
        this.isProp(nodes[i]) &&
        this.isOr(nodes[i + 1])
      ) {
        if (this.toRemove(nodes[i][0], all)) {
          nodes.splice(i, 2)
          continue
        }

        i += 2
        continue
      }

      if (typeof nodes[i] === 'object') {
        nodes[i] = this.remove(nodes[i], all)
      }

      i += 1
    }
    return nodes
  }

  /**
   * Clean brackets with one child
   */
  cleanBrackets(nodes) {
    return nodes.map(i => {
      if (typeof i !== 'object') {
        return i
      }

      if (i.length === 1 && typeof i[0] === 'object') {
        return this.cleanBrackets(i[0])
      }

      return this.cleanBrackets(i)
    })
  }

  /**
   * Add " or " between properties and convert it to brackets format
   */
  convert(progress) {
    let result = ['']
    for (let i of progress) {
      result.push([`${i.prop}: ${i.value}`])
      result.push(' or ')
    }
    result[result.length - 1] = ''
    return result
  }

  /**
   * Compress value functions into a string nodes
   */
  normalize(nodes) {
    if (typeof nodes !== 'object') {
      return nodes
    }

    nodes = nodes.filter(i => i !== '')

    if (typeof nodes[0] === 'string') {
      let firstNode = nodes[0].trim()

      if (
        firstNode.includes(':') ||
        firstNode === 'selector' ||
        firstNode === 'not selector'
      ) {
        return [brackets.stringify(nodes)]
      }
    }
    return nodes.map(i => this.normalize(i))
  }

  /**
   * Add prefixes
   */
  add(nodes, all) {
    return nodes.map(i => {
      if (this.isProp(i)) {
        let prefixed = this.prefixed(i[0])
        if (prefixed.length > 1) {
          return this.convert(prefixed)
        }

        return i
      }

      if (typeof i === 'object') {
        return this.add(i, all)
      }

      return i
    })
  }

  /**
   * Add prefixed declaration
   */
  process(rule) {
    let ast = brackets.parse(rule.params)
    ast = this.normalize(ast)
    ast = this.remove(ast, rule.params)
    ast = this.add(ast, rule.params)
    ast = this.cleanBrackets(ast)
    rule.params = brackets.stringify(ast)
  }

  /**
   * Check global options
   */
  disabled(node) {
    if (!this.all.options.grid) {
      if (node.prop === 'display' && node.value.includes('grid')) {
        return true
      }
      if (node.prop.includes('grid') || node.prop === 'justify-items') {
        return true
      }
    }

    if (this.all.options.flexbox === false) {
      if (node.prop === 'display' && node.value.includes('flex')) {
        return true
      }
      let other = ['order', 'justify-content', 'align-items', 'align-content']
      if (node.prop.includes('flex') || other.includes(node.prop)) {
        return true
      }
    }

    return false
  }
}

module.exports = Supports


/***/ }),

/***/ 20960:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let { list } = __nccwpck_require__(77001)
let parser = __nccwpck_require__(19285)

let Browsers = __nccwpck_require__(50931)
let vendor = __nccwpck_require__(62667)

class Transition {
  constructor(prefixes) {
    this.props = ['transition', 'transition-property']
    this.prefixes = prefixes
  }

  /**
   * Process transition and add prefixes for all necessary properties
   */
  add(decl, result) {
    let prefix, prop
    let add = this.prefixes.add[decl.prop]
    let vendorPrefixes = this.ruleVendorPrefixes(decl)
    let declPrefixes = vendorPrefixes || (add && add.prefixes) || []

    let params = this.parse(decl.value)
    let names = params.map(i => this.findProp(i))
    let added = []

    if (names.some(i => i[0] === '-')) {
      return
    }

    for (let param of params) {
      prop = this.findProp(param)
      if (prop[0] === '-') continue

      let prefixer = this.prefixes.add[prop]
      if (!prefixer || !prefixer.prefixes) continue

      for (prefix of prefixer.prefixes) {
        if (vendorPrefixes && !vendorPrefixes.some(p => prefix.includes(p))) {
          continue
        }

        let prefixed = this.prefixes.prefixed(prop, prefix)
        if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {
          if (!this.disabled(prop, prefix)) {
            added.push(this.clone(prop, prefixed, param))
          }
        }
      }
    }

    params = params.concat(added)
    let value = this.stringify(params)

    let webkitClean = this.stringify(
      this.cleanFromUnprefixed(params, '-webkit-')
    )
    if (declPrefixes.includes('-webkit-')) {
      this.cloneBefore(decl, `-webkit-${decl.prop}`, webkitClean)
    }
    this.cloneBefore(decl, decl.prop, webkitClean)
    if (declPrefixes.includes('-o-')) {
      let operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'))
      this.cloneBefore(decl, `-o-${decl.prop}`, operaClean)
    }

    for (prefix of declPrefixes) {
      if (prefix !== '-webkit-' && prefix !== '-o-') {
        let prefixValue = this.stringify(
          this.cleanOtherPrefixes(params, prefix)
        )
        this.cloneBefore(decl, prefix + decl.prop, prefixValue)
      }
    }

    if (value !== decl.value && !this.already(decl, decl.prop, value)) {
      this.checkForWarning(result, decl)
      decl.cloneBefore()
      decl.value = value
    }
  }

  /**
   * Find property name
   */
  findProp(param) {
    let prop = param[0].value
    if (/^\d/.test(prop)) {
      for (let [i, token] of param.entries()) {
        if (i !== 0 && token.type === 'word') {
          return token.value
        }
      }
    }
    return prop
  }

  /**
   * Does we already have this declaration
   */
  already(decl, prop, value) {
    return decl.parent.some(i => i.prop === prop && i.value === value)
  }

  /**
   * Add declaration if it is not exist
   */
  cloneBefore(decl, prop, value) {
    if (!this.already(decl, prop, value)) {
      decl.cloneBefore({ prop, value })
    }
  }

  /**
   * Show transition-property warning
   */
  checkForWarning(result, decl) {
    if (decl.prop !== 'transition-property') {
      return
    }

    let isPrefixed = false
    let hasAssociatedProp = false

    decl.parent.each(i => {
      if (i.type !== 'decl') {
        return undefined
      }
      if (i.prop.indexOf('transition-') !== 0) {
        return undefined
      }
      let values = list.comma(i.value)
      // check if current Rule's transition-property comma separated value list needs prefixes
      if (i.prop === 'transition-property') {
        values.forEach(value => {
          let lookup = this.prefixes.add[value]
          if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {
            isPrefixed = true
          }
        })
        return undefined
      }
      // check if another transition-* prop in current Rule has comma separated value list
      hasAssociatedProp = hasAssociatedProp || values.length > 1
      return false
    })

    if (isPrefixed && hasAssociatedProp) {
      decl.warn(
        result,
        'Replace transition-property to transition, ' +
          'because Autoprefixer could not support ' +
          'any cases of transition-property ' +
          'and other transition-*'
      )
    }
  }

  /**
   * Process transition and remove all unnecessary properties
   */
  remove(decl) {
    let params = this.parse(decl.value)
    params = params.filter(i => {
      let prop = this.prefixes.remove[this.findProp(i)]
      return !prop || !prop.remove
    })
    let value = this.stringify(params)

    if (decl.value === value) {
      return
    }

    if (params.length === 0) {
      decl.remove()
      return
    }

    let double = decl.parent.some(i => {
      return i.prop === decl.prop && i.value === value
    })
    let smaller = decl.parent.some(i => {
      return i !== decl && i.prop === decl.prop && i.value.length > value.length
    })

    if (double || smaller) {
      decl.remove()
      return
    }

    decl.value = value
  }

  /**
   * Parse properties list to array
   */
  parse(value) {
    let ast = parser(value)
    let result = []
    let param = []
    for (let node of ast.nodes) {
      param.push(node)
      if (node.type === 'div' && node.value === ',') {
        result.push(param)
        param = []
      }
    }
    result.push(param)
    return result.filter(i => i.length > 0)
  }

  /**
   * Return properties string from array
   */
  stringify(params) {
    if (params.length === 0) {
      return ''
    }
    let nodes = []
    for (let param of params) {
      if (param[param.length - 1].type !== 'div') {
        param.push(this.div(params))
      }
      nodes = nodes.concat(param)
    }
    if (nodes[0].type === 'div') {
      nodes = nodes.slice(1)
    }
    if (nodes[nodes.length - 1].type === 'div') {
      nodes = nodes.slice(0, +-2 + 1 || 0)
    }
    return parser.stringify({ nodes })
  }

  /**
   * Return new param array with different name
   */
  clone(origin, name, param) {
    let result = []
    let changed = false
    for (let i of param) {
      if (!changed && i.type === 'word' && i.value === origin) {
        result.push({ type: 'word', value: name })
        changed = true
      } else {
        result.push(i)
      }
    }
    return result
  }

  /**
   * Find or create separator
   */
  div(params) {
    for (let param of params) {
      for (let node of param) {
        if (node.type === 'div' && node.value === ',') {
          return node
        }
      }
    }
    return { type: 'div', value: ',', after: ' ' }
  }

  cleanOtherPrefixes(params, prefix) {
    return params.filter(param => {
      let current = vendor.prefix(this.findProp(param))
      return current === '' || current === prefix
    })
  }

  /**
   * Remove all non-webkit prefixes and unprefixed params if we have prefixed
   */
  cleanFromUnprefixed(params, prefix) {
    let remove = params
      .map(i => this.findProp(i))
      .filter(i => i.slice(0, prefix.length) === prefix)
      .map(i => this.prefixes.unprefixed(i))

    let result = []
    for (let param of params) {
      let prop = this.findProp(param)
      let p = vendor.prefix(prop)
      if (!remove.includes(prop) && (p === prefix || p === '')) {
        result.push(param)
      }
    }
    return result
  }

  /**
   * Check property for disabled by option
   */
  disabled(prop, prefix) {
    let other = ['order', 'justify-content', 'align-self', 'align-content']
    if (prop.includes('flex') || other.includes(prop)) {
      if (this.prefixes.options.flexbox === false) {
        return true
      }

      if (this.prefixes.options.flexbox === 'no-2009') {
        return prefix.includes('2009')
      }
    }
    return undefined
  }

  /**
   * Check if transition prop is inside vendor specific rule
   */
  ruleVendorPrefixes(decl) {
    let { parent } = decl

    if (parent.type !== 'rule') {
      return false
    } else if (!parent.selector.includes(':-')) {
      return false
    }

    let selectors = Browsers.prefixes().filter(s =>
      parent.selector.includes(':' + s)
    )

    return selectors.length > 0 ? selectors : false
  }
}

module.exports = Transition


/***/ }),

/***/ 96584:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let { list } = __nccwpck_require__(77001)

/**
 * Throw special error, to tell beniary,
 * that this error is from Autoprefixer.
 */
module.exports.error = function (text) {
  let err = new Error(text)
  err.autoprefixer = true
  throw err
}

/**
 * Return array, that doesnt contain duplicates.
 */
module.exports.uniq = function (array) {
  return [...new Set(array)]
}

/**
 * Return "-webkit-" on "-webkit- old"
 */
module.exports.removeNote = function (string) {
  if (!string.includes(' ')) {
    return string
  }

  return string.split(' ')[0]
}

/**
 * Escape RegExp symbols
 */
module.exports.escapeRegexp = function (string) {
  return string.replace(/[$()*+-.?[\\\]^{|}]/g, '\\$&')
}

/**
 * Return regexp to check, that CSS string contain word
 */
module.exports.regexp = function (word, escape = true) {
  if (escape) {
    word = this.escapeRegexp(word)
  }
  return new RegExp(`(^|[\\s,(])(${word}($|[\\s(,]))`, 'gi')
}

/**
 * Change comma list
 */
module.exports.editList = function (value, callback) {
  let origin = list.comma(value)
  let changed = callback(origin, [])

  if (origin === changed) {
    return value
  }

  let join = value.match(/,\s*/)
  join = join ? join[0] : ', '
  return changed.join(join)
}

/**
 * Split the selector into parts.
 * It returns 3 level deep array because selectors can be comma
 * separated (1), space separated (2), and combined (3)
 * @param {String} selector selector string
 * @return {Array<Array<Array>>} 3 level deep array of split selector
 * @see utils.test.js for examples
 */
module.exports.splitSelector = function (selector) {
  return list.comma(selector).map(i => {
    return list.space(i).map(k => {
      return k.split(/(?=\.|#)/g)
    })
  })
}


/***/ }),

/***/ 52530:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Prefixer = __nccwpck_require__(26579)
let OldValue = __nccwpck_require__(86029)
let vendor = __nccwpck_require__(62667)
let utils = __nccwpck_require__(96584)

class Value extends Prefixer {
  /**
   * Clone decl for each prefixed values
   */
  static save(prefixes, decl) {
    let prop = decl.prop
    let result = []

    for (let prefix in decl._autoprefixerValues) {
      let value = decl._autoprefixerValues[prefix]

      if (value === decl.value) {
        continue
      }

      let item
      let propPrefix = vendor.prefix(prop)

      if (propPrefix === '-pie-') {
        continue
      }

      if (propPrefix === prefix) {
        item = decl.value = value
        result.push(item)
        continue
      }

      let prefixed = prefixes.prefixed(prop, prefix)
      let rule = decl.parent

      if (!rule.every(i => i.prop !== prefixed)) {
        result.push(item)
        continue
      }

      let trimmed = value.replace(/\s+/, ' ')
      let already = rule.some(
        i => i.prop === decl.prop && i.value.replace(/\s+/, ' ') === trimmed
      )

      if (already) {
        result.push(item)
        continue
      }

      let cloned = this.clone(decl, { value })
      item = decl.parent.insertBefore(decl, cloned)

      result.push(item)
    }

    return result
  }

  /**
   * Is declaration need to be prefixed
   */
  check(decl) {
    let value = decl.value
    if (!value.includes(this.name)) {
      return false
    }

    return !!value.match(this.regexp())
  }

  /**
   * Lazy regexp loading
   */
  regexp() {
    return this.regexpCache || (this.regexpCache = utils.regexp(this.name))
  }

  /**
   * Add prefix to values in string
   */
  replace(string, prefix) {
    return string.replace(this.regexp(), `$1${prefix}$2`)
  }

  /**
   * Get value with comments if it was not changed
   */
  value(decl) {
    if (decl.raws.value && decl.raws.value.value === decl.value) {
      return decl.raws.value.raw
    } else {
      return decl.value
    }
  }

  /**
   * Save values with next prefixed token
   */
  add(decl, prefix) {
    if (!decl._autoprefixerValues) {
      decl._autoprefixerValues = {}
    }
    let value = decl._autoprefixerValues[prefix] || this.value(decl)

    let before
    do {
      before = value
      value = this.replace(value, prefix)
      if (value === false) return
    } while (value !== before)

    decl._autoprefixerValues[prefix] = value
  }

  /**
   * Return function to fast find prefixed value
   */
  old(prefix) {
    return new OldValue(this.name, prefix + this.name)
  }
}

module.exports = Value


/***/ }),

/***/ 62667:
/***/ ((module) => {

module.exports = {
  prefix(prop) {
    let match = prop.match(/^(-\w+-)/)
    if (match) {
      return match[0]
    }

    return ''
  },

  unprefixed(prop) {
    return prop.replace(/^-\w+-/, '')
  }
}


/***/ }),

/***/ 44159:
/***/ ((module) => {

module.exports = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};

/***/ }),

/***/ 92498:
/***/ ((module) => {

function BrowserslistError (message) {
  this.name = 'BrowserslistError'
  this.message = message
  this.browserslist = true
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, BrowserslistError)
  }
}

BrowserslistError.prototype = Error.prototype

module.exports = BrowserslistError


/***/ }),

/***/ 55478:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var jsReleases = __nccwpck_require__(83835)
var agents = __nccwpck_require__(87462).agents
var jsEOL = __nccwpck_require__(85659)
var path = __nccwpck_require__(85622)
var e2c = __nccwpck_require__(46719)

var BrowserslistError = __nccwpck_require__(92498)
var env = __nccwpck_require__(20486) // Will load browser.js in webpack

var YEAR = 365.259641 * 24 * 60 * 60 * 1000
var ANDROID_EVERGREEN_FIRST = 37

var QUERY_OR = 1
var QUERY_AND = 2

function isVersionsMatch (versionA, versionB) {
  return (versionA + '.').indexOf(versionB + '.') === 0
}

function isEolReleased (name) {
  var version = name.slice(1)
  return jsReleases.some(function (i) {
    return isVersionsMatch(i.version, version)
  })
}

function normalize (versions) {
  return versions.filter(function (version) {
    return typeof version === 'string'
  })
}

function normalizeElectron (version) {
  var versionToUse = version
  if (version.split('.').length === 3) {
    versionToUse = version
      .split('.')
      .slice(0, -1)
      .join('.')
  }
  return versionToUse
}

function nameMapper (name) {
  return function mapName (version) {
    return name + ' ' + version
  }
}

function getMajor (version) {
  return parseInt(version.split('.')[0])
}

function getMajorVersions (released, number) {
  if (released.length === 0) return []
  var majorVersions = uniq(released.map(getMajor))
  var minimum = majorVersions[majorVersions.length - number]
  if (!minimum) {
    return released
  }
  var selected = []
  for (var i = released.length - 1; i >= 0; i--) {
    if (minimum > getMajor(released[i])) break
    selected.unshift(released[i])
  }
  return selected
}

function uniq (array) {
  var filtered = []
  for (var i = 0; i < array.length; i++) {
    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i])
  }
  return filtered
}

// Helpers

function fillUsage (result, name, data) {
  for (var i in data) {
    result[name + ' ' + i] = data[i]
  }
}

function generateFilter (sign, version) {
  version = parseFloat(version)
  if (sign === '>') {
    return function (v) {
      return parseFloat(v) > version
    }
  } else if (sign === '>=') {
    return function (v) {
      return parseFloat(v) >= version
    }
  } else if (sign === '<') {
    return function (v) {
      return parseFloat(v) < version
    }
  } else {
    return function (v) {
      return parseFloat(v) <= version
    }
  }
}

function generateSemverFilter (sign, version) {
  version = version.split('.').map(parseSimpleInt)
  version[1] = version[1] || 0
  version[2] = version[2] || 0
  if (sign === '>') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt)
      return compareSemver(v, version) > 0
    }
  } else if (sign === '>=') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt)
      return compareSemver(v, version) >= 0
    }
  } else if (sign === '<') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt)
      return compareSemver(version, v) > 0
    }
  } else {
    return function (v) {
      v = v.split('.').map(parseSimpleInt)
      return compareSemver(version, v) >= 0
    }
  }
}

function parseSimpleInt (x) {
  return parseInt(x)
}

function compare (a, b) {
  if (a < b) return -1
  if (a > b) return +1
  return 0
}

function compareSemver (a, b) {
  return (
    compare(parseInt(a[0]), parseInt(b[0])) ||
    compare(parseInt(a[1] || '0'), parseInt(b[1] || '0')) ||
    compare(parseInt(a[2] || '0'), parseInt(b[2] || '0'))
  )
}

// this follows the npm-like semver behavior
function semverFilterLoose (operator, range) {
  range = range.split('.').map(parseSimpleInt)
  if (typeof range[1] === 'undefined') {
    range[1] = 'x'
  }
  // ignore any patch version because we only return minor versions
  // range[2] = 'x'
  switch (operator) {
    case '<=':
      return function (version) {
        version = version.split('.').map(parseSimpleInt)
        return compareSemverLoose(version, range) <= 0
      }
    default:
    case '>=':
      return function (version) {
        version = version.split('.').map(parseSimpleInt)
        return compareSemverLoose(version, range) >= 0
      }
  }
}

// this follows the npm-like semver behavior
function compareSemverLoose (version, range) {
  if (version[0] !== range[0]) {
    return version[0] < range[0] ? -1 : +1
  }
  if (range[1] === 'x') {
    return 0
  }
  if (version[1] !== range[1]) {
    return version[1] < range[1] ? -1 : +1
  }
  return 0
}

function resolveVersion (data, version) {
  if (data.versions.indexOf(version) !== -1) {
    return version
  } else if (browserslist.versionAliases[data.name][version]) {
    return browserslist.versionAliases[data.name][version]
  } else {
    return false
  }
}

function normalizeVersion (data, version) {
  var resolved = resolveVersion(data, version)
  if (resolved) {
    return resolved
  } else if (data.versions.length === 1) {
    return data.versions[0]
  } else {
    return false
  }
}

function filterByYear (since, context) {
  since = since / 1000
  return Object.keys(agents).reduce(function (selected, name) {
    var data = byName(name, context)
    if (!data) return selected
    var versions = Object.keys(data.releaseDate).filter(function (v) {
      return data.releaseDate[v] >= since
    })
    return selected.concat(versions.map(nameMapper(data.name)))
  }, [])
}

function cloneData (data) {
  return {
    name: data.name,
    versions: data.versions,
    released: data.released,
    releaseDate: data.releaseDate
  }
}

function mapVersions (data, map) {
  data.versions = data.versions.map(function (i) {
    return map[i] || i
  })
  data.released = data.versions.map(function (i) {
    return map[i] || i
  })
  var fixedDate = { }
  for (var i in data.releaseDate) {
    fixedDate[map[i] || i] = data.releaseDate[i]
  }
  data.releaseDate = fixedDate
  return data
}

function byName (name, context) {
  name = name.toLowerCase()
  name = browserslist.aliases[name] || name
  if (context.mobileToDesktop && browserslist.desktopNames[name]) {
    var desktop = browserslist.data[browserslist.desktopNames[name]]
    if (name === 'android') {
      return normalizeAndroidData(cloneData(browserslist.data[name]), desktop)
    } else {
      var cloned = cloneData(desktop)
      cloned.name = name
      if (name === 'op_mob') {
        cloned = mapVersions(cloned, { '10.0-10.1': '10' })
      }
      return cloned
    }
  }
  return browserslist.data[name]
}

function normalizeAndroidVersions (androidVersions, chromeVersions) {
  var firstEvergreen = ANDROID_EVERGREEN_FIRST
  var last = chromeVersions[chromeVersions.length - 1]
  return androidVersions
    .filter(function (version) { return /^(?:[2-4]\.|[34]$)/.test(version) })
    .concat(chromeVersions.slice(firstEvergreen - last - 1))
}

function normalizeAndroidData (android, chrome) {
  android.released = normalizeAndroidVersions(android.released, chrome.released)
  android.versions = normalizeAndroidVersions(android.versions, chrome.versions)
  return android
}

function checkName (name, context) {
  var data = byName(name, context)
  if (!data) throw new BrowserslistError('Unknown browser ' + name)
  return data
}

function unknownQuery (query) {
  return new BrowserslistError(
    'Unknown browser query `' + query + '`. ' +
    'Maybe you are using old Browserslist or made typo in query.'
  )
}

function filterAndroid (list, versions, context) {
  if (context.mobileToDesktop) return list
  var released = browserslist.data.android.released
  var last = released[released.length - 1]
  var diff = last - ANDROID_EVERGREEN_FIRST - versions
  if (diff > 0) {
    return list.slice(-1)
  } else {
    return list.slice(diff - 1)
  }
}

/**
 * Resolves queries into a browser list.
 * @param {string|string[]} queries Queries to combine.
 * Either an array of queries or a long string of queries.
 * @param {object} [context] Optional arguments to
 * the select function in `queries`.
 * @returns {string[]} A list of browsers
 */
function resolve (queries, context) {
  if (Array.isArray(queries)) {
    queries = flatten(queries.map(parse))
  } else {
    queries = parse(queries)
  }

  return queries.reduce(function (result, query, index) {
    var selection = query.queryString

    var isExclude = selection.indexOf('not ') === 0
    if (isExclude) {
      if (index === 0) {
        throw new BrowserslistError(
          'Write any browsers query (for instance, `defaults`) ' +
          'before `' + selection + '`')
      }
      selection = selection.slice(4)
    }

    for (var i = 0; i < QUERIES.length; i++) {
      var type = QUERIES[i]
      var match = selection.match(type.regexp)
      if (match) {
        var args = [context].concat(match.slice(1))
        var array = type.select.apply(browserslist, args).map(function (j) {
          var parts = j.split(' ')
          if (parts[1] === '0') {
            return parts[0] + ' ' + byName(parts[0], context).versions[0]
          } else {
            return j
          }
        })

        switch (query.type) {
          case QUERY_AND:
            if (isExclude) {
              return result.filter(function (j) {
                return array.indexOf(j) === -1
              })
            } else {
              return result.filter(function (j) {
                return array.indexOf(j) !== -1
              })
            }
          case QUERY_OR:
          default:
            if (isExclude) {
              var filter = { }
              array.forEach(function (j) {
                filter[j] = true
              })
              return result.filter(function (j) {
                return !filter[j]
              })
            }
            return result.concat(array)
        }
      }
    }

    throw unknownQuery(selection)
  }, [])
}

var cache = { }

/**
 * Return array of browsers by selection queries.
 *
 * @param {(string|string[])} [queries=browserslist.defaults] Browser queries.
 * @param {object} [opts] Options.
 * @param {string} [opts.path="."] Path to processed file.
 *                                 It will be used to find config files.
 * @param {string} [opts.env="production"] Processing environment.
 *                                         It will be used to take right
 *                                         queries from config file.
 * @param {string} [opts.config] Path to config file with queries.
 * @param {object} [opts.stats] Custom browser usage statistics
 *                              for "> 1% in my stats" query.
 * @param {boolean} [opts.ignoreUnknownVersions=false] Do not throw on unknown
 *                                                     version in direct query.
 * @param {boolean} [opts.dangerousExtend] Disable security checks
 *                                         for extend query.
 * @param {boolean} [opts.mobileToDesktop] Alias mobile browsers to the desktop
 *                                         version when Can I Use doesn't have
 *                                         data about the specified version.
 * @returns {string[]} Array with browser names in Can I Use.
 *
 * @example
 * browserslist('IE >= 10, IE 8') //=> ['ie 11', 'ie 10', 'ie 8']
 */
function browserslist (queries, opts) {
  if (typeof opts === 'undefined') opts = { }

  if (typeof opts.path === 'undefined') {
    opts.path = path.resolve ? path.resolve('.') : '.'
  }

  if (typeof queries === 'undefined' || queries === null) {
    var config = browserslist.loadConfig(opts)
    if (config) {
      queries = config
    } else {
      queries = browserslist.defaults
    }
  }

  if (!(typeof queries === 'string' || Array.isArray(queries))) {
    throw new BrowserslistError(
      'Browser queries must be an array or string. Got ' + typeof queries + '.')
  }

  var context = {
    ignoreUnknownVersions: opts.ignoreUnknownVersions,
    dangerousExtend: opts.dangerousExtend,
    mobileToDesktop: opts.mobileToDesktop,
    path: opts.path,
    env: opts.env
  }

  env.oldDataWarning(browserslist.data)
  var stats = env.getStat(opts, browserslist.data)
  if (stats) {
    context.customUsage = { }
    for (var browser in stats) {
      fillUsage(context.customUsage, browser, stats[browser])
    }
  }

  var cacheKey = JSON.stringify([queries, context])
  if (cache[cacheKey]) return cache[cacheKey]

  var result = uniq(resolve(queries, context)).sort(function (name1, name2) {
    name1 = name1.split(' ')
    name2 = name2.split(' ')
    if (name1[0] === name2[0]) {
      // assumptions on caniuse data
      // 1) version ranges never overlaps
      // 2) if version is not a range, it never contains `-`
      var version1 = name1[1].split('-')[0]
      var version2 = name2[1].split('-')[0]
      return compareSemver(version2.split('.'), version1.split('.'))
    } else {
      return compare(name1[0], name2[0])
    }
  })
  if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
    cache[cacheKey] = result
  }
  return result
}

function parse (queries) {
  var qs = []
  do {
    queries = doMatch(queries, qs)
  } while (queries)
  return qs
}

function doMatch (string, qs) {
  var or = /^(?:,\s*|\s+or\s+)(.*)/i
  var and = /^\s+and\s+(.*)/i

  return find(string, function (parsed, n, max) {
    if (and.test(parsed)) {
      qs.unshift({ type: QUERY_AND, queryString: parsed.match(and)[1] })
      return true
    } else if (or.test(parsed)) {
      qs.unshift({ type: QUERY_OR, queryString: parsed.match(or)[1] })
      return true
    } else if (n === max) {
      qs.unshift({ type: QUERY_OR, queryString: parsed.trim() })
      return true
    }
    return false
  })
}

function find (string, predicate) {
  for (var n = 1, max = string.length; n <= max; n++) {
    var parsed = string.substr(-n, n)
    if (predicate(parsed, n, max)) {
      return string.slice(0, -n)
    }
  }
  return ''
}

function flatten (array) {
  if (!Array.isArray(array)) return [array]
  return array.reduce(function (a, b) {
    return a.concat(flatten(b))
  }, [])
}

// Will be filled by Can I Use data below
browserslist.cache = { }
browserslist.data = { }
browserslist.usage = {
  global: { },
  custom: null
}

// Default browsers query
browserslist.defaults = [
  '> 0.5%',
  'last 2 versions',
  'Firefox ESR',
  'not dead'
]

// Browser names aliases
browserslist.aliases = {
  fx: 'firefox',
  ff: 'firefox',
  ios: 'ios_saf',
  explorer: 'ie',
  blackberry: 'bb',
  explorermobile: 'ie_mob',
  operamini: 'op_mini',
  operamobile: 'op_mob',
  chromeandroid: 'and_chr',
  firefoxandroid: 'and_ff',
  ucandroid: 'and_uc',
  qqandroid: 'and_qq'
}

// Can I Use only provides a few versions for some browsers (e.g. and_chr).
// Fallback to a similar browser for unknown versions
browserslist.desktopNames = {
  and_chr: 'chrome',
  and_ff: 'firefox',
  ie_mob: 'ie',
  op_mob: 'opera',
  android: 'chrome' // has extra processing logic
}

// Aliases to work with joined versions like `ios_saf 7.0-7.1`
browserslist.versionAliases = { }

browserslist.clearCaches = env.clearCaches
browserslist.parseConfig = env.parseConfig
browserslist.readConfig = env.readConfig
browserslist.findConfig = env.findConfig
browserslist.loadConfig = env.loadConfig

/**
 * Return browsers market coverage.
 *
 * @param {string[]} browsers Browsers names in Can I Use.
 * @param {string|object} [stats="global"] Which statistics should be used.
 *                                         Country code or custom statistics.
 *                                         Pass `"my stats"` to load statistics
 *                                         from Browserslist files.
 *
 * @return {number} Total market coverage for all selected browsers.
 *
 * @example
 * browserslist.coverage(browserslist('> 1% in US'), 'US') //=> 83.1
 */
browserslist.coverage = function (browsers, stats) {
  var data
  if (typeof stats === 'undefined') {
    data = browserslist.usage.global
  } else if (stats === 'my stats') {
    var opts = {}
    opts.path = path.resolve ? path.resolve('.') : '.'
    var customStats = env.getStat(opts)
    if (!customStats) {
      throw new BrowserslistError('Custom usage statistics was not provided')
    }
    data = {}
    for (var browser in customStats) {
      fillUsage(data, browser, customStats[browser])
    }
  } else if (typeof stats === 'string') {
    if (stats.length > 2) {
      stats = stats.toLowerCase()
    } else {
      stats = stats.toUpperCase()
    }
    env.loadCountry(browserslist.usage, stats, browserslist.data)
    data = browserslist.usage[stats]
  } else {
    if ('dataByBrowser' in stats) {
      stats = stats.dataByBrowser
    }
    data = { }
    for (var name in stats) {
      for (var version in stats[name]) {
        data[name + ' ' + version] = stats[name][version]
      }
    }
  }

  return browsers.reduce(function (all, i) {
    var usage = data[i]
    if (usage === undefined) {
      usage = data[i.replace(/ \S+$/, ' 0')]
    }
    return all + (usage || 0)
  }, 0)
}

function nodeQuery (context, version) {
  var nodeReleases = jsReleases.filter(function (i) {
    return i.name === 'nodejs'
  })
  var matched = nodeReleases.filter(function (i) {
    return isVersionsMatch(i.version, version)
  })
  if (matched.length === 0) {
    if (context.ignoreUnknownVersions) {
      return []
    } else {
      throw new BrowserslistError('Unknown version ' + version + ' of Node.js')
    }
  }
  return ['node ' + matched[matched.length - 1].version]
}

function sinceQuery (context, year, month, date) {
  year = parseInt(year)
  month = parseInt(month || '01') - 1
  date = parseInt(date || '01')
  return filterByYear(Date.UTC(year, month, date, 0, 0, 0), context)
}

function coverQuery (context, coverage, statMode) {
  coverage = parseFloat(coverage)
  var usage = browserslist.usage.global
  if (statMode) {
    if (statMode.match(/^my\s+stats$/)) {
      if (!context.customUsage) {
        throw new BrowserslistError(
          'Custom usage statistics was not provided'
        )
      }
      usage = context.customUsage
    } else {
      var place
      if (statMode.length === 2) {
        place = statMode.toUpperCase()
      } else {
        place = statMode.toLowerCase()
      }
      env.loadCountry(browserslist.usage, place, browserslist.data)
      usage = browserslist.usage[place]
    }
  }
  var versions = Object.keys(usage).sort(function (a, b) {
    return usage[b] - usage[a]
  })
  var coveraged = 0
  var result = []
  var version
  for (var i = 0; i <= versions.length; i++) {
    version = versions[i]
    if (usage[version] === 0) break
    coveraged += usage[version]
    result.push(version)
    if (coveraged >= coverage) break
  }
  return result
}

var QUERIES = [
  {
    regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
    select: function (context, versions) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context)
        if (!data) return selected
        var list = getMajorVersions(data.released, versions)
        list = list.map(nameMapper(data.name))
        if (data.name === 'android') {
          list = filterAndroid(list, versions, context)
        }
        return selected.concat(list)
      }, [])
    }
  },
  {
    regexp: /^last\s+(\d+)\s+versions?$/i,
    select: function (context, versions) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context)
        if (!data) return selected
        var list = data.released.slice(-versions)
        list = list.map(nameMapper(data.name))
        if (data.name === 'android') {
          list = filterAndroid(list, versions, context)
        }
        return selected.concat(list)
      }, [])
    }
  },
  {
    regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
    select: function (context, versions) {
      var validVersions = getMajorVersions(Object.keys(e2c), versions)
      return validVersions.map(function (i) {
        return 'chrome ' + e2c[i]
      })
    }
  },
  {
    regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
    select: function (context, versions, name) {
      var data = checkName(name, context)
      var validVersions = getMajorVersions(data.released, versions)
      var list = validVersions.map(nameMapper(data.name))
      if (data.name === 'android') {
        list = filterAndroid(list, versions, context)
      }
      return list
    }
  },
  {
    regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
    select: function (context, versions) {
      return Object.keys(e2c)
        .slice(-versions)
        .map(function (i) {
          return 'chrome ' + e2c[i]
        })
    }
  },
  {
    regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
    select: function (context, versions, name) {
      var data = checkName(name, context)
      var list = data.released.slice(-versions).map(nameMapper(data.name))
      if (data.name === 'android') {
        list = filterAndroid(list, versions, context)
      }
      return list
    }
  },
  {
    regexp: /^unreleased\s+versions$/i,
    select: function (context) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context)
        if (!data) return selected
        var list = data.versions.filter(function (v) {
          return data.released.indexOf(v) === -1
        })
        list = list.map(nameMapper(data.name))
        return selected.concat(list)
      }, [])
    }
  },
  {
    regexp: /^unreleased\s+electron\s+versions?$/i,
    select: function () {
      return []
    }
  },
  {
    regexp: /^unreleased\s+(\w+)\s+versions?$/i,
    select: function (context, name) {
      var data = checkName(name, context)
      return data.versions
        .filter(function (v) {
          return data.released.indexOf(v) === -1
        })
        .map(nameMapper(data.name))
    }
  },
  {
    regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
    select: function (context, years) {
      return filterByYear(Date.now() - YEAR * years, context)
    }
  },
  {
    regexp: /^since (\d+)$/i,
    select: sinceQuery
  },
  {
    regexp: /^since (\d+)-(\d+)$/i,
    select: sinceQuery
  },
  {
    regexp: /^since (\d+)-(\d+)-(\d+)$/i,
    select: sinceQuery
  },
  {
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
    select: function (context, sign, popularity) {
      popularity = parseFloat(popularity)
      var usage = browserslist.usage.global
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version)
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version)
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version)
          }
        } else if (usage[version] >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  {
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
    select: function (context, sign, popularity) {
      popularity = parseFloat(popularity)
      if (!context.customUsage) {
        throw new BrowserslistError('Custom usage statistics was not provided')
      }
      var usage = context.customUsage
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version)
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version)
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version)
          }
        } else if (usage[version] >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  {
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
    select: function (context, sign, popularity, name) {
      popularity = parseFloat(popularity)
      var stats = env.loadStat(context, name, browserslist.data)
      if (stats) {
        context.customUsage = {}
        for (var browser in stats) {
          fillUsage(context.customUsage, browser, stats[browser])
        }
      }
      if (!context.customUsage) {
        throw new BrowserslistError('Custom usage statistics was not provided')
      }
      var usage = context.customUsage
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version)
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version)
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version)
          }
        } else if (usage[version] >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  {
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
    select: function (context, sign, popularity, place) {
      popularity = parseFloat(popularity)
      if (place.length === 2) {
        place = place.toUpperCase()
      } else {
        place = place.toLowerCase()
      }
      env.loadCountry(browserslist.usage, place, browserslist.data)
      var usage = browserslist.usage[place]
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version)
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version)
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version)
          }
        } else if (usage[version] >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  {
    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/,
    select: coverQuery
  },
  {
    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/,
    select: coverQuery
  },
  {
    regexp: /^supports\s+([\w-]+)$/,
    select: function (context, feature) {
      env.loadFeature(browserslist.cache, feature)
      var features = browserslist.cache[feature]
      return Object.keys(features).reduce(function (result, version) {
        var flags = features[version]
        if (flags.indexOf('y') >= 0 || flags.indexOf('a') >= 0) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  {
    regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, from, to) {
      var fromToUse = normalizeElectron(from)
      var toToUse = normalizeElectron(to)
      if (!e2c[fromToUse]) {
        throw new BrowserslistError('Unknown version ' + from + ' of electron')
      }
      if (!e2c[toToUse]) {
        throw new BrowserslistError('Unknown version ' + to + ' of electron')
      }
      from = parseFloat(from)
      to = parseFloat(to)
      return Object.keys(e2c)
        .filter(function (i) {
          var parsed = parseFloat(i)
          return parsed >= from && parsed <= to
        })
        .map(function (i) {
          return 'chrome ' + e2c[i]
        })
    }
  },
  {
    regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, from, to) {
      var nodeVersions = jsReleases
        .filter(function (i) {
          return i.name === 'nodejs'
        })
        .map(function (i) {
          return i.version
        })
      return nodeVersions
        .filter(semverFilterLoose('>=', from))
        .filter(semverFilterLoose('<=', to))
        .map(function (v) {
          return 'node ' + v
        })
    }
  },
  {
    regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, name, from, to) {
      var data = checkName(name, context)
      from = parseFloat(normalizeVersion(data, from) || from)
      to = parseFloat(normalizeVersion(data, to) || to)
      function filter (v) {
        var parsed = parseFloat(v)
        return parsed >= from && parsed <= to
      }
      return data.released.filter(filter).map(nameMapper(data.name))
    }
  },
  {
    regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function (context, sign, version) {
      var versionToUse = normalizeElectron(version)
      return Object.keys(e2c)
        .filter(generateFilter(sign, versionToUse))
        .map(function (i) {
          return 'chrome ' + e2c[i]
        })
    }
  },
  {
    regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function (context, sign, version) {
      var nodeVersions = jsReleases
        .filter(function (i) {
          return i.name === 'nodejs'
        })
        .map(function (i) {
          return i.version
        })
      return nodeVersions
        .filter(generateSemverFilter(sign, version))
        .map(function (v) {
          return 'node ' + v
        })
    }
  },
  {
    regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
    select: function (context, name, sign, version) {
      var data = checkName(name, context)
      var alias = browserslist.versionAliases[data.name][version]
      if (alias) {
        version = alias
      }
      return data.released
        .filter(generateFilter(sign, version))
        .map(function (v) {
          return data.name + ' ' + v
        })
    }
  },
  {
    regexp: /^(firefox|ff|fx)\s+esr$/i,
    select: function () {
      return ['firefox 78', 'firefox 91']
    }
  },
  {
    regexp: /(operamini|op_mini)\s+all/i,
    select: function () {
      return ['op_mini all']
    }
  },
  {
    regexp: /^electron\s+([\d.]+)$/i,
    select: function (context, version) {
      var versionToUse = normalizeElectron(version)
      var chrome = e2c[versionToUse]
      if (!chrome) {
        throw new BrowserslistError(
          'Unknown version ' + version + ' of electron'
        )
      }
      return ['chrome ' + chrome]
    }
  },
  {
    regexp: /^node\s+(\d+)$/i,
    select: nodeQuery
  },
  {
    regexp: /^node\s+(\d+\.\d+)$/i,
    select: nodeQuery
  },
  {
    regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
    select: nodeQuery
  },
  {
    regexp: /^current\s+node$/i,
    select: function (context) {
      return [env.currentNode(resolve, context)]
    }
  },
  {
    regexp: /^maintained\s+node\s+versions$/i,
    select: function (context) {
      var now = Date.now()
      var queries = Object.keys(jsEOL)
        .filter(function (key) {
          return (
            now < Date.parse(jsEOL[key].end) &&
            now > Date.parse(jsEOL[key].start) &&
            isEolReleased(key)
          )
        })
        .map(function (key) {
          return 'node ' + key.slice(1)
        })
      return resolve(queries, context)
    }
  },
  {
    regexp: /^phantomjs\s+1.9$/i,
    select: function () {
      return ['safari 5']
    }
  },
  {
    regexp: /^phantomjs\s+2.1$/i,
    select: function () {
      return ['safari 6']
    }
  },
  {
    regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
    select: function (context, name, version) {
      if (/^tp$/i.test(version)) version = 'TP'
      var data = checkName(name, context)
      var alias = normalizeVersion(data, version)
      if (alias) {
        version = alias
      } else {
        if (version.indexOf('.') === -1) {
          alias = version + '.0'
        } else {
          alias = version.replace(/\.0$/, '')
        }
        alias = normalizeVersion(data, alias)
        if (alias) {
          version = alias
        } else if (context.ignoreUnknownVersions) {
          return []
        } else {
          throw new BrowserslistError(
            'Unknown version ' + version + ' of ' + name
          )
        }
      }
      return [data.name + ' ' + version]
    }
  },
  {
    regexp: /^browserslist config$/i,
    select: function (context) {
      return browserslist(undefined, context)
    }
  },
  {
    regexp: /^extends (.+)$/i,
    select: function (context, name) {
      return resolve(env.loadQueries(context, name), context)
    }
  },
  {
    regexp: /^defaults$/i,
    select: function (context) {
      return resolve(browserslist.defaults, context)
    }
  },
  {
    regexp: /^dead$/i,
    select: function (context) {
      var dead = [
        'ie <= 10',
        'ie_mob <= 11',
        'bb <= 10',
        'op_mob <= 12.1',
        'samsung 4'
      ]
      return resolve(dead, context)
    }
  },
  {
    regexp: /^(\w+)$/i,
    select: function (context, name) {
      if (byName(name, context)) {
        throw new BrowserslistError(
          'Specify versions in Browserslist query for browser ' + name
        )
      } else {
        throw unknownQuery(name)
      }
    }
  }
];

// Get and convert Can I Use data

(function () {
  for (var name in agents) {
    var browser = agents[name]
    browserslist.data[name] = {
      name: name,
      versions: normalize(agents[name].versions),
      released: normalize(agents[name].versions.slice(0, -3)),
      releaseDate: agents[name].release_date
    }
    fillUsage(browserslist.usage.global, name, browser.usage_global)

    browserslist.versionAliases[name] = { }
    for (var i = 0; i < browser.versions.length; i++) {
      var full = browser.versions[i]
      if (!full) continue

      if (full.indexOf('-') !== -1) {
        var interval = full.split('-')
        for (var j = 0; j < interval.length; j++) {
          browserslist.versionAliases[name][interval[j]] = full
        }
      }
    }
  }

  browserslist.versionAliases.op_mob['59'] = '58'
}())

module.exports = browserslist


/***/ }),

/***/ 20486:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var feature = __nccwpck_require__(13206).default
var region = __nccwpck_require__(53506).default
var path = __nccwpck_require__(85622)
var fs = __nccwpck_require__(35747)

var BrowserslistError = __nccwpck_require__(92498)

var IS_SECTION = /^\s*\[(.+)]\s*$/
var CONFIG_PATTERN = /^browserslist-config-/
var SCOPED_CONFIG__PATTERN = /@[^/]+\/browserslist-config(-|$|\/)/
var TIME_TO_UPDATE_CANIUSE = 6 * 30 * 24 * 60 * 60 * 1000
var FORMAT = 'Browserslist config should be a string or an array ' +
             'of strings with browser queries'

var dataTimeChecked = false
var filenessCache = { }
var configCache = { }
function checkExtend (name) {
  var use = ' Use `dangerousExtend` option to disable.'
  if (!CONFIG_PATTERN.test(name) && !SCOPED_CONFIG__PATTERN.test(name)) {
    throw new BrowserslistError(
      'Browserslist config needs `browserslist-config-` prefix. ' + use)
  }
  if (name.replace(/^@[^/]+\//, '').indexOf('.') !== -1) {
    throw new BrowserslistError(
      '`.` not allowed in Browserslist config name. ' + use)
  }
  if (name.indexOf('node_modules') !== -1) {
    throw new BrowserslistError(
      '`node_modules` not allowed in Browserslist config.' + use)
  }
}

function isFile (file) {
  if (file in filenessCache) {
    return filenessCache[file]
  }
  var result = fs.existsSync(file) && fs.statSync(file).isFile()
  if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
    filenessCache[file] = result
  }
  return result
}

function eachParent (file, callback) {
  var dir = isFile(file) ? path.dirname(file) : file
  var loc = path.resolve(dir)
  do {
    var result = callback(loc)
    if (typeof result !== 'undefined') return result
  } while (loc !== (loc = path.dirname(loc)))
  return undefined
}

function check (section) {
  if (Array.isArray(section)) {
    for (var i = 0; i < section.length; i++) {
      if (typeof section[i] !== 'string') {
        throw new BrowserslistError(FORMAT)
      }
    }
  } else if (typeof section !== 'string') {
    throw new BrowserslistError(FORMAT)
  }
}

function pickEnv (config, opts) {
  if (typeof config !== 'object') return config

  var name
  if (typeof opts.env === 'string') {
    name = opts.env
  } else if (process.env.BROWSERSLIST_ENV) {
    name = process.env.BROWSERSLIST_ENV
  } else if (process.env.NODE_ENV) {
    name = process.env.NODE_ENV
  } else {
    name = 'production'
  }

  return config[name] || config.defaults
}

function parsePackage (file) {
  var config = JSON.parse(fs.readFileSync(file))
  if (config.browserlist && !config.browserslist) {
    throw new BrowserslistError(
      '`browserlist` key instead of `browserslist` in ' + file
    )
  }
  var list = config.browserslist
  if (Array.isArray(list) || typeof list === 'string') {
    list = { defaults: list }
  }
  for (var i in list) {
    check(list[i])
  }

  return list
}

function latestReleaseTime (agents) {
  var latest = 0
  for (var name in agents) {
    var dates = agents[name].releaseDate || { }
    for (var key in dates) {
      if (latest < dates[key]) {
        latest = dates[key]
      }
    }
  }
  return latest * 1000
}

function normalizeStats (data, stats) {
  if (!data) {
    data = {}
  }
  if (stats && 'dataByBrowser' in stats) {
    stats = stats.dataByBrowser
  }

  if (typeof stats !== 'object') return undefined

  var normalized = { }
  for (var i in stats) {
    var versions = Object.keys(stats[i])
    if (
      versions.length === 1 &&
      data[i] &&
      data[i].versions.length === 1
    ) {
      var normal = data[i].versions[0]
      normalized[i] = { }
      normalized[i][normal] = stats[i][versions[0]]
    } else {
      normalized[i] = stats[i]
    }
  }

  return normalized
}

function normalizeUsageData (usageData, data) {
  for (var browser in usageData) {
    var browserUsage = usageData[browser]
    // eslint-disable-next-line max-len
    // https://github.com/browserslist/browserslist/issues/431#issuecomment-565230615
    // caniuse-db returns { 0: "percentage" } for `and_*` regional stats
    if ('0' in browserUsage) {
      var versions = data[browser].versions
      browserUsage[versions[versions.length - 1]] = browserUsage[0]
      delete browserUsage[0]
    }
  }
}

module.exports = {
  loadQueries: function loadQueries (ctx, name) {
    if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
      checkExtend(name)
    }
    // eslint-disable-next-line security/detect-non-literal-require
    var queries = require(__nccwpck_require__(28440).resolve(name, { paths: ['.'] }))
    if (queries) {
      if (Array.isArray(queries)) {
        return queries
      } else if (typeof queries === 'object') {
        if (!queries.defaults) queries.defaults = []
        return pickEnv(queries, ctx, name)
      }
    }
    throw new BrowserslistError(
      '`' + name + '` config exports not an array of queries' +
      ' or an object of envs'
    )
  },

  loadStat: function loadStat (ctx, name, data) {
    if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
      checkExtend(name)
    }
    // eslint-disable-next-line security/detect-non-literal-require
    var stats = require(
      __nccwpck_require__(28440).resolve(
        path.join(name, 'browserslist-stats.json'),
        { paths: ['.'] }
      )
    )
    return normalizeStats(data, stats)
  },

  getStat: function getStat (opts, data) {
    var stats
    if (opts.stats) {
      stats = opts.stats
    } else if (process.env.BROWSERSLIST_STATS) {
      stats = process.env.BROWSERSLIST_STATS
    } else if (opts.path && path.resolve && fs.existsSync) {
      stats = eachParent(opts.path, function (dir) {
        var file = path.join(dir, 'browserslist-stats.json')
        return isFile(file) ? file : undefined
      })
    }
    if (typeof stats === 'string') {
      try {
        stats = JSON.parse(fs.readFileSync(stats))
      } catch (e) {
        throw new BrowserslistError('Can\'t read ' + stats)
      }
    }
    return normalizeStats(data, stats)
  },

  loadConfig: function loadConfig (opts) {
    if (process.env.BROWSERSLIST) {
      return process.env.BROWSERSLIST
    } else if (opts.config || process.env.BROWSERSLIST_CONFIG) {
      var file = opts.config || process.env.BROWSERSLIST_CONFIG
      if (path.basename(file) === 'package.json') {
        return pickEnv(parsePackage(file), opts)
      } else {
        return pickEnv(module.exports.readConfig(file), opts)
      }
    } else if (opts.path) {
      return pickEnv(module.exports.findConfig(opts.path), opts)
    } else {
      return undefined
    }
  },

  loadCountry: function loadCountry (usage, country, data) {
    var code = country.replace(/[^\w-]/g, '')
    if (!usage[code]) {
      // eslint-disable-next-line security/detect-non-literal-require
      var compressed = require('caniuse-lite/data/regions/' + code + '.js')
      var usageData = region(compressed)
      normalizeUsageData(usageData, data)
      usage[country] = { }
      for (var i in usageData) {
        for (var j in usageData[i]) {
          usage[country][i + ' ' + j] = usageData[i][j]
        }
      }
    }
  },

  loadFeature: function loadFeature (features, name) {
    name = name.replace(/[^\w-]/g, '')
    if (features[name]) return

    // eslint-disable-next-line security/detect-non-literal-require
    var compressed = require('caniuse-lite/data/features/' + name + '.js')
    var stats = feature(compressed).stats
    features[name] = { }
    for (var i in stats) {
      for (var j in stats[i]) {
        features[name][i + ' ' + j] = stats[i][j]
      }
    }
  },

  parseConfig: function parseConfig (string) {
    var result = { defaults: [] }
    var sections = ['defaults']

    string.toString()
      .replace(/#[^\n]*/g, '')
      .split(/\n|,/)
      .map(function (line) {
        return line.trim()
      })
      .filter(function (line) {
        return line !== ''
      })
      .forEach(function (line) {
        if (IS_SECTION.test(line)) {
          sections = line.match(IS_SECTION)[1].trim().split(' ')
          sections.forEach(function (section) {
            if (result[section]) {
              throw new BrowserslistError(
                'Duplicate section ' + section + ' in Browserslist config'
              )
            }
            result[section] = []
          })
        } else {
          sections.forEach(function (section) {
            result[section].push(line)
          })
        }
      })

    return result
  },

  readConfig: function readConfig (file) {
    if (!isFile(file)) {
      throw new BrowserslistError('Can\'t read ' + file + ' config')
    }
    return module.exports.parseConfig(fs.readFileSync(file))
  },

  findConfig: function findConfig (from) {
    from = path.resolve(from)

    var passed = []
    var resolved = eachParent(from, function (dir) {
      if (dir in configCache) {
        return configCache[dir]
      }

      passed.push(dir)

      var config = path.join(dir, 'browserslist')
      var pkg = path.join(dir, 'package.json')
      var rc = path.join(dir, '.browserslistrc')

      var pkgBrowserslist
      if (isFile(pkg)) {
        try {
          pkgBrowserslist = parsePackage(pkg)
        } catch (e) {
          if (e.name === 'BrowserslistError') throw e
          console.warn(
            '[Browserslist] Could not parse ' + pkg + '. Ignoring it.'
          )
        }
      }

      if (isFile(config) && pkgBrowserslist) {
        throw new BrowserslistError(
          dir + ' contains both browserslist and package.json with browsers'
        )
      } else if (isFile(rc) && pkgBrowserslist) {
        throw new BrowserslistError(
          dir + ' contains both .browserslistrc and package.json with browsers'
        )
      } else if (isFile(config) && isFile(rc)) {
        throw new BrowserslistError(
          dir + ' contains both .browserslistrc and browserslist'
        )
      } else if (isFile(config)) {
        return module.exports.readConfig(config)
      } else if (isFile(rc)) {
        return module.exports.readConfig(rc)
      } else {
        return pkgBrowserslist
      }
    })
    if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
      passed.forEach(function (dir) {
        configCache[dir] = resolved
      })
    }
    return resolved
  },

  clearCaches: function clearCaches () {
    dataTimeChecked = false
    filenessCache = { }
    configCache = { }

    this.cache = { }
  },

  oldDataWarning: function oldDataWarning (agentsObj) {
    if (dataTimeChecked) return
    dataTimeChecked = true
    if (process.env.BROWSERSLIST_IGNORE_OLD_DATA) return

    var latest = latestReleaseTime(agentsObj)
    var halfYearAgo = Date.now() - TIME_TO_UPDATE_CANIUSE

    if (latest !== 0 && latest < halfYearAgo) {
      console.warn(
        'Browserslist: caniuse-lite is outdated. Please run:\n' +
        '  npx browserslist@latest --update-db\n' +
        '  Why you should do it regularly: ' +
        'https://github.com/browserslist/browserslist#browsers-data-updating'
      )
    }
  },

  currentNode: function currentNode () {
    return 'node ' + process.versions.node
  }
}


/***/ }),

/***/ 78390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getBrowserScope = exports.setBrowserScope = exports.getLatestStableBrowsers = exports.find = exports.isSupported = exports.getSupport = exports.features = undefined;

var _lodash = __nccwpck_require__(24538);

var _lodash2 = _interopRequireDefault(_lodash);

var _browserslist = __nccwpck_require__(55478);

var _browserslist2 = _interopRequireDefault(_browserslist);

var _caniuseLite = __nccwpck_require__(64006);

var _utils = __nccwpck_require__(53228);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var featuresList = Object.keys(_caniuseLite.features);

var browsers = void 0;
function setBrowserScope(browserList) {
  browsers = (0, _utils.cleanBrowsersList)(browserList);
}

function getBrowserScope() {
  return browsers;
}

var parse = (0, _lodash2.default)(_utils.parseCaniuseData, function (feat, browsers) {
  return feat.title + browsers;
});

function getSupport(query) {
  var feature = void 0;
  try {
    feature = (0, _caniuseLite.feature)(_caniuseLite.features[query]);
  } catch (e) {
    var res = find(query);
    if (res.length === 1) return getSupport(res[0]);
    throw new ReferenceError("Please provide a proper feature name. Cannot find " + query);
  }
  return parse(feature, browsers);
}

function isSupported(feature, browsers) {
  var data = void 0;
  try {
    data = (0, _caniuseLite.feature)(_caniuseLite.features[feature]);
  } catch (e) {
    var res = find(feature);
    if (res.length === 1) {
      data = _caniuseLite.features[res[0]];
    } else {
      throw new ReferenceError("Please provide a proper feature name. Cannot find " + feature);
    }
  }

  return (0, _browserslist2.default)(browsers, { ignoreUnknownVersions: true }).map(function (browser) {
    return browser.split(" ");
  }).every(function (browser) {
    return data.stats[browser[0]] && data.stats[browser[0]][browser[1]] === "y";
  });
}

function find(query) {
  if (typeof query !== "string") {
    throw new TypeError("The `query` parameter should be a string.");
  }

  if (~featuresList.indexOf(query)) {
    // exact match
    return query;
  }

  return featuresList.filter(function (file) {
    return (0, _utils.contains)(file, query);
  });
}

function getLatestStableBrowsers() {
  return (0, _browserslist2.default)("last 1 version");
}

setBrowserScope();

exports.features = featuresList;
exports.getSupport = getSupport;
exports.isSupported = isSupported;
exports.find = find;
exports.getLatestStableBrowsers = getLatestStableBrowsers;
exports.setBrowserScope = setBrowserScope;
exports.getBrowserScope = getBrowserScope;

/***/ }),

/***/ 53228:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.contains = contains;
exports.parseCaniuseData = parseCaniuseData;
exports.cleanBrowsersList = cleanBrowsersList;

var _lodash = __nccwpck_require__(78216);

var _lodash2 = _interopRequireDefault(_lodash);

var _browserslist = __nccwpck_require__(55478);

var _browserslist2 = _interopRequireDefault(_browserslist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function contains(str, substr) {
  return !!~str.indexOf(substr);
}

function parseCaniuseData(feature, browsers) {
  var support = {};
  var letters;
  var letter;

  browsers.forEach(function (browser) {
    support[browser] = {};
    for (var info in feature.stats[browser]) {
      letters = feature.stats[browser][info].replace(/#\d+/, "").trim().split(" ");
      info = parseFloat(info.split("-")[0]); //if info is a range, take the left
      if (isNaN(info)) continue;
      for (var i = 0; i < letters.length; i++) {
        letter = letters[i];
        if (letter === "d") {
          // skip this letter, we don't support it yet
          continue;
        } else if (letter === "y") {
          // min support asked, need to find the min value
          if (typeof support[browser][letter] === "undefined" || info < support[browser][letter]) {
            support[browser][letter] = info;
          }
        } else {
          // any other support, need to find the max value
          if (typeof support[browser][letter] === "undefined" || info > support[browser][letter]) {
            support[browser][letter] = info;
          }
        }
      }
    }
  });

  return support;
}

function cleanBrowsersList(browserList) {
  return (0, _lodash2.default)((0, _browserslist2.default)(browserList).map(function (browser) {
    return browser.split(" ")[0];
  }));
}

/***/ }),

/***/ 306:
/***/ ((module) => {

module.exports={A:{A:{J:0.0131217,D:0.00621152,E:0.020096,F:0.113877,A:0.0133974,B:0.763649,iB:0.009298},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","iB","J","D","E","F","A","B","","",""],E:"IE",F:{iB:962323200,J:998870400,D:1161129600,E:1237420800,F:1300060800,A:1346716800,B:1381968000}},B:{A:{C:0.008282,K:0.004267,L:0.004141,G:0.004141,M:0.008282,N:0.016564,O:0.078679,R:0,S:0.004298,T:0.00944,U:0.00415,V:0.008282,W:0.008282,X:0.008282,Y:0.008282,Z:0.008282,a:0.020705,P:0.024846,b:2.58398,H:0.712252},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","C","K","L","G","M","N","O","R","S","T","U","V","W","X","Y","Z","a","P","b","H","","",""],E:"Edge",F:{C:1438128000,K:1447286400,L:1470096000,G:1491868800,M:1508198400,N:1525046400,O:1542067200,R:1579046400,S:1581033600,T:1586736000,U:1590019200,V:1594857600,W:1598486400,X:1602201600,Y:1605830400,Z:1611360000,a:1614816000,P:1618358400,b:1622073600,H:1626912000},D:{C:"ms",K:"ms",L:"ms",G:"ms",M:"ms",N:"ms",O:"ms"}},C:{A:{"0":0.0047,"1":0.04141,"2":0.008282,"3":0.004141,"4":0.004525,"5":0.004141,"6":0.008282,"7":0.004538,"8":0.008282,"9":0.004141,jB:0.012813,aB:0.004271,I:0.020705,c:0.004879,J:0.020136,D:0.005725,E:0.004525,F:0.00533,A:0.004283,B:0.004141,C:0.004471,K:0.004486,L:0.00453,G:0.008542,M:0.004417,N:0.004425,O:0.008542,d:0.004443,e:0.004283,f:0.008542,g:0.013698,h:0.008542,i:0.008786,j:0.004141,k:0.004317,l:0.004393,m:0.004418,n:0.008834,o:0.008542,p:0.008928,q:0.004471,r:0.009284,s:0.004707,t:0.009076,u:0.004425,v:0.004783,w:0.004271,x:0.004783,y:0.00487,z:0.005029,AB:0.074538,BB:0.004335,CB:0.004141,DB:0.004141,EB:0.008282,FB:0.004425,GB:0.004141,bB:0.004141,HB:0.008282,cB:0.00472,IB:0.004425,JB:0.008282,Q:0.00415,KB:0.004267,LB:0.004141,MB:0.004267,NB:0.012423,OB:0.00415,PB:0.008282,QB:0.004425,RB:0.024846,SB:0.00415,TB:0.00415,UB:0.004141,VB:0.004298,WB:0.004141,XB:0.161499,R:0.008282,S:0.008282,T:0.008282,kB:0.016564,U:0.008282,V:0.016564,W:0.008282,X:0.012423,Y:0.016564,Z:0.057974,a:1.51146,P:0.919302,b:0.016564,H:0,dB:0,lB:0.008786,mB:0.00487},B:"moz",C:["jB","aB","lB","mB","I","c","J","D","E","F","A","B","C","K","L","G","M","N","O","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","AB","BB","CB","DB","EB","FB","GB","bB","HB","cB","IB","JB","Q","KB","LB","MB","NB","OB","PB","QB","RB","SB","TB","UB","VB","WB","XB","R","S","T","kB","U","V","W","X","Y","Z","a","P","b","H","dB",""],E:"Firefox",F:{"0":1446508800,"1":1450137600,"2":1453852800,"3":1457395200,"4":1461628800,"5":1465257600,"6":1470096000,"7":1474329600,"8":1479168000,"9":1485216000,jB:1161648000,aB:1213660800,lB:1246320000,mB:1264032000,I:1300752000,c:1308614400,J:1313452800,D:1317081600,E:1317081600,F:1320710400,A:1324339200,B:1327968000,C:1331596800,K:1335225600,L:1338854400,G:1342483200,M:1346112000,N:1349740800,O:1353628800,d:1357603200,e:1361232000,f:1364860800,g:1368489600,h:1372118400,i:1375747200,j:1379376000,k:1386633600,l:1391472000,m:1395100800,n:1398729600,o:1402358400,p:1405987200,q:1409616000,r:1413244800,s:1417392000,t:1421107200,u:1424736000,v:1428278400,w:1431475200,x:1435881600,y:1439251200,z:1442880000,AB:1488844800,BB:1492560000,CB:1497312000,DB:1502150400,EB:1506556800,FB:1510617600,GB:1516665600,bB:1520985600,HB:1525824000,cB:1529971200,IB:1536105600,JB:1540252800,Q:1544486400,KB:1548720000,LB:1552953600,MB:1558396800,NB:1562630400,OB:1567468800,PB:1571788800,QB:1575331200,RB:1578355200,SB:1581379200,TB:1583798400,UB:1586304000,VB:1588636800,WB:1591056000,XB:1593475200,R:1595894400,S:1598313600,T:1600732800,kB:1603152000,U:1605571200,V:1607990400,W:1611619200,X:1614038400,Y:1616457600,Z:1618790400,a:1622505600,P:1626134400,b:1628553600,H:null,dB:null}},D:{A:{"0":0.004403,"1":0.008282,"2":0.004465,"3":0.004642,"4":0.004891,"5":0.012423,"6":0.020705,"7":0.182204,"8":0.004141,"9":0.004141,I:0.004706,c:0.004879,J:0.004879,D:0.005591,E:0.005591,F:0.005591,A:0.004534,B:0.004464,C:0.010424,K:0.0083,L:0.004706,G:0.015087,M:0.004393,N:0.004393,O:0.008652,d:0.008542,e:0.004393,f:0.004317,g:0.012423,h:0.008786,i:0.008282,j:0.004461,k:0.004141,l:0.004326,m:0.0047,n:0.004538,o:0.008542,p:0.008596,q:0.004566,r:0.004141,s:0.008282,t:0.008282,u:0.004335,v:0.004464,w:0.028987,x:0.004464,y:0.012423,z:0.0236,AB:0.004141,BB:0.020705,CB:0.008282,DB:0.012423,EB:0.045551,FB:0.008282,GB:0.008282,bB:0.008282,HB:0.012423,cB:0.074538,IB:0.008282,JB:0.016564,Q:0.020705,KB:0.020705,LB:0.020705,MB:0.020705,NB:0.012423,OB:0.066256,PB:0.053833,QB:0.028987,RB:0.04141,SB:0.016564,TB:0.111807,UB:0.08282,VB:0.053833,WB:0.024846,XB:0.049692,R:0.186345,S:0.08282,T:0.070397,U:0.091102,V:0.091102,W:0.236037,X:0.099384,Y:0.285729,Z:0.128371,a:0.227755,P:0.596304,b:17.9554,H:4.05818,dB:0.024846,nB:0.008282,oB:0},B:"webkit",C:["","","","","I","c","J","D","E","F","A","B","C","K","L","G","M","N","O","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","AB","BB","CB","DB","EB","FB","GB","bB","HB","cB","IB","JB","Q","KB","LB","MB","NB","OB","PB","QB","RB","SB","TB","UB","VB","WB","XB","R","S","T","U","V","W","X","Y","Z","a","P","b","H","dB","nB","oB"],E:"Chrome",F:{"0":1429401600,"1":1432080000,"2":1437523200,"3":1441152000,"4":1444780800,"5":1449014400,"6":1453248000,"7":1456963200,"8":1460592000,"9":1464134400,I:1264377600,c:1274745600,J:1283385600,D:1287619200,E:1291248000,F:1296777600,A:1299542400,B:1303862400,C:1307404800,K:1312243200,L:1316131200,G:1316131200,M:1319500800,N:1323734400,O:1328659200,d:1332892800,e:1337040000,f:1340668800,g:1343692800,h:1348531200,i:1352246400,j:1357862400,k:1361404800,l:1364428800,m:1369094400,n:1374105600,o:1376956800,p:1384214400,q:1389657600,r:1392940800,s:1397001600,t:1400544000,u:1405468800,v:1409011200,w:1412640000,x:1416268800,y:1421798400,z:1425513600,AB:1469059200,BB:1472601600,CB:1476230400,DB:1480550400,EB:1485302400,FB:1489017600,GB:1492560000,bB:1496707200,HB:1500940800,cB:1504569600,IB:1508198400,JB:1512518400,Q:1516752000,KB:1520294400,LB:1523923200,MB:1527552000,NB:1532390400,OB:1536019200,PB:1539648000,QB:1543968000,RB:1548720000,SB:1552348800,TB:1555977600,UB:1559606400,VB:1564444800,WB:1568073600,XB:1571702400,R:1575936000,S:1580860800,T:1586304000,U:1589846400,V:1594684800,W:1598313600,X:1601942400,Y:1605571200,Z:1611014400,a:1614556800,P:1618272000,b:1621987200,H:1626739200,dB:null,nB:null,oB:null}},E:{A:{I:0,c:0.008542,J:0.004656,D:0.004465,E:0.004141,F:0.004891,A:0.004425,B:0.008282,C:0.012423,K:0.078679,L:0.654278,G:0.012423,pB:0,eB:0.008692,qB:0.020705,rB:0.00456,sB:0.004283,tB:0.016564,fB:0.020705,YB:0.053833,ZB:0.08282,uB:0.546612,vB:2.36037,wB:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","pB","eB","I","c","qB","J","rB","D","sB","E","F","tB","A","fB","B","YB","C","ZB","K","uB","L","vB","G","wB",""],E:"Safari",F:{pB:1205798400,eB:1226534400,I:1244419200,c:1275868800,qB:1311120000,J:1343174400,rB:1382400000,D:1382400000,sB:1410998400,E:1413417600,F:1443657600,tB:1458518400,A:1474329600,fB:1490572800,B:1505779200,YB:1522281600,C:1537142400,ZB:1553472000,K:1568851200,uB:1585008000,L:1600214400,vB:1619395200,G:null,wB:null}},F:{A:{"0":0.004418,"1":0.008542,"2":0.004227,"3":0.004725,"4":0.008282,"5":0.008942,"6":0.004707,"7":0.004827,"8":0.004707,"9":0.004707,F:0.0082,B:0.016581,C:0.004317,G:0.00685,M:0.00685,N:0.00685,O:0.005014,d:0.006015,e:0.004879,f:0.006597,g:0.006597,h:0.013434,i:0.006702,j:0.006015,k:0.005595,l:0.004393,m:0.008652,n:0.004879,o:0.004879,p:0.004141,q:0.005152,r:0.005014,s:0.009758,t:0.004879,u:0.008282,v:0.004283,w:0.004367,x:0.004534,y:0.008282,z:0.004227,AB:0.004326,BB:0.008922,CB:0.014349,DB:0.004425,EB:0.00472,FB:0.004425,GB:0.004425,HB:0.00472,IB:0.004532,JB:0.004566,Q:0.02283,KB:0.00867,LB:0.004656,MB:0.004642,NB:0.004298,OB:0.00944,PB:0.00415,QB:0.004271,RB:0.004298,SB:0.096692,TB:0.004201,UB:0.004141,VB:0.190486,WB:0.687406,XB:0,xB:0.00685,yB:0,zB:0.008392,"0B":0.004706,YB:0.006229,gB:0.004879,"1B":0.008786,ZB:0.00472},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","F","xB","yB","zB","0B","B","YB","gB","1B","C","ZB","G","M","N","O","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","AB","BB","CB","DB","EB","FB","GB","HB","IB","JB","Q","KB","LB","MB","NB","OB","PB","QB","RB","SB","TB","UB","VB","WB","XB","","",""],E:"Opera",F:{"0":1481587200,"1":1486425600,"2":1490054400,"3":1494374400,"4":1498003200,"5":1502236800,"6":1506470400,"7":1510099200,"8":1515024000,"9":1517961600,F:1150761600,xB:1223424000,yB:1251763200,zB:1267488000,"0B":1277942400,B:1292457600,YB:1302566400,gB:1309219200,"1B":1323129600,C:1323129600,ZB:1352073600,G:1372723200,M:1377561600,N:1381104000,O:1386288000,d:1390867200,e:1393891200,f:1399334400,g:1401753600,h:1405987200,i:1409616000,j:1413331200,k:1417132800,l:1422316800,m:1425945600,n:1430179200,o:1433808000,p:1438646400,q:1442448000,r:1445904000,s:1449100800,t:1454371200,u:1457308800,v:1462320000,w:1465344000,x:1470096000,y:1474329600,z:1477267200,AB:1521676800,BB:1525910400,CB:1530144000,DB:1534982400,EB:1537833600,FB:1543363200,GB:1548201600,HB:1554768000,IB:1561593600,JB:1566259200,Q:1570406400,KB:1573689600,LB:1578441600,MB:1583971200,NB:1587513600,OB:1592956800,PB:1595894400,QB:1600128000,RB:1603238400,SB:1613520000,TB:1612224000,UB:1616544000,VB:1619568000,WB:1623715200,XB:1627948800},D:{F:"o",B:"o",C:"o",xB:"o",yB:"o",zB:"o","0B":"o",YB:"o",gB:"o","1B":"o",ZB:"o"}},G:{A:{E:0.00149029,eB:0,"2B":0,hB:0.00298058,"3B":0.00894175,"4B":0.0491796,"5B":0.0298058,"6B":0.0163932,"7B":0.0223544,"8B":0.140087,"9B":0.0372573,AC:0.143068,BC:0.0834563,CC:0.0640825,DC:0.071534,EC:0.199699,FC:0.0581214,GC:0.0268253,HC:0.149029,IC:0.490306,JC:2.41129,KC:10.2666},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","eB","2B","hB","3B","4B","5B","E","6B","7B","8B","9B","AC","BC","CC","DC","EC","FC","GC","HC","IC","JC","KC","","",""],E:"Safari on iOS",F:{eB:1270252800,"2B":1283904000,hB:1299628800,"3B":1331078400,"4B":1359331200,"5B":1394409600,E:1410912000,"6B":1413763200,"7B":1442361600,"8B":1458518400,"9B":1473724800,AC:1490572800,BC:1505779200,CC:1522281600,DC:1537142400,EC:1553472000,FC:1568851200,GC:1572220800,HC:1580169600,IC:1585008000,JC:1600214400,KC:1619395200}},H:{A:{LC:1.0761},B:"o",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","LC","","",""],E:"Opera Mini",F:{LC:1426464000}},I:{A:{aB:0,I:0.0269428,H:0,MC:0,NC:0,OC:0,PC:0.0179619,hB:0.0628666,QC:0,RC:0.302359},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","MC","NC","OC","aB","I","PC","hB","QC","RC","H","","",""],E:"Android Browser",F:{MC:1256515200,NC:1274313600,OC:1291593600,aB:1298332800,I:1318896000,PC:1341792000,hB:1374624000,QC:1386547200,RC:1401667200,H:1626998400}},J:{A:{D:0,A:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","D","A","","",""],E:"Blackberry Browser",F:{D:1325376000,A:1359504000}},K:{A:{A:0,B:0,C:0,Q:0.0111391,YB:0,gB:0,ZB:0},B:"o",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A","B","YB","gB","C","ZB","Q","","",""],E:"Opera Mobile",F:{A:1287100800,B:1300752000,YB:1314835200,gB:1318291200,C:1330300800,ZB:1349740800,Q:1613433600},D:{Q:"webkit"}},L:{A:{H:40.2461},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","H","","",""],E:"Chrome for Android",F:{H:1626998400}},M:{A:{P:0.298809},B:"moz",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","P","","",""],E:"Firefox for Android",F:{P:1626652800}},N:{A:{A:0.0115934,B:0.022664},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A","B","","",""],E:"IE Mobile",F:{A:1340150400,B:1353456000}},O:{A:{SC:1.20109},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","SC","","",""],E:"UC Browser for Android",F:{SC:1471392000},D:{SC:"webkit"}},P:{A:{I:0.291244,TC:0.0103543,UC:0.010304,VC:0.0832126,WC:0.0103584,XC:0.0520079,fB:0.0208032,YC:0.145622,ZC:0.0728111,aC:0.239236,bC:2.38196},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","I","TC","UC","VC","WC","XC","fB","YC","ZC","aC","bC","","",""],E:"Samsung Internet",F:{I:1461024000,TC:1481846400,UC:1509408000,VC:1528329600,WC:1546128000,XC:1554163200,fB:1567900800,YC:1582588800,ZC:1593475200,aC:1605657600,bC:1618531200}},Q:{A:{cC:0.181629},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","cC","","",""],E:"QQ Browser",F:{cC:1589846400}},R:{A:{dC:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","dC","","",""],E:"Baidu Browser",F:{dC:1491004800}},S:{A:{eC:0.111321},B:"moz",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","eC","","",""],E:"KaiOS Browser",F:{eC:1527811200}}};


/***/ }),

/***/ 95582:
/***/ ((module) => {

module.exports={"0":"42","1":"43","2":"44","3":"45","4":"46","5":"47","6":"48","7":"49","8":"50","9":"51",A:"10",B:"11",C:"12",D:"7",E:"8",F:"9",G:"15",H:"92",I:"4",J:"6",K:"13",L:"14",M:"16",N:"17",O:"18",P:"90",Q:"64",R:"79",S:"80",T:"81",U:"83",V:"84",W:"85",X:"86",Y:"87",Z:"88",a:"89",b:"91",c:"5",d:"19",e:"20",f:"21",g:"22",h:"23",i:"24",j:"25",k:"26",l:"27",m:"28",n:"29",o:"30",p:"31",q:"32",r:"33",s:"34",t:"35",u:"36",v:"37",w:"38",x:"39",y:"40",z:"41",AB:"52",BB:"53",CB:"54",DB:"55",EB:"56",FB:"57",GB:"58",HB:"60",IB:"62",JB:"63",KB:"65",LB:"66",MB:"67",NB:"68",OB:"69",PB:"70",QB:"71",RB:"72",SB:"73",TB:"74",UB:"75",VB:"76",WB:"77",XB:"78",YB:"11.1",ZB:"12.1",aB:"3",bB:"59",cB:"61",dB:"93",eB:"3.2",fB:"10.1",gB:"11.5",hB:"4.2-4.3",iB:"5.5",jB:"2",kB:"82",lB:"3.5",mB:"3.6",nB:"94",oB:"95",pB:"3.1",qB:"5.1",rB:"6.1",sB:"7.1",tB:"9.1",uB:"13.1",vB:"14.1",wB:"TP",xB:"9.5-9.6",yB:"10.0-10.1",zB:"10.5","0B":"10.6","1B":"11.6","2B":"4.0-4.1","3B":"5.0-5.1","4B":"6.0-6.1","5B":"7.0-7.1","6B":"8.1-8.4","7B":"9.0-9.2","8B":"9.3","9B":"10.0-10.2",AC:"10.3",BC:"11.0-11.2",CC:"11.3-11.4",DC:"12.0-12.1",EC:"12.2-12.4",FC:"13.0-13.1",GC:"13.2",HC:"13.3",IC:"13.4-13.7",JC:"14.0-14.4",KC:"14.5-14.7",LC:"all",MC:"2.1",NC:"2.2",OC:"2.3",PC:"4.1",QC:"4.4",RC:"4.4.3-4.4.4",SC:"12.12",TC:"5.0-5.4",UC:"6.2-6.4",VC:"7.2-7.4",WC:"8.2",XC:"9.2",YC:"11.1-11.2",ZC:"12.0",aC:"13.0",bC:"14.0",cC:"10.4",dC:"7.12",eC:"2.5"};


/***/ }),

/***/ 60257:
/***/ ((module) => {

module.exports={A:"ie",B:"edge",C:"firefox",D:"chrome",E:"safari",F:"opera",G:"ios_saf",H:"op_mini",I:"android",J:"bb",K:"op_mob",L:"and_chr",M:"and_ff",N:"ie_mob",O:"and_uc",P:"samsung",Q:"and_qq",R:"baidu",S:"kaios"};


/***/ }),

/***/ 28649:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports={"aac":__nccwpck_require__(22041),"abortcontroller":__nccwpck_require__(58633),"ac3-ec3":__nccwpck_require__(16821),"accelerometer":__nccwpck_require__(64181),"addeventlistener":__nccwpck_require__(31621),"alternate-stylesheet":__nccwpck_require__(18627),"ambient-light":__nccwpck_require__(12148),"apng":__nccwpck_require__(2312),"array-find-index":__nccwpck_require__(79271),"array-find":__nccwpck_require__(39299),"array-flat":__nccwpck_require__(38626),"array-includes":__nccwpck_require__(33189),"arrow-functions":__nccwpck_require__(72093),"asmjs":__nccwpck_require__(72303),"async-clipboard":__nccwpck_require__(40152),"async-functions":__nccwpck_require__(49000),"atob-btoa":__nccwpck_require__(37179),"audio-api":__nccwpck_require__(70873),"audio":__nccwpck_require__(6398),"audiotracks":__nccwpck_require__(77417),"autofocus":__nccwpck_require__(91333),"auxclick":__nccwpck_require__(638),"av1":__nccwpck_require__(14604),"avif":__nccwpck_require__(66762),"background-attachment":__nccwpck_require__(41394),"background-clip-text":__nccwpck_require__(13197),"background-img-opts":__nccwpck_require__(22115),"background-position-x-y":__nccwpck_require__(4414),"background-repeat-round-space":__nccwpck_require__(74678),"background-sync":__nccwpck_require__(99995),"battery-status":__nccwpck_require__(96576),"beacon":__nccwpck_require__(33903),"beforeafterprint":__nccwpck_require__(38484),"bigint":__nccwpck_require__(88210),"blobbuilder":__nccwpck_require__(43840),"bloburls":__nccwpck_require__(75394),"border-image":__nccwpck_require__(14915),"border-radius":__nccwpck_require__(72853),"broadcastchannel":__nccwpck_require__(35485),"brotli":__nccwpck_require__(67933),"calc":__nccwpck_require__(287),"canvas-blending":__nccwpck_require__(39321),"canvas-text":__nccwpck_require__(35888),"canvas":__nccwpck_require__(66710),"ch-unit":__nccwpck_require__(30814),"chacha20-poly1305":__nccwpck_require__(34099),"channel-messaging":__nccwpck_require__(610),"childnode-remove":__nccwpck_require__(40258),"classlist":__nccwpck_require__(33077),"client-hints-dpr-width-viewport":__nccwpck_require__(26164),"clipboard":__nccwpck_require__(28546),"colr":__nccwpck_require__(22303),"comparedocumentposition":__nccwpck_require__(2004),"console-basic":__nccwpck_require__(30695),"console-time":__nccwpck_require__(15498),"const":__nccwpck_require__(67727),"constraint-validation":__nccwpck_require__(92806),"contenteditable":__nccwpck_require__(46638),"contentsecuritypolicy":__nccwpck_require__(90370),"contentsecuritypolicy2":__nccwpck_require__(39564),"cookie-store-api":__nccwpck_require__(71369),"cors":__nccwpck_require__(96637),"createimagebitmap":__nccwpck_require__(25702),"credential-management":__nccwpck_require__(32011),"cryptography":__nccwpck_require__(91342),"css-all":__nccwpck_require__(55211),"css-animation":__nccwpck_require__(40083),"css-any-link":__nccwpck_require__(2031),"css-appearance":__nccwpck_require__(3599),"css-apply-rule":__nccwpck_require__(66395),"css-at-counter-style":__nccwpck_require__(2769),"css-backdrop-filter":__nccwpck_require__(74043),"css-background-offsets":__nccwpck_require__(29407),"css-backgroundblendmode":__nccwpck_require__(98732),"css-boxdecorationbreak":__nccwpck_require__(81371),"css-boxshadow":__nccwpck_require__(22004),"css-canvas":__nccwpck_require__(34651),"css-caret-color":__nccwpck_require__(3560),"css-case-insensitive":__nccwpck_require__(4497),"css-clip-path":__nccwpck_require__(37028),"css-color-adjust":__nccwpck_require__(75747),"css-color-function":__nccwpck_require__(4008),"css-conic-gradients":__nccwpck_require__(31811),"css-container-queries":__nccwpck_require__(61547),"css-containment":__nccwpck_require__(64484),"css-content-visibility":__nccwpck_require__(69511),"css-counters":__nccwpck_require__(11237),"css-crisp-edges":__nccwpck_require__(36717),"css-cross-fade":__nccwpck_require__(90831),"css-default-pseudo":__nccwpck_require__(99030),"css-descendant-gtgt":__nccwpck_require__(14942),"css-deviceadaptation":__nccwpck_require__(83318),"css-dir-pseudo":__nccwpck_require__(15902),"css-display-contents":__nccwpck_require__(45140),"css-element-function":__nccwpck_require__(21694),"css-env-function":__nccwpck_require__(21809),"css-exclusions":__nccwpck_require__(79991),"css-featurequeries":__nccwpck_require__(53231),"css-filter-function":__nccwpck_require__(19533),"css-filters":__nccwpck_require__(35123),"css-first-letter":__nccwpck_require__(95006),"css-first-line":__nccwpck_require__(34624),"css-fixed":__nccwpck_require__(4787),"css-focus-visible":__nccwpck_require__(59934),"css-focus-within":__nccwpck_require__(1620),"css-font-rendering-controls":__nccwpck_require__(80882),"css-font-stretch":__nccwpck_require__(6482),"css-gencontent":__nccwpck_require__(49718),"css-gradients":__nccwpck_require__(13657),"css-grid":__nccwpck_require__(19330),"css-hanging-punctuation":__nccwpck_require__(59804),"css-has":__nccwpck_require__(28790),"css-hyphenate":__nccwpck_require__(22889),"css-hyphens":__nccwpck_require__(89317),"css-image-orientation":__nccwpck_require__(38133),"css-image-set":__nccwpck_require__(2762),"css-in-out-of-range":__nccwpck_require__(88654),"css-indeterminate-pseudo":__nccwpck_require__(61436),"css-initial-letter":__nccwpck_require__(68010),"css-initial-value":__nccwpck_require__(52764),"css-letter-spacing":__nccwpck_require__(6661),"css-line-clamp":__nccwpck_require__(12931),"css-logical-props":__nccwpck_require__(23871),"css-marker-pseudo":__nccwpck_require__(35371),"css-masks":__nccwpck_require__(15592),"css-matches-pseudo":__nccwpck_require__(45820),"css-math-functions":__nccwpck_require__(15868),"css-media-interaction":__nccwpck_require__(22427),"css-media-resolution":__nccwpck_require__(79494),"css-media-scripting":__nccwpck_require__(78527),"css-mediaqueries":__nccwpck_require__(47055),"css-mixblendmode":__nccwpck_require__(93831),"css-motion-paths":__nccwpck_require__(46876),"css-namespaces":__nccwpck_require__(9028),"css-not-sel-list":__nccwpck_require__(92481),"css-nth-child-of":__nccwpck_require__(66492),"css-opacity":__nccwpck_require__(23375),"css-optional-pseudo":__nccwpck_require__(93492),"css-overflow-anchor":__nccwpck_require__(11721),"css-overflow-overlay":__nccwpck_require__(74065),"css-overflow":__nccwpck_require__(91764),"css-overscroll-behavior":__nccwpck_require__(50237),"css-page-break":__nccwpck_require__(88866),"css-paged-media":__nccwpck_require__(76098),"css-paint-api":__nccwpck_require__(10133),"css-placeholder-shown":__nccwpck_require__(70361),"css-placeholder":__nccwpck_require__(83448),"css-read-only-write":__nccwpck_require__(17667),"css-rebeccapurple":__nccwpck_require__(32723),"css-reflections":__nccwpck_require__(25056),"css-regions":__nccwpck_require__(32598),"css-repeating-gradients":__nccwpck_require__(62787),"css-resize":__nccwpck_require__(36660),"css-revert-value":__nccwpck_require__(47190),"css-rrggbbaa":__nccwpck_require__(87215),"css-scroll-behavior":__nccwpck_require__(58544),"css-scroll-timeline":__nccwpck_require__(52572),"css-scrollbar":__nccwpck_require__(37851),"css-sel2":__nccwpck_require__(92398),"css-sel3":__nccwpck_require__(40787),"css-selection":__nccwpck_require__(16302),"css-shapes":__nccwpck_require__(56938),"css-snappoints":__nccwpck_require__(82776),"css-sticky":__nccwpck_require__(67425),"css-subgrid":__nccwpck_require__(70836),"css-supports-api":__nccwpck_require__(43295),"css-table":__nccwpck_require__(57271),"css-text-align-last":__nccwpck_require__(68887),"css-text-indent":__nccwpck_require__(34715),"css-text-justify":__nccwpck_require__(83983),"css-text-orientation":__nccwpck_require__(80045),"css-text-spacing":__nccwpck_require__(75688),"css-textshadow":__nccwpck_require__(43548),"css-touch-action-2":__nccwpck_require__(62291),"css-touch-action":__nccwpck_require__(8517),"css-transitions":__nccwpck_require__(61964),"css-unicode-bidi":__nccwpck_require__(45257),"css-unset-value":__nccwpck_require__(50750),"css-variables":__nccwpck_require__(32973),"css-widows-orphans":__nccwpck_require__(47477),"css-writing-mode":__nccwpck_require__(47816),"css-zoom":__nccwpck_require__(26061),"css3-attr":__nccwpck_require__(26203),"css3-boxsizing":__nccwpck_require__(47610),"css3-colors":__nccwpck_require__(91578),"css3-cursors-grab":__nccwpck_require__(63355),"css3-cursors-newer":__nccwpck_require__(70800),"css3-cursors":__nccwpck_require__(73281),"css3-tabsize":__nccwpck_require__(87604),"currentcolor":__nccwpck_require__(66010),"custom-elements":__nccwpck_require__(89306),"custom-elementsv1":__nccwpck_require__(68426),"customevent":__nccwpck_require__(96529),"datalist":__nccwpck_require__(61338),"dataset":__nccwpck_require__(80410),"datauri":__nccwpck_require__(57593),"date-tolocaledatestring":__nccwpck_require__(57488),"details":__nccwpck_require__(55777),"deviceorientation":__nccwpck_require__(30111),"devicepixelratio":__nccwpck_require__(57084),"dialog":__nccwpck_require__(84530),"dispatchevent":__nccwpck_require__(63229),"dnssec":__nccwpck_require__(15381),"do-not-track":__nccwpck_require__(3481),"document-currentscript":__nccwpck_require__(88864),"document-evaluate-xpath":__nccwpck_require__(93781),"document-execcommand":__nccwpck_require__(24147),"document-policy":__nccwpck_require__(39985),"document-scrollingelement":__nccwpck_require__(55988),"documenthead":__nccwpck_require__(2001),"dom-manip-convenience":__nccwpck_require__(64198),"dom-range":__nccwpck_require__(3563),"domcontentloaded":__nccwpck_require__(38057),"domfocusin-domfocusout-events":__nccwpck_require__(54275),"dommatrix":__nccwpck_require__(31943),"download":__nccwpck_require__(49291),"dragndrop":__nccwpck_require__(625),"element-closest":__nccwpck_require__(54805),"element-from-point":__nccwpck_require__(25808),"element-scroll-methods":__nccwpck_require__(80674),"eme":__nccwpck_require__(21671),"eot":__nccwpck_require__(51180),"es5":__nccwpck_require__(62719),"es6-class":__nccwpck_require__(54682),"es6-generators":__nccwpck_require__(6483),"es6-module-dynamic-import":__nccwpck_require__(69972),"es6-module":__nccwpck_require__(33513),"es6-number":__nccwpck_require__(24785),"es6-string-includes":__nccwpck_require__(41908),"es6":__nccwpck_require__(76634),"eventsource":__nccwpck_require__(99513),"extended-system-fonts":__nccwpck_require__(29486),"feature-policy":__nccwpck_require__(6411),"fetch":__nccwpck_require__(80486),"fieldset-disabled":__nccwpck_require__(35953),"fileapi":__nccwpck_require__(61730),"filereader":__nccwpck_require__(92314),"filereadersync":__nccwpck_require__(80418),"filesystem":__nccwpck_require__(13394),"flac":__nccwpck_require__(37012),"flexbox-gap":__nccwpck_require__(2448),"flexbox":__nccwpck_require__(48976),"flow-root":__nccwpck_require__(37107),"focusin-focusout-events":__nccwpck_require__(3162),"focusoptions-preventscroll":__nccwpck_require__(9962),"font-family-system-ui":__nccwpck_require__(92562),"font-feature":__nccwpck_require__(26538),"font-kerning":__nccwpck_require__(88367),"font-loading":__nccwpck_require__(90792),"font-metrics-overrides":__nccwpck_require__(24934),"font-size-adjust":__nccwpck_require__(60647),"font-smooth":__nccwpck_require__(21936),"font-unicode-range":__nccwpck_require__(88108),"font-variant-alternates":__nccwpck_require__(90534),"font-variant-east-asian":__nccwpck_require__(35187),"font-variant-numeric":__nccwpck_require__(85199),"fontface":__nccwpck_require__(90829),"form-attribute":__nccwpck_require__(32662),"form-submit-attributes":__nccwpck_require__(37913),"form-validation":__nccwpck_require__(17644),"forms":__nccwpck_require__(68112),"fullscreen":__nccwpck_require__(99086),"gamepad":__nccwpck_require__(66952),"geolocation":__nccwpck_require__(64161),"getboundingclientrect":__nccwpck_require__(73165),"getcomputedstyle":__nccwpck_require__(43665),"getelementsbyclassname":__nccwpck_require__(85337),"getrandomvalues":__nccwpck_require__(26199),"gyroscope":__nccwpck_require__(49966),"hardwareconcurrency":__nccwpck_require__(89006),"hashchange":__nccwpck_require__(62563),"heif":__nccwpck_require__(56666),"hevc":__nccwpck_require__(64206),"hidden":__nccwpck_require__(6027),"high-resolution-time":__nccwpck_require__(88772),"history":__nccwpck_require__(81648),"html-media-capture":__nccwpck_require__(64940),"html5semantic":__nccwpck_require__(72753),"http-live-streaming":__nccwpck_require__(15638),"http2":__nccwpck_require__(16824),"http3":__nccwpck_require__(70549),"iframe-sandbox":__nccwpck_require__(76002),"iframe-seamless":__nccwpck_require__(82891),"iframe-srcdoc":__nccwpck_require__(72100),"imagecapture":__nccwpck_require__(16659),"ime":__nccwpck_require__(54606),"img-naturalwidth-naturalheight":__nccwpck_require__(35720),"import-maps":__nccwpck_require__(64548),"imports":__nccwpck_require__(72563),"indeterminate-checkbox":__nccwpck_require__(66518),"indexeddb":__nccwpck_require__(78797),"indexeddb2":__nccwpck_require__(11395),"inline-block":__nccwpck_require__(7354),"innertext":__nccwpck_require__(40674),"input-autocomplete-onoff":__nccwpck_require__(60328),"input-color":__nccwpck_require__(24411),"input-datetime":__nccwpck_require__(41858),"input-email-tel-url":__nccwpck_require__(65488),"input-event":__nccwpck_require__(56301),"input-file-accept":__nccwpck_require__(3024),"input-file-directory":__nccwpck_require__(77213),"input-file-multiple":__nccwpck_require__(64907),"input-inputmode":__nccwpck_require__(75178),"input-minlength":__nccwpck_require__(90453),"input-number":__nccwpck_require__(90754),"input-pattern":__nccwpck_require__(70620),"input-placeholder":__nccwpck_require__(45840),"input-range":__nccwpck_require__(19303),"input-search":__nccwpck_require__(86763),"input-selection":__nccwpck_require__(48804),"insert-adjacent":__nccwpck_require__(36404),"insertadjacenthtml":__nccwpck_require__(20379),"internationalization":__nccwpck_require__(558),"intersectionobserver-v2":__nccwpck_require__(16414),"intersectionobserver":__nccwpck_require__(93717),"intl-pluralrules":__nccwpck_require__(14130),"intrinsic-width":__nccwpck_require__(56835),"jpeg2000":__nccwpck_require__(99137),"jpegxl":__nccwpck_require__(58083),"jpegxr":__nccwpck_require__(70525),"js-regexp-lookbehind":__nccwpck_require__(91191),"json":__nccwpck_require__(92815),"justify-content-space-evenly":__nccwpck_require__(37001),"kerning-pairs-ligatures":__nccwpck_require__(82612),"keyboardevent-charcode":__nccwpck_require__(7891),"keyboardevent-code":__nccwpck_require__(39598),"keyboardevent-getmodifierstate":__nccwpck_require__(87626),"keyboardevent-key":__nccwpck_require__(98685),"keyboardevent-location":__nccwpck_require__(90035),"keyboardevent-which":__nccwpck_require__(82586),"lazyload":__nccwpck_require__(23230),"let":__nccwpck_require__(51884),"link-icon-png":__nccwpck_require__(42789),"link-icon-svg":__nccwpck_require__(4506),"link-rel-dns-prefetch":__nccwpck_require__(66458),"link-rel-modulepreload":__nccwpck_require__(36767),"link-rel-preconnect":__nccwpck_require__(67578),"link-rel-prefetch":__nccwpck_require__(31145),"link-rel-preload":__nccwpck_require__(7015),"link-rel-prerender":__nccwpck_require__(74778),"loading-lazy-attr":__nccwpck_require__(11394),"localecompare":__nccwpck_require__(89380),"magnetometer":__nccwpck_require__(19271),"matchesselector":__nccwpck_require__(71184),"matchmedia":__nccwpck_require__(66743),"mathml":__nccwpck_require__(35717),"maxlength":__nccwpck_require__(16924),"media-attribute":__nccwpck_require__(23924),"media-fragments":__nccwpck_require__(6277),"media-session-api":__nccwpck_require__(94413),"mediacapture-fromelement":__nccwpck_require__(84279),"mediarecorder":__nccwpck_require__(55997),"mediasource":__nccwpck_require__(32348),"menu":__nccwpck_require__(89056),"meta-theme-color":__nccwpck_require__(69895),"meter":__nccwpck_require__(44701),"midi":__nccwpck_require__(83250),"minmaxwh":__nccwpck_require__(55879),"mp3":__nccwpck_require__(59447),"mpeg-dash":__nccwpck_require__(374),"mpeg4":__nccwpck_require__(33463),"multibackgrounds":__nccwpck_require__(19069),"multicolumn":__nccwpck_require__(24233),"mutation-events":__nccwpck_require__(90072),"mutationobserver":__nccwpck_require__(98212),"namevalue-storage":__nccwpck_require__(80611),"native-filesystem-api":__nccwpck_require__(7576),"nav-timing":__nccwpck_require__(73272),"navigator-language":__nccwpck_require__(56212),"netinfo":__nccwpck_require__(1493),"notifications":__nccwpck_require__(54483),"object-entries":__nccwpck_require__(69577),"object-fit":__nccwpck_require__(6228),"object-observe":__nccwpck_require__(63008),"object-values":__nccwpck_require__(55480),"objectrtc":__nccwpck_require__(39611),"offline-apps":__nccwpck_require__(45884),"offscreencanvas":__nccwpck_require__(74509),"ogg-vorbis":__nccwpck_require__(77081),"ogv":__nccwpck_require__(18398),"ol-reversed":__nccwpck_require__(67096),"once-event-listener":__nccwpck_require__(79713),"online-status":__nccwpck_require__(11219),"opus":__nccwpck_require__(12205),"orientation-sensor":__nccwpck_require__(77294),"outline":__nccwpck_require__(28311),"pad-start-end":__nccwpck_require__(42502),"page-transition-events":__nccwpck_require__(72796),"pagevisibility":__nccwpck_require__(87772),"passive-event-listener":__nccwpck_require__(50754),"passwordrules":__nccwpck_require__(28403),"path2d":__nccwpck_require__(13066),"payment-request":__nccwpck_require__(36954),"pdf-viewer":__nccwpck_require__(31504),"permissions-api":__nccwpck_require__(98901),"permissions-policy":__nccwpck_require__(17093),"picture-in-picture":__nccwpck_require__(2610),"picture":__nccwpck_require__(85312),"ping":__nccwpck_require__(96744),"png-alpha":__nccwpck_require__(54659),"pointer-events":__nccwpck_require__(2224),"pointer":__nccwpck_require__(27252),"pointerlock":__nccwpck_require__(50221),"portals":__nccwpck_require__(72388),"prefers-color-scheme":__nccwpck_require__(93412),"prefers-reduced-motion":__nccwpck_require__(21506),"private-class-fields":__nccwpck_require__(2344),"private-methods-and-accessors":__nccwpck_require__(46300),"progress":__nccwpck_require__(31127),"promise-finally":__nccwpck_require__(22438),"promises":__nccwpck_require__(26044),"proximity":__nccwpck_require__(93871),"proxy":__nccwpck_require__(88321),"public-class-fields":__nccwpck_require__(94312),"publickeypinning":__nccwpck_require__(29636),"push-api":__nccwpck_require__(39446),"queryselector":__nccwpck_require__(78361),"readonly-attr":__nccwpck_require__(21513),"referrer-policy":__nccwpck_require__(68504),"registerprotocolhandler":__nccwpck_require__(35575),"rel-noopener":__nccwpck_require__(67634),"rel-noreferrer":__nccwpck_require__(53615),"rellist":__nccwpck_require__(40764),"rem":__nccwpck_require__(49123),"requestanimationframe":__nccwpck_require__(10380),"requestidlecallback":__nccwpck_require__(28670),"resizeobserver":__nccwpck_require__(21994),"resource-timing":__nccwpck_require__(28286),"rest-parameters":__nccwpck_require__(42459),"rtcpeerconnection":__nccwpck_require__(17936),"ruby":__nccwpck_require__(35921),"run-in":__nccwpck_require__(88365),"same-site-cookie-attribute":__nccwpck_require__(87529),"screen-orientation":__nccwpck_require__(22474),"script-async":__nccwpck_require__(1522),"script-defer":__nccwpck_require__(13440),"scrollintoview":__nccwpck_require__(39781),"scrollintoviewifneeded":__nccwpck_require__(12228),"sdch":__nccwpck_require__(52531),"selection-api":__nccwpck_require__(60612),"server-timing":__nccwpck_require__(6978),"serviceworkers":__nccwpck_require__(65958),"setimmediate":__nccwpck_require__(87394),"sha-2":__nccwpck_require__(83083),"shadowdom":__nccwpck_require__(29657),"shadowdomv1":__nccwpck_require__(32860),"sharedarraybuffer":__nccwpck_require__(71306),"sharedworkers":__nccwpck_require__(42568),"sni":__nccwpck_require__(18689),"spdy":__nccwpck_require__(35867),"speech-recognition":__nccwpck_require__(7773),"speech-synthesis":__nccwpck_require__(38623),"spellcheck-attribute":__nccwpck_require__(79418),"sql-storage":__nccwpck_require__(88502),"srcset":__nccwpck_require__(31740),"stream":__nccwpck_require__(83192),"streams":__nccwpck_require__(54664),"stricttransportsecurity":__nccwpck_require__(24046),"style-scoped":__nccwpck_require__(39846),"subresource-integrity":__nccwpck_require__(50847),"svg-css":__nccwpck_require__(52279),"svg-filters":__nccwpck_require__(24682),"svg-fonts":__nccwpck_require__(18443),"svg-fragment":__nccwpck_require__(32036),"svg-html":__nccwpck_require__(18617),"svg-html5":__nccwpck_require__(94098),"svg-img":__nccwpck_require__(86703),"svg-smil":__nccwpck_require__(91827),"svg":__nccwpck_require__(44087),"sxg":__nccwpck_require__(12832),"tabindex-attr":__nccwpck_require__(40960),"template-literals":__nccwpck_require__(7507),"template":__nccwpck_require__(52873),"temporal":__nccwpck_require__(85105),"testfeat":__nccwpck_require__(40831),"text-decoration":__nccwpck_require__(6866),"text-emphasis":__nccwpck_require__(76001),"text-overflow":__nccwpck_require__(73033),"text-size-adjust":__nccwpck_require__(2368),"text-stroke":__nccwpck_require__(10481),"text-underline-offset":__nccwpck_require__(13785),"textcontent":__nccwpck_require__(2846),"textencoder":__nccwpck_require__(96073),"tls1-1":__nccwpck_require__(76376),"tls1-2":__nccwpck_require__(99062),"tls1-3":__nccwpck_require__(5423),"token-binding":__nccwpck_require__(51858),"touch":__nccwpck_require__(61653),"transforms2d":__nccwpck_require__(98415),"transforms3d":__nccwpck_require__(48912),"trusted-types":__nccwpck_require__(58552),"ttf":__nccwpck_require__(23126),"typedarrays":__nccwpck_require__(71426),"u2f":__nccwpck_require__(61405),"unhandledrejection":__nccwpck_require__(43287),"upgradeinsecurerequests":__nccwpck_require__(97798),"url-scroll-to-text-fragment":__nccwpck_require__(52411),"url":__nccwpck_require__(80081),"urlsearchparams":__nccwpck_require__(17586),"use-strict":__nccwpck_require__(33500),"user-select-none":__nccwpck_require__(85671),"user-timing":__nccwpck_require__(98345),"variable-fonts":__nccwpck_require__(56153),"vector-effect":__nccwpck_require__(18563),"vibration":__nccwpck_require__(78480),"video":__nccwpck_require__(69345),"videotracks":__nccwpck_require__(32495),"viewport-units":__nccwpck_require__(23396),"wai-aria":__nccwpck_require__(32102),"wake-lock":__nccwpck_require__(44534),"wasm":__nccwpck_require__(95495),"wav":__nccwpck_require__(22174),"wbr-element":__nccwpck_require__(91075),"web-animation":__nccwpck_require__(17713),"web-app-manifest":__nccwpck_require__(48215),"web-bluetooth":__nccwpck_require__(46475),"web-serial":__nccwpck_require__(86902),"web-share":__nccwpck_require__(1574),"webauthn":__nccwpck_require__(8423),"webgl":__nccwpck_require__(34889),"webgl2":__nccwpck_require__(75593),"webgpu":__nccwpck_require__(98935),"webhid":__nccwpck_require__(51706),"webkit-user-drag":__nccwpck_require__(27580),"webm":__nccwpck_require__(19936),"webnfc":__nccwpck_require__(57179),"webp":__nccwpck_require__(95001),"websockets":__nccwpck_require__(9648),"webusb":__nccwpck_require__(75310),"webvr":__nccwpck_require__(28335),"webvtt":__nccwpck_require__(53707),"webworkers":__nccwpck_require__(82501),"webxr":__nccwpck_require__(85515),"will-change":__nccwpck_require__(70441),"woff":__nccwpck_require__(15216),"woff2":__nccwpck_require__(92249),"word-break":__nccwpck_require__(72383),"wordwrap":__nccwpck_require__(40133),"x-doc-messaging":__nccwpck_require__(3334),"x-frame-options":__nccwpck_require__(52711),"xhr2":__nccwpck_require__(94381),"xhtml":__nccwpck_require__(92605),"xhtmlsmil":__nccwpck_require__(7278),"xml-serializer":__nccwpck_require__(12227)};


/***/ }),

/***/ 22041:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f lB mB","132":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F","16":"A B"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"2":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"132":"P"},N:{"1":"A","2":"B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"132":"eC"}},B:6,C:"AAC audio file format"};


/***/ }),

/***/ 58633:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"M N O R S T U V W X Y Z a P b H","2":"C K L G"},C:{"1":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB lB mB"},D:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB"},E:{"1":"K L G ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB","130":"C YB"},F:{"1":"BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB xB yB zB 0B YB gB 1B ZB"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"XC fB YC ZC aC bC","2":"I TC UC VC WC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"AbortController & AbortSignal"};


/***/ }),

/***/ 16821:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O","2":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B","132":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D","132":"A"},K:{"2":"A B C Q YB gB","132":"ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"132":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"AC-3 (Dolby Digital) and EC-3 (Dolby Digital Plus) codecs"};


/***/ }),

/***/ 64181:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB","194":"GB bB HB cB IB JB Q KB LB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"Accelerometer"};


/***/ }),

/***/ 31621:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","130":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","257":"jB aB I c J lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"EventTarget.addEventListener()"};


/***/ }),

/***/ 18627:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"J D iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"F B C xB yB zB 0B YB gB 1B ZB","16":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"16":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"2":"Q","16":"A B C YB gB ZB"},L:{"16":"H"},M:{"16":"P"},N:{"16":"A B"},O:{"16":"SC"},P:{"16":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"16":"dC"},S:{"1":"eC"}},B:1,C:"Alternate stylesheet"};


/***/ }),

/***/ 12148:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K","132":"L G M N O","322":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f lB mB","132":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB","194":"HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB","322":"GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB xB yB zB 0B YB gB 1B ZB","322":"SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"132":"eC"}},B:4,C:"Ambient Light Sensor"};


/***/ }),

/***/ 2312:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB"},D:{"1":"bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB"},E:{"1":"E F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D pB eB qB rB sB"},F:{"1":"4 5 6 7 8 9 B C AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"0 1 2 3 F G M N O d e f g h i j k l m n o p q r s t u v w x y z"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","2":"I TC UC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:7,C:"Animated PNG (APNG)"};


/***/ }),

/***/ 79271:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i lB mB"},D:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J D pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D","16":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Array.prototype.findIndex"};


/***/ }),

/***/ 39299:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"G M N O R S T U V W X Y Z a P b H","16":"C K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i lB mB"},D:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J D pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D","16":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Array.prototype.find"};


/***/ }),

/***/ 38626:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB lB mB"},D:{"1":"OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB"},E:{"1":"C K L G ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB YB"},F:{"1":"EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB xB yB zB 0B YB gB 1B ZB"},G:{"1":"DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"fB YC ZC aC bC","2":"I TC UC VC WC XC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"flat & flatMap array methods"};


/***/ }),

/***/ 33189:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","2":"C K"},C:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Array.prototype.includes"};


/***/ }),

/***/ 72093:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f lB mB"},D:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Arrow functions"};


/***/ }),

/***/ 72303:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O","132":"R S T U V W X Y Z a P b H","322":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f lB mB"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i j k l","132":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","132":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","132":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","132":"Q"},L:{"132":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I","132":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"132":"cC"},R:{"132":"dC"},S:{"1":"eC"}},B:6,C:"asm.js"};


/***/ }),

/***/ 40152:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB lB mB","132":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB","66":"GB bB HB cB"},E:{"1":"L G uB vB wB","2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB"},F:{"1":"7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC","260":"JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","260":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","260":"Q"},L:{"1":"H"},M:{"132":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC","260":"XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"Asynchronous Clipboard API"};


/***/ }),

/***/ 49000:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"G M N O R S T U V W X Y Z a P b H","2":"C K","194":"L"},C:{"1":"AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB","514":"fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B","514":"AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I TC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"Async functions"};


/***/ }),

/***/ 37179:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 0B YB gB 1B ZB","2":"F xB yB","16":"zB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","16":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Base64 encoding and decoding"};


/***/ }),

/***/ 70873:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K","33":"L G M N O d e f g h i j k l m n o p q r"},E:{"1":"G vB wB","2":"I c pB eB qB","33":"J D E F A B C K L rB sB tB fB YB ZB uB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","33":"G M N O d e f"},G:{"1":"KC","2":"eB 2B hB 3B","33":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"Web Audio API"};


/***/ }),

/***/ 6398:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","132":"I c J D E F A B C K L G M N O d lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F","4":"xB yB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","2":"MC NC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Audio element"};


/***/ }),

/***/ 77417:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O","322":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q lB mB","194":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"0 1 2 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","322":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p xB yB zB 0B YB gB 1B ZB","322":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"322":"H"},M:{"2":"P"},N:{"1":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"194":"eC"}},B:1,C:"Audio Tracks"};


/***/ }),

/***/ 91333:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"2":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:1,C:"Autofocus attribute"};


/***/ }),

/***/ 638:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB lB mB","129":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"Auxclick"};


/***/ }),

/***/ 14604:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N","194":"O"},C:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB lB mB","66":"DB EB FB GB bB HB cB IB JB Q","260":"KB","516":"LB"},D:{"1":"PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB","66":"MB NB OB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1090":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"ZC aC bC","2":"I TC UC VC WC XC fB YC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"AV1 video format"};


/***/ }),

/***/ 66762:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB lB mB","194":"WB XB R S T kB U V W X Y Z a P b"},D:{"1":"W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"194":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"bC","2":"I TC UC VC WC XC fB YC ZC aC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"AVIF image format"};


/***/ }),

/***/ 41394:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","132":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","132":"jB aB I c J D E F A B C K L G M N O d e f g h i lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J D E F A B C qB rB sB tB fB YB ZB","132":"I K pB eB uB","2050":"L G vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","132":"F xB yB"},G:{"2":"eB 2B hB","772":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC","2050":"FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC QC RC","132":"PC hB"},J:{"260":"D A"},K:{"1":"B C YB gB ZB","2":"Q","132":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"2":"I","1028":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1028":"dC"},S:{"1":"eC"}},B:4,C:"CSS background-attachment"};


/***/ }),

/***/ 13197:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"G M N O","33":"C K L R S T U V W X Y Z a P b H"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"33":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"16":"pB eB","33":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","33":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"16":"eB 2B hB 3B","33":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"16":"aB MC NC OC","33":"I H PC hB QC RC"},J:{"33":"D A"},K:{"16":"A B C YB gB ZB","33":"Q"},L:{"33":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"33":"SC"},P:{"33":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"33":"cC"},R:{"33":"dC"},S:{"1":"eC"}},B:7,C:"Background-clip: text"};


/***/ }),

/***/ 22115:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB","36":"mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","516":"I c J D E F A B C K L"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","772":"I c J pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB","36":"yB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","4":"eB 2B hB 4B","516":"3B"},H:{"132":"LC"},I:{"1":"H QC RC","36":"MC","516":"aB I PC hB","548":"NC OC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS3 Background-image options"};


/***/ }),

/***/ 4414:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:7,C:"background-position-x & background-position-y"};


/***/ }),

/***/ 74678:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E iB","132":"F"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F G M N O xB yB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:4,C:"CSS background-repeat round and space"};


/***/ }),

/***/ 99995:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b lB mB","16":"H dB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Background Sync API"};


/***/ }),

/***/ 96576:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"1 2 3 4 5 6 7 8 9","2":"jB aB I c J D E F AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","132":"0 M N O d e f g h i j k l m n o p q r s t u v w x y z","164":"A B C K L G"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u","66":"v"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"Battery Status API"};


/***/ }),

/***/ 33903:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","2":"C K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j xB yB zB 0B YB gB 1B ZB"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"Beacon API"};


/***/ }),

/***/ 38484:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c lB mB"},D:{"1":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"16":"A B"},O:{"16":"SC"},P:{"2":"TC UC VC WC XC fB YC ZC aC bC","16":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:1,C:"Printing Events"};


/***/ }),

/***/ 88210:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q lB mB","194":"KB LB MB"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB"},E:{"1":"L G vB wB","2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB uB"},F:{"1":"CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB xB yB zB 0B YB gB 1B ZB"},G:{"1":"JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"XC fB YC ZC aC bC","2":"I TC UC VC WC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"BigInt"};


/***/ }),

/***/ 43840:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c lB mB","36":"J D E F A B C"},D:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D","36":"E F A B C K L G M N O d"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B C xB yB zB 0B YB gB 1B"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B"},H:{"2":"LC"},I:{"1":"H","2":"MC NC OC","36":"aB I PC hB QC RC"},J:{"1":"A","2":"D"},K:{"1":"Q ZB","2":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"Blob constructing"};


/***/ }),

/***/ 75394:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","129":"A B"},B:{"1":"G M N O R S T U V W X Y Z a P b H","129":"C K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D","33":"E F A B C K L G M N O d e f g"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB","33":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B","33":"4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB MC NC OC","33":"I PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"Blob URLs"};


/***/ }),

/***/ 14915:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","129":"C K"},C:{"1":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","260":"0 1 2 3 4 5 6 7 G M N O d e f g h i j k l m n o p q r s t u v w x y z","804":"I c J D E F A B C K L lB mB"},D:{"1":"EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","260":"9 AB BB CB DB","388":"0 1 2 3 4 5 6 7 8 o p q r s t u v w x y z","1412":"G M N O d e f g h i j k l m n","1956":"I c J D E F A B C K L"},E:{"129":"A B C K L G tB fB YB ZB uB vB wB","1412":"J D E F rB sB","1956":"I c pB eB qB"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F xB yB","260":"0 w x y z","388":"G M N O d e f g h i j k l m n o p q r s t u v","1796":"zB 0B","1828":"B C YB gB 1B ZB"},G:{"129":"8B 9B AC BC CC DC EC FC GC HC IC JC KC","1412":"E 4B 5B 6B 7B","1956":"eB 2B hB 3B"},H:{"1828":"LC"},I:{"1":"H","388":"QC RC","1956":"aB I MC NC OC PC hB"},J:{"1412":"A","1924":"D"},K:{"1":"Q","2":"A","1828":"B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"388":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","260":"TC UC","388":"I"},Q:{"260":"cC"},R:{"260":"dC"},S:{"260":"eC"}},B:4,C:"CSS3 Border images"};


/***/ }),

/***/ 72853:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","257":"0 1 2 3 4 5 6 7 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","289":"aB lB mB","292":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"I"},E:{"1":"c D E F A B C K L G sB tB fB YB ZB uB vB wB","33":"I pB eB","129":"J qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","33":"eB"},H:{"2":"LC"},I:{"1":"aB I H NC OC PC hB QC RC","33":"MC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"257":"eC"}},B:4,C:"CSS3 Border-radius (rounded corners)"};


/***/ }),

/***/ 35485:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v lB mB"},D:{"1":"CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","2":"I TC UC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:1,C:"BroadcastChannel"};


/***/ }),

/***/ 67933:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"G M N O R S T U V W X Y Z a P b H","2":"C K L"},C:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"7","257":"8"},E:{"1":"K L G uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB","513":"B C YB ZB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t xB yB zB 0B YB gB 1B ZB","194":"u v"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:6,C:"Brotli Accept-Encoding/Content-Encoding"};


/***/ }),

/***/ 287:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","260":"F","516":"A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","33":"I c J D E F A B C K L G"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O","33":"d e f g h i j"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB","33":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B","33":"4B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB","132":"QC RC"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"calc() as CSS unit value"};


/***/ }),

/***/ 39321:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"Canvas blend modes"};


/***/ }),

/***/ 35888:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"iB","8":"J D E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","8":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","8":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","8":"F xB yB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","8":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Text API for Canvas"};


/***/ }),

/***/ 66710:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"iB","8":"J D E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB mB","132":"jB aB lB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","132":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"260":"LC"},I:{"1":"aB I H PC hB QC RC","132":"MC NC OC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Canvas (basic support)"};


/***/ }),

/***/ 30814:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","132":"F A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"ch (character) unit"};


/***/ }),

/***/ 34099:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q","129":"0 1 2 3 4 5 6 r s t u v w x y z"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t xB yB zB 0B YB gB 1B ZB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC","16":"RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"ChaCha20-Poly1305 cipher suites for TLS"};


/***/ }),

/***/ 610:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j lB mB","194":"k l m n o p q r s t u v w x y"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 0B YB gB 1B ZB","2":"F xB yB","16":"zB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Channel messaging"};


/***/ }),

/***/ 40258:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","16":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB","16":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"ChildNode.remove()"};


/***/ }),

/***/ 33077:
/***/ ((module) => {

module.exports={A:{A:{"8":"J D E F iB","1924":"A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","8":"jB aB lB","516":"i j","772":"I c J D E F A B C K L G M N O d e f g h mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","8":"I c J D","516":"i j k l","772":"h","900":"E F A B C K L G M N O d e f g"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","8":"I c pB eB","900":"J qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","8":"F B xB yB zB 0B YB","900":"C gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","8":"eB 2B hB","900":"3B 4B"},H:{"900":"LC"},I:{"1":"H QC RC","8":"MC NC OC","900":"aB I PC hB"},J:{"1":"A","900":"D"},K:{"1":"Q","8":"A B","900":"C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"900":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"classList (DOMTokenList)"};


/***/ }),

/***/ 26164:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"2":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:6,C:"Client Hints: DPR, Width, Viewport-Width"};


/***/ }),

/***/ 28546:
/***/ ((module) => {

module.exports={A:{A:{"2436":"J D E F A B iB"},B:{"260":"N O","2436":"C K L G M","8196":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f lB mB","772":"g h i j k l m n o p q r s t u v w x y","4100":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"I c J D E F A B C","2564":"0 K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","8196":"GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","10244":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB"},E:{"1":"C K L G ZB uB vB wB","16":"pB eB","2308":"A B fB YB","2820":"I c J D E F qB rB sB tB"},F:{"2":"F B xB yB zB 0B YB gB 1B","16":"C","516":"ZB","2564":"G M N O d e f g h i j k l m n","8196":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","10244":"0 1 2 o p q r s t u v w x y z"},G:{"1":"DC EC FC GC HC IC JC KC","2":"eB 2B hB","2820":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","260":"H","2308":"QC RC"},J:{"2":"D","2308":"A"},K:{"2":"A B C YB gB","16":"ZB","260":"Q"},L:{"8196":"H"},M:{"1028":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2052":"TC UC","2308":"I","8196":"VC WC XC fB YC ZC aC bC"},Q:{"10244":"cC"},R:{"2052":"dC"},S:{"4100":"eC"}},B:5,C:"Synchronous Clipboard API"};


/***/ }),

/***/ 22303:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","257":"F A B"},B:{"1":"C K L G M N O","513":"R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB","513":"QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"L G vB wB","2":"I c J D E F A pB eB qB rB sB tB fB","129":"B C K YB ZB uB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB xB yB zB 0B YB gB 1B ZB","513":"GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"16":"A B"},O:{"1":"SC"},P:{"1":"fB YC ZC aC bC","2":"I TC UC VC WC XC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"COLR/CPAL(v0) Font Formats"};


/***/ }),

/***/ 2004:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","16":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L","132":"G M N O d e f g h i j k l m n"},E:{"1":"A B C K L G fB YB ZB uB vB wB","16":"I c J pB eB","132":"D E F rB sB tB","260":"qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","16":"F B xB yB zB 0B YB gB","132":"G M"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB","132":"E 2B hB 3B 4B 5B 6B 7B 8B"},H:{"1":"LC"},I:{"1":"H QC RC","16":"MC NC","132":"aB I OC PC hB"},J:{"132":"D A"},K:{"1":"C Q ZB","16":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Node.compareDocumentPosition()"};


/***/ }),

/***/ 30695:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D iB","132":"E F"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","2":"F xB yB zB 0B"},G:{"1":"eB 2B hB 3B","513":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"4097":"LC"},I:{"1025":"aB I H MC NC OC PC hB QC RC"},J:{"258":"D A"},K:{"2":"A","258":"B C YB gB ZB","1025":"Q"},L:{"1025":"H"},M:{"2049":"P"},N:{"258":"A B"},O:{"258":"SC"},P:{"1025":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1025":"dC"},S:{"1":"eC"}},B:1,C:"Basic console logging functions"};


/***/ }),

/***/ 15498:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","2":"F xB yB zB 0B","16":"B"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"Q","16":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"console.time and console.timeEnd"};


/***/ }),

/***/ 67727:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","2052":"B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","132":"jB aB I c J D E F A B C lB mB","260":"K L G M N O d e f g h i j k l m n o p q r s t"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","260":"I c J D E F A B C K L G M N O d e","772":"f g h i j k l m n o p q r s t u v w x y","1028":"0 1 2 3 4 5 6 z"},E:{"1":"B C K L G YB ZB uB vB wB","260":"I c A pB eB fB","772":"J D E F qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F xB","132":"B yB zB 0B YB gB","644":"C 1B ZB","772":"G M N O d e f g h i j k l","1028":"m n o p q r s t"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","260":"eB 2B hB 9B AC","772":"E 3B 4B 5B 6B 7B 8B"},H:{"644":"LC"},I:{"1":"H","16":"MC NC","260":"OC","772":"aB I PC hB QC RC"},J:{"772":"D A"},K:{"1":"Q","132":"A B YB gB","644":"C ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","1028":"I"},Q:{"1":"cC"},R:{"1028":"dC"},S:{"1":"eC"}},B:6,C:"const"};


/***/ }),

/***/ 92806:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","900":"A B"},B:{"1":"N O R S T U V W X Y Z a P b H","388":"L G M","900":"C K"},C:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","260":"7 8","388":"0 1 2 3 4 5 6 n o p q r s t u v w x y z","900":"I c J D E F A B C K L G M N O d e f g h i j k l m"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L","388":"j k l m n o p q r s t u v w x","900":"G M N O d e f g h i"},E:{"1":"A B C K L G fB YB ZB uB vB wB","16":"I c pB eB","388":"E F sB tB","900":"J D qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F B xB yB zB 0B YB gB","388":"G M N O d e f g h i j k","900":"C 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB","388":"E 5B 6B 7B 8B","900":"3B 4B"},H:{"2":"LC"},I:{"1":"H","16":"aB MC NC OC","388":"QC RC","900":"I PC hB"},J:{"16":"D","388":"A"},K:{"1":"Q","16":"A B YB gB","900":"C ZB"},L:{"1":"H"},M:{"1":"P"},N:{"900":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"388":"eC"}},B:1,C:"Constraint Validation API"};


/***/ }),

/***/ 46638:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB","4":"aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"2":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"D A"},K:{"1":"Q ZB","2":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"contenteditable attribute (basic support)"};


/***/ }),

/***/ 90370:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","132":"A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","129":"I c J D E F A B C K L G M N O d e f g"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K","257":"L G M N O d e f g h i"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c pB eB","257":"J rB","260":"qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB","257":"4B","260":"3B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D","257":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"257":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"Content Security Policy 1.0"};


/***/ }),

/***/ 39564:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L","32772":"G M N O"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o lB mB","132":"p q r s","260":"t","516":"0 1 2 u v w x y z","8196":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t","1028":"u v w","2052":"x"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g xB yB zB 0B YB gB 1B ZB","1028":"h i j","2052":"k"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"4100":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"8196":"eC"}},B:2,C:"Content Security Policy Level 2"};


/***/ }),

/***/ 71369:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"Y Z a P b H","2":"C K L G M N O","194":"R S T U V W X"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB","194":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","194":"9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"bC","2":"I TC UC VC WC XC fB YC ZC aC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Cookie Store API"};


/***/ }),

/***/ 96637:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D iB","132":"A","260":"E F"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB","1025":"cB IB JB Q KB LB MB NB OB PB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c J D E F A B C"},E:{"2":"pB eB","513":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","644":"I c qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B YB gB 1B"},G:{"513":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","644":"eB 2B hB 3B"},H:{"2":"LC"},I:{"1":"H QC RC","132":"aB I MC NC OC PC hB"},J:{"1":"A","132":"D"},K:{"1":"C Q ZB","2":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","132":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Cross-Origin Resource Sharing"};


/***/ }),

/***/ 25702:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","3076":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","132":"8 9","260":"AB BB","516":"CB DB EB FB GB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u xB yB zB 0B YB gB 1B ZB","132":"v w","260":"x y","516":"0 1 2 3 z"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"3076":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","16":"I TC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"3076":"eC"}},B:1,C:"createImageBitmap"};


/***/ }),

/***/ 32011:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","66":"6 7 8","129":"9 AB BB CB DB EB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","2":"I TC UC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"Credential Management API"};


/***/ }),

/***/ 91342:
/***/ ((module) => {

module.exports={A:{A:{"2":"iB","8":"J D E F A","164":"B"},B:{"1":"R S T U V W X Y Z a P b H","513":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","8":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p lB mB","66":"q r"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","8":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u"},E:{"1":"B C K L G YB ZB uB vB wB","8":"I c J D pB eB qB rB","289":"E F A sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","8":"F B C G M N O d e f g h xB yB zB 0B YB gB 1B ZB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","8":"eB 2B hB 3B 4B 5B","289":"E 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","8":"aB I MC NC OC PC hB QC RC"},J:{"8":"D A"},K:{"1":"Q","8":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"8":"A","164":"B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"Web Cryptography"};


/***/ }),

/***/ 55211:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h xB yB zB 0B YB gB 1B ZB"},G:{"1":"8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B"},H:{"2":"LC"},I:{"1":"H RC","2":"aB I MC NC OC PC hB QC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS all property"};


/***/ }),

/***/ 40083:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I lB mB","33":"c J D E F A B C K L G"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"0 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"pB eB","33":"J D E qB rB sB","292":"I c"},F:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B YB gB 1B","33":"C G M N O d e f g h i j k l m n"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","33":"E 4B 5B 6B","164":"eB 2B hB 3B"},H:{"2":"LC"},I:{"1":"H","33":"I PC hB QC RC","164":"aB MC NC OC"},J:{"33":"D A"},K:{"1":"Q ZB","2":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"33":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"CSS Animation"};


/***/ }),

/***/ 2031:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","16":"jB","33":"0 1 2 3 4 5 6 7 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L","33":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","16":"I c J pB eB qB","33":"D E rB sB"},F:{"1":"AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","33":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB 3B","33":"E 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","16":"aB I MC NC OC PC hB","33":"QC RC"},J:{"16":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"33":"SC"},P:{"1":"XC fB YC ZC aC bC","16":"I","33":"TC UC VC WC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"33":"eC"}},B:5,C:"CSS :any-link selector"};


/***/ }),

/***/ 3599:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"V W X Y Z a P b H","33":"U","164":"R S T","388":"C K L G M N O"},C:{"1":"S T kB U V W X Y Z a P b H dB","164":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R","676":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s lB mB"},D:{"1":"V W X Y Z a P b H dB nB oB","33":"U","164":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T"},E:{"164":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","33":"PB QB RB","164":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB"},G:{"164":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","164":"aB I MC NC OC PC hB QC RC"},J:{"164":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A","388":"B"},O:{"164":"SC"},P:{"164":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"164":"cC"},R:{"164":"dC"},S:{"164":"eC"}},B:5,C:"CSS Appearance"};


/***/ }),

/***/ 66395:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","194":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p q r s t u v xB yB zB 0B YB gB 1B ZB","194":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"194":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I","194":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"194":"dC"},S:{"2":"eC"}},B:7,C:"CSS @apply rule"};


/***/ }),

/***/ 2769:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P","132":"b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q lB mB","132":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P","132":"b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB xB yB zB 0B YB gB 1B ZB","132":"WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","132":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","132":"Q"},L:{"132":"H"},M:{"132":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"132":"eC"}},B:4,C:"CSS Counter Styles"};


/***/ }),

/***/ 74043:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M","257":"N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB lB mB","578":"PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB"},E:{"2":"I c J D E pB eB qB rB sB","33":"F A B C K L G tB fB YB ZB uB vB wB"},F:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r xB yB zB 0B YB gB 1B ZB","194":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB HB IB JB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B","33":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"578":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"ZC aC bC","2":"I","194":"TC UC VC WC XC fB YC"},Q:{"194":"cC"},R:{"194":"dC"},S:{"2":"eC"}},B:7,C:"CSS Backdrop Filter"};


/***/ }),

/***/ 29407:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS background-position edge offsets"};


/***/ }),

/***/ 98732:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n lB mB"},D:{"1":"0 1 2 3 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s","260":"4"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D pB eB qB rB","132":"E F A sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f xB yB zB 0B YB gB 1B ZB","260":"r"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B","132":"E 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS background-blend-mode"};


/***/ }),

/***/ 81371:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","164":"R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p lB mB"},D:{"2":"I c J D E F A B C K L G M N O d e f","164":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J pB eB qB","164":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB"},F:{"2":"F xB yB zB 0B","129":"B C YB gB 1B ZB","164":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"eB 2B hB 3B 4B","164":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"132":"LC"},I:{"2":"aB I MC NC OC PC hB","164":"H QC RC"},J:{"2":"D","164":"A"},K:{"2":"A","129":"B C YB gB ZB","164":"Q"},L:{"164":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"164":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"164":"cC"},R:{"164":"dC"},S:{"1":"eC"}},B:5,C:"CSS box-decoration-break"};


/***/ }),

/***/ 22004:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","33":"lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"I c J D E F"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","33":"c","164":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","33":"2B hB","164":"eB"},H:{"2":"LC"},I:{"1":"I H PC hB QC RC","164":"aB MC NC OC"},J:{"1":"A","33":"D"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS3 Box-shadow"};


/***/ }),

/***/ 34651:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"0 1 2 3 4 5 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"2":"pB eB","33":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","33":"G M N O d e f g h i j k l m n o p q r s"},G:{"33":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"H","33":"aB I MC NC OC PC hB QC RC"},J:{"33":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"TC UC VC WC XC fB YC ZC aC bC","33":"I"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"CSS Canvas Drawings"};


/***/ }),

/***/ 3560:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB lB mB"},D:{"1":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB"},F:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","2":"I TC UC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"CSS caret-color"};


/***/ }),

/***/ 4497:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:5,C:"Case-insensitive CSS attribute selectors"};


/***/ }),

/***/ 37028:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N","260":"R S T U V W X Y Z a P b H","3138":"O"},C:{"1":"CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","132":"0 1 2 3 4 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","644":"5 6 7 8 9 AB BB"},D:{"2":"I c J D E F A B C K L G M N O d e f g h","260":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","292":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB"},E:{"2":"I c J pB eB qB rB","292":"D E F A B C K L G sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","260":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","292":"G M N O d e f g h i j k l m n o p q r s t u v w x y z"},G:{"2":"eB 2B hB 3B 4B","292":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","260":"H","292":"QC RC"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","260":"Q"},L:{"260":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"292":"SC"},P:{"292":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"292":"cC"},R:{"260":"dC"},S:{"644":"eC"}},B:4,C:"CSS clip-path property (for HTML)"};


/***/ }),

/***/ 75747:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","33":"R S T U V W X Y Z a P b H"},C:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"16":"I c J D E F A B C K L G M N O","33":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c pB eB qB","33":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","33":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"16":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"16":"aB I MC NC OC PC hB QC RC","33":"H"},J:{"16":"D A"},K:{"2":"A B C YB gB ZB","33":"Q"},L:{"16":"H"},M:{"1":"P"},N:{"16":"A B"},O:{"16":"SC"},P:{"16":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"33":"cC"},R:{"16":"dC"},S:{"1":"eC"}},B:5,C:"CSS color-adjust"};


/***/ }),

/***/ 4008:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"G wB","2":"I c J D E F A pB eB qB rB sB tB","132":"B C K L fB YB ZB uB vB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B","132":"AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS color() function"};


/***/ }),

/***/ 31811:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB lB mB","578":"UB VB WB XB R S T kB"},D:{"1":"OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB","194":"bB HB cB IB JB Q KB LB MB NB"},E:{"1":"K L G ZB uB vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB"},F:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","194":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB"},G:{"1":"EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"fB YC ZC aC bC","2":"I TC UC VC WC XC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS Conical Gradients"};


/***/ }),

/***/ 61547:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b","194":"H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"CSS Container Queries"};


/***/ }),

/***/ 64484:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y lB mB","194":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB"},D:{"1":"AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","66":"9"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v xB yB zB 0B YB gB 1B ZB","66":"w x"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I TC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"194":"eC"}},B:2,C:"CSS Containment"};


/***/ }),

/***/ 69511:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"W X Y Z a P b H","2":"C K L G M N O R S T U V"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V"},E:{"2":"I c J D E F A B C K L pB eB qB rB sB tB fB YB ZB uB vB wB","16":"G"},F:{"1":"QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"bC","2":"I TC UC VC WC XC fB YC ZC aC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS content-visibility"};


/***/ }),

/***/ 11237:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"J D iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS Counters"};


/***/ }),

/***/ 36717:
/***/ ((module) => {

module.exports={A:{A:{"2":"J iB","2340":"D E F A B"},B:{"2":"C K L G M N O","1025":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB lB","513":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","545":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q mB"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y","1025":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c pB eB qB","164":"J","4644":"D E F rB sB tB"},F:{"2":"F B G M N O d e f g h i j k l xB yB zB 0B YB gB","545":"C 1B ZB","1025":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB","4260":"3B 4B","4644":"E 5B 6B 7B 8B"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","1025":"H"},J:{"2":"D","4260":"A"},K:{"2":"A B YB gB","545":"C ZB","1025":"Q"},L:{"1025":"H"},M:{"545":"P"},N:{"2340":"A B"},O:{"1":"SC"},P:{"1025":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1025":"cC"},R:{"1025":"dC"},S:{"4097":"eC"}},B:7,C:"Crisp edges/pixelated images"};


/***/ }),

/***/ 90831:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","33":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"I c J D E F A B C K L G M","33":"0 1 2 3 4 5 6 7 8 9 N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c pB eB","33":"J D E F qB rB sB tB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","33":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB","33":"E 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","33":"H QC RC"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","33":"Q"},L:{"33":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"33":"SC"},P:{"33":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"33":"cC"},R:{"33":"dC"},S:{"2":"eC"}},B:4,C:"CSS Cross-Fade Function"};


/***/ }),

/***/ 99030:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","16":"jB aB lB mB"},D:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L","132":"0 1 2 3 4 5 6 7 8 G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"B C K L G fB YB ZB uB vB wB","16":"I c pB eB","132":"J D E F A qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F B xB yB zB 0B YB gB","132":"G M N O d e f g h i j k l m n o p q r s t u v","260":"C 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB 3B 4B","132":"E 5B 6B 7B 8B 9B"},H:{"260":"LC"},I:{"1":"H","16":"aB MC NC OC","132":"I PC hB QC RC"},J:{"16":"D","132":"A"},K:{"1":"Q","16":"A B C YB gB","260":"ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"132":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","132":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:7,C:":default CSS pseudo-class"};


/***/ }),

/***/ 14942:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O S T U V W X Y Z a P b H","16":"R"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"B","2":"I c J D E F A C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Explicit descendant combinator >>"};


/***/ }),

/***/ 83318:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","164":"A B"},B:{"66":"R S T U V W X Y Z a P b H","164":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i j k l m","66":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x xB yB zB 0B YB gB 1B ZB","66":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"292":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A Q","292":"B C YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"164":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"66":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS Device Adaptation"};


/***/ }),

/***/ 15902:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M lB mB","33":"0 1 2 3 4 5 6 N O d e f g h i j k l m n o p q r s t u v w x y z"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P","194":"b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"33":"eC"}},B:5,C:":dir() CSS pseudo-class"};


/***/ }),

/***/ 45140:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"a P b H","2":"C K L G M N O","260":"R S T U V W X Y Z"},C:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u lB mB","260":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB bB HB cB"},D:{"1":"a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB","194":"GB bB HB cB IB JB Q","260":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z"},E:{"2":"I c J D E F A B pB eB qB rB sB tB fB","260":"L G uB vB wB","772":"C K YB ZB"},F:{"1":"VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","260":"AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC","260":"IC JC KC","772":"CC DC EC FC GC HC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC","260":"XC fB YC ZC aC bC"},Q:{"260":"cC"},R:{"2":"dC"},S:{"260":"eC"}},B:5,C:"CSS display: contents"};


/***/ }),

/***/ 21694:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"33":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","164":"jB aB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"33":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"33":"eC"}},B:5,C:"CSS element() function"};


/***/ }),

/***/ 21809:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q lB mB"},D:{"1":"OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB","132":"B"},F:{"1":"EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB xB yB zB 0B YB gB 1B ZB"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC","132":"BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"fB YC ZC aC bC","2":"I TC UC VC WC XC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"CSS Environment Variables env()"};


/***/ }),

/***/ 79991:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","33":"A B"},B:{"2":"R S T U V W X Y Z a P b H","33":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"33":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS Exclusions Level 1"};


/***/ }),

/***/ 53231:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B C xB yB zB 0B YB gB 1B"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS Feature Queries"};


/***/ }),

/***/ 19533:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB","33":"F"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B","33":"7B 8B"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS filter() function"};


/***/ }),

/***/ 35123:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","1028":"K L G M N O","1346":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB","196":"s","516":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r mB"},D:{"1":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N","33":"0 1 2 3 4 5 6 7 8 9 O d e f g h i j k l m n o p q r s t u v w x y z AB"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"I c pB eB qB","33":"J D E F rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","33":"G M N O d e f g h i j k l m n o p q r s t u v w x"},G:{"1":"8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B","33":"E 4B 5B 6B 7B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB","33":"QC RC"},J:{"2":"D","33":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","33":"I TC UC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"CSS Filter Effects"};


/***/ }),

/***/ 95006:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","16":"iB","516":"E","1540":"J D"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","132":"aB","260":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"c J D E","132":"I"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"c pB","132":"I eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","16":"F xB","260":"B yB zB 0B YB gB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB"},H:{"1":"LC"},I:{"1":"aB I H PC hB QC RC","16":"MC NC","132":"OC"},J:{"1":"D A"},K:{"1":"C Q ZB","260":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"::first-letter CSS pseudo-element selector"};


/***/ }),

/***/ 34624:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","132":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS first-line pseudo-element"};


/***/ }),

/***/ 4787:
/***/ ((module) => {

module.exports={A:{A:{"1":"D E F A B","2":"iB","8":"J"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB fB YB ZB uB vB wB","1025":"tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB","132":"3B 4B 5B"},H:{"2":"LC"},I:{"1":"aB H QC RC","260":"MC NC OC","513":"I PC hB"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS position:fixed"};


/***/ }),

/***/ 59934:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"X Y Z a P b H","2":"C K L G M N O","328":"R S T U V W"},C:{"1":"W X Y Z a P b H dB","2":"jB aB lB mB","161":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V"},D:{"1":"X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB","328":"MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W"},E:{"2":"I c J D E F A B C K L pB eB qB rB sB tB fB YB ZB uB vB wB","16":"G"},F:{"1":"RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB xB yB zB 0B YB gB 1B ZB","328":"LB MB NB OB PB QB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"bC","2":"I TC UC VC WC XC fB YC ZC aC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"161":"eC"}},B:7,C:":focus-visible CSS pseudo-class"};


/***/ }),

/***/ 1620:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB","194":"bB"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","194":"4"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC VC"},Q:{"1":"cC"},R:{"16":"dC"},S:{"2":"eC"}},B:7,C:":focus-within CSS pseudo-class"};


/***/ }),

/***/ 80882:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","194":"4 5 6 7 8 9 AB BB CB DB EB FB"},D:{"1":"HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","66":"7 8 9 AB BB CB DB EB FB GB bB"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB"},F:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t xB yB zB 0B YB gB 1B ZB","66":"0 1 2 3 4 u v w x y z"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I","66":"TC UC VC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"194":"eC"}},B:5,C:"CSS font-display"};


/***/ }),

/***/ 6482:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E lB mB"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS font-stretch"};


/***/ }),

/***/ 49718:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D iB","132":"E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS Generated content for pseudo-elements"};


/***/ }),

/***/ 13657:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB","260":"M N O d e f g h i j k l m n o p q r s t","292":"I c J D E F A B C K L G mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"A B C K L G M N O d e f g h i j","548":"I c J D E F"},E:{"2":"pB eB","260":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","292":"J qB","804":"I c"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B","33":"C 1B","164":"YB gB"},G:{"260":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","292":"3B 4B","804":"eB 2B hB"},H:{"2":"LC"},I:{"1":"H QC RC","33":"I PC hB","548":"aB MC NC OC"},J:{"1":"A","548":"D"},K:{"1":"Q ZB","2":"A B","33":"C","164":"YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS Gradients"};


/***/ }),

/***/ 19330:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","8":"F","292":"A B"},B:{"1":"M N O R S T U V W X Y Z a P b H","292":"C K L G"},C:{"1":"CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O lB mB","8":"d e f g h i j k l m n o p q r s t u v w x","584":"0 1 2 3 4 5 6 7 8 9 y z","1025":"AB BB"},D:{"1":"GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i","8":"j k l m","200":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB","1025":"FB"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c pB eB qB","8":"J D E F A rB sB tB"},F:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l xB yB zB 0B YB gB 1B ZB","200":"0 1 m n o p q r s t u v w x y z"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B","8":"E 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC","8":"hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"292":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"TC","8":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:4,C:"CSS Grid Layout (level 1)"};


/***/ }),

/***/ 59804:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS hanging-punctuation"};


/***/ }),

/***/ 28790:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:":has() CSS relational pseudo-class"};


/***/ }),

/***/ 22889:
/***/ ((module) => {

module.exports={A:{A:{"16":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","16":"C K L G M N O"},C:{"16":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB"},E:{"16":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"16":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"16":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"16":"LC"},I:{"16":"aB I H MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"16":"A B C Q YB gB ZB"},L:{"16":"H"},M:{"16":"P"},N:{"16":"A B"},O:{"16":"SC"},P:{"16":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"16":"cC"},R:{"16":"dC"},S:{"16":"eC"}},B:5,C:"CSS4 Hyphenation"};


/***/ }),

/***/ 89317:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","33":"A B"},B:{"33":"C K L G M N O","132":"R S T U V W X Y","260":"Z a P b H"},C:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c lB mB","33":"0 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},D:{"1":"Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB","132":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y"},E:{"2":"I c pB eB","33":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","132":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"eB 2B","33":"E hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"4":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I","132":"TC"},Q:{"2":"cC"},R:{"132":"dC"},S:{"1":"eC"}},B:5,C:"CSS Hyphenation"};


/***/ }),

/***/ 38133:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"a P b H","2":"C K L G M N O R S","257":"T U V W X Y Z"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j lB mB"},D:{"1":"a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S","257":"T U V W X Y Z"},E:{"1":"L G uB vB wB","2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB"},F:{"1":"NB OB PB QB RB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB xB yB zB 0B YB gB 1B ZB","257":"SB TB UB VB WB XB"},G:{"1":"JC KC","132":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"aC bC","2":"I TC UC VC WC XC fB YC ZC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:4,C:"CSS3 image-orientation"};


/***/ }),

/***/ 2762:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","164":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W lB mB","66":"X Y","257":"a P b H dB","772":"Z"},D:{"2":"I c J D E F A B C K L G M N O d e","164":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c pB eB qB","132":"A B C K fB YB ZB uB","164":"J D E F rB sB tB","516":"L G vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","164":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"eB 2B hB 3B","132":"9B AC BC CC DC EC FC GC HC IC","164":"E 4B 5B 6B 7B 8B","516":"JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","164":"H QC RC"},J:{"2":"D","164":"A"},K:{"2":"A B C YB gB ZB","164":"Q"},L:{"164":"H"},M:{"257":"P"},N:{"2":"A B"},O:{"164":"SC"},P:{"164":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"164":"cC"},R:{"164":"dC"},S:{"2":"eC"}},B:5,C:"CSS image-set"};


/***/ }),

/***/ 88654:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C","260":"K L G M N O"},C:{"1":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB","516":"0 1 2 3 4 5 6 7 n o p q r s t u v w x y z"},D:{"1":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I","16":"c J D E F A B C K L","260":"AB","772":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I pB eB","16":"c","772":"J D E F A qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F xB","260":"B C x yB zB 0B YB gB 1B ZB","772":"G M N O d e f g h i j k l m n o p q r s t u v w"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB","772":"E 3B 4B 5B 6B 7B 8B 9B"},H:{"132":"LC"},I:{"1":"H","2":"aB MC NC OC","260":"I PC hB QC RC"},J:{"2":"D","260":"A"},K:{"1":"Q","260":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","260":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"516":"eC"}},B:5,C:":in-range and :out-of-range CSS pseudo-classes"};


/***/ }),

/***/ 61436:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","132":"A B","388":"F"},B:{"1":"R S T U V W X Y Z a P b H","132":"C K L G M N O"},C:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","16":"jB aB lB mB","132":"0 1 2 3 4 5 6 7 8 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","388":"I c"},D:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L","132":"G M N O d e f g h i j k l m n o p q r s t u v w"},E:{"1":"B C K L G fB YB ZB uB vB wB","16":"I c J pB eB","132":"D E F A rB sB tB","388":"qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F B xB yB zB 0B YB gB","132":"G M N O d e f g h i j","516":"C 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB 3B 4B","132":"E 5B 6B 7B 8B 9B"},H:{"516":"LC"},I:{"1":"H","16":"aB MC NC OC RC","132":"QC","388":"I PC hB"},J:{"16":"D","132":"A"},K:{"1":"Q","16":"A B C YB gB","516":"ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"132":"eC"}},B:7,C:":indeterminate CSS pseudo-class"};


/***/ }),

/***/ 68010:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E pB eB qB rB sB","4":"F","164":"A B C K L G tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B","164":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS Initial Letter"};


/***/ }),

/***/ 52764:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","33":"I c J D E F A B C K L G M N O lB mB","164":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G eB qB rB sB tB fB YB ZB uB vB wB","16":"pB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS initial value"};


/***/ }),

/***/ 6661:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","16":"iB","132":"J D E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c J D E F A B C K L G M N O d e f g h i j k l m n"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","16":"pB","132":"I c J eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F xB","132":"B C G M yB zB 0B YB gB 1B ZB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"2":"LC"},I:{"1":"H QC RC","16":"MC NC","132":"aB I OC PC hB"},J:{"132":"D A"},K:{"1":"Q","132":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"letter-spacing CSS property"};


/***/ }),

/***/ 12931:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M","33":"R S T U V W X Y Z a P b H","129":"N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB lB mB","33":"NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"16":"I c J D E F A B C K","33":"0 1 2 3 4 5 6 7 8 9 L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I pB eB","33":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","33":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"eB 2B hB","33":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"16":"MC NC","33":"aB I H OC PC hB QC RC"},J:{"33":"D A"},K:{"2":"A B C YB gB ZB","33":"Q"},L:{"33":"H"},M:{"33":"P"},N:{"2":"A B"},O:{"33":"SC"},P:{"33":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"33":"cC"},R:{"33":"dC"},S:{"2":"eC"}},B:5,C:"CSS line-clamp"};


/***/ }),

/***/ 23871:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"a P b H","2":"C K L G M N O","2052":"Y Z","3588":"R S T U V W X"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB","164":"aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y lB mB"},D:{"1":"a P b H dB nB oB","292":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB","2052":"Y Z","3588":"OB PB QB RB SB TB UB VB WB XB R S T U V W X"},E:{"1":"G wB","292":"I c J D E F A B C pB eB qB rB sB tB fB YB","2052":"vB","3588":"K L ZB uB"},F:{"1":"VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","292":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB","2052":"TB UB","3588":"EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB"},G:{"292":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC","2052":"KC","3588":"EC FC GC HC IC JC"},H:{"2":"LC"},I:{"1":"H","292":"aB I MC NC OC PC hB QC RC"},J:{"292":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"292":"SC"},P:{"292":"I TC UC VC WC XC","3588":"fB YC ZC aC bC"},Q:{"3588":"cC"},R:{"3588":"dC"},S:{"3588":"eC"}},B:5,C:"CSS Logical Properties"};


/***/ }),

/***/ 35371:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"X Y Z a P b H","2":"C K L G M N O R S T U V W"},C:{"1":"NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB lB mB"},D:{"1":"X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W"},E:{"2":"I c J D E F A B pB eB qB rB sB tB fB","129":"C K L G YB ZB uB vB wB"},F:{"1":"RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB xB yB zB 0B YB gB 1B ZB"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"bC","2":"I TC UC VC WC XC fB YC ZC aC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS ::marker pseudo-element"};


/***/ }),

/***/ 15592:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M","164":"R S T U V W X Y Z a P b H","3138":"N","12292":"O"},C:{"1":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","260":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB lB mB"},D:{"164":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"pB eB","164":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","164":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"164":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"164":"H QC RC","676":"aB I MC NC OC PC hB"},J:{"164":"D A"},K:{"2":"A B C YB gB ZB","164":"Q"},L:{"164":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"164":"SC"},P:{"164":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"164":"cC"},R:{"164":"dC"},S:{"260":"eC"}},B:4,C:"CSS Masks"};


/***/ }),

/***/ 45820:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"Z a P b H","2":"C K L G M N O","1220":"R S T U V W X Y"},C:{"1":"XB R S T kB U V W X Y Z a P b H dB","16":"jB aB lB mB","548":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB"},D:{"1":"Z a P b H dB nB oB","16":"I c J D E F A B C K L","164":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q","196":"KB LB MB","1220":"NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y"},E:{"1":"L G vB wB","2":"I pB eB","16":"c","164":"J D E qB rB sB","260":"F A B C K tB fB YB ZB uB"},F:{"1":"UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","164":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z","196":"AB BB CB","1220":"DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB"},G:{"1":"JC KC","16":"eB 2B hB 3B 4B","164":"E 5B 6B","260":"7B 8B 9B AC BC CC DC EC FC GC HC IC"},H:{"2":"LC"},I:{"1":"H","16":"aB MC NC OC","164":"I PC hB QC RC"},J:{"16":"D","164":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"164":"SC"},P:{"164":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1220":"cC"},R:{"164":"dC"},S:{"548":"eC"}},B:5,C:":is() CSS pseudo-class"};


/***/ }),

/***/ 15868:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB lB mB"},D:{"1":"R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},E:{"1":"L G uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB","132":"C K YB ZB"},F:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB xB yB zB 0B YB gB 1B ZB"},G:{"1":"IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC","132":"CC DC EC FC GC HC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"ZC aC bC","2":"I TC UC VC WC XC fB YC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS math functions min(), max() and clamp()"};


/***/ }),

/***/ 22427:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"Media Queries: interaction media features"};


/***/ }),

/***/ 79494:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","132":"F A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","260":"I c J D E F A B C K L G lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","548":"I c J D E F A B C K L G M N O d e f g h i j k l m"},E:{"2":"pB eB","548":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F","548":"B C xB yB zB 0B YB gB 1B"},G:{"16":"eB","548":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"132":"LC"},I:{"1":"H QC RC","16":"MC NC","548":"aB I OC PC hB"},J:{"548":"D A"},K:{"1":"Q ZB","548":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"Media Queries: resolution feature"};


/***/ }),

/***/ 78527:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"16":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","16":"AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H","16":"dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"Media Queries: scripting media feature"};


/***/ }),

/***/ 47055:
/***/ ((module) => {

module.exports={A:{A:{"8":"J D E iB","129":"F A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","129":"I c J D E F A B C K L G M N O d e f g h i j"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","129":"I c J qB","388":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","129":"eB 2B hB 3B 4B"},H:{"1":"LC"},I:{"1":"H QC RC","129":"aB I MC NC OC PC hB"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"129":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS3 Media Queries"};


/***/ }),

/***/ 93831:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m","194":"n o p q r s t u v w x y"},E:{"2":"I c J D pB eB qB rB","260":"E F A B C K L G sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m xB yB zB 0B YB gB 1B ZB"},G:{"2":"eB 2B hB 3B 4B 5B","260":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"Blending of HTML/SVG elements"};


/***/ }),

/***/ 46876:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB lB mB"},D:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"1 2 3"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n xB yB zB 0B YB gB 1B ZB","194":"o p q"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"CSS Motion Path"};


/***/ }),

/***/ 9028:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS namespaces"};


/***/ }),

/***/ 92481:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"Z a P b H","2":"C K L G M N O S T U V W X Y","16":"R"},C:{"1":"V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U lB mB"},D:{"1":"Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"selector list argument of :not()"};


/***/ }),

/***/ 66492:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"selector list argument of :nth-child and :nth-last-child CSS pseudo-classes"};


/***/ }),

/***/ 23375:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","4":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS3 Opacity"};


/***/ }),

/***/ 93492:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F xB","132":"B C yB zB 0B YB gB 1B ZB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"132":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"Q","132":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:7,C:":optional CSS pseudo-class"};


/***/ }),

/***/ 11721:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB lB mB"},D:{"1":"EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"2":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"CSS overflow-anchor (Scroll Anchoring)"};


/***/ }),

/***/ 74065:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"I c J D E F A B qB rB sB tB fB YB","16":"pB eB","130":"C K L G ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC","16":"eB","130":"DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:7,C:"CSS overflow: overlay"};


/***/ }),

/***/ 91764:
/***/ ((module) => {

module.exports={A:{A:{"388":"J D E F A B iB"},B:{"1":"P b H","260":"R S T U V W X Y Z a","388":"C K L G M N O"},C:{"1":"T kB U V W X Y Z a P b H dB","260":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S","388":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB lB mB"},D:{"1":"P b H dB nB oB","260":"NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a","388":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB"},E:{"260":"L G uB vB wB","388":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB"},F:{"260":"DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","388":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB xB yB zB 0B YB gB 1B ZB"},G:{"260":"IC JC KC","388":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC"},H:{"388":"LC"},I:{"1":"H","388":"aB I MC NC OC PC hB QC RC"},J:{"388":"D A"},K:{"1":"Q","388":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"388":"A B"},O:{"388":"SC"},P:{"388":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"388":"cC"},R:{"388":"dC"},S:{"388":"eC"}},B:5,C:"CSS overflow property"};


/***/ }),

/***/ 50237:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","132":"A B"},B:{"1":"R S T U V W X Y Z a P b H","132":"C K L G M N","516":"O"},C:{"1":"bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB lB mB"},D:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB","260":"JB Q"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB wB","1090":"vB"},F:{"1":"AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","260":"8 9"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"2":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC VC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"CSS overscroll-behavior"};


/***/ }),

/***/ 88866:
/***/ ((module) => {

module.exports={A:{A:{"388":"A B","900":"J D E F iB"},B:{"388":"C K L G M N O","900":"R S T U V W X Y Z a P b H"},C:{"772":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","900":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q lB mB"},D:{"900":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"772":"A","900":"I c J D E F B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"16":"F xB","129":"B C yB zB 0B YB gB 1B ZB","900":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"900":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"129":"LC"},I:{"900":"aB I H MC NC OC PC hB QC RC"},J:{"900":"D A"},K:{"129":"A B C YB gB ZB","900":"Q"},L:{"900":"H"},M:{"900":"P"},N:{"388":"A B"},O:{"900":"SC"},P:{"900":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"900":"cC"},R:{"900":"dC"},S:{"900":"eC"}},B:2,C:"CSS page-break properties"};


/***/ }),

/***/ 76098:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D iB","132":"E F A B"},B:{"1":"R S T U V W X Y Z a P b H","132":"C K L G M N O"},C:{"2":"jB aB I c J D E F A B C K L G M N O lB mB","132":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","132":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"16":"LC"},I:{"16":"aB I H MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"16":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"132":"P"},N:{"258":"A B"},O:{"258":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"132":"eC"}},B:5,C:"CSS Paged Media (@page)"};


/***/ }),

/***/ 10133:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q"},E:{"2":"I c J D E F A B C pB eB qB rB sB tB fB YB","194":"K L G ZB uB vB wB"},F:{"1":"AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS Paint API"};


/***/ }),

/***/ 70361:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","292":"A B"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","164":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},D:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"164":"eC"}},B:5,C:":placeholder-shown CSS pseudo-class"};


/***/ }),

/***/ 83448:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","36":"C K L G M N O"},C:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O lB mB","33":"0 1 2 3 4 5 6 7 8 d e f g h i j k l m n o p q r s t u v w x y z"},D:{"1":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","36":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I pB eB","36":"c J D E F A qB rB sB tB"},F:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","36":"0 1 G M N O d e f g h i j k l m n o p q r s t u v w x y z"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B","36":"E hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","36":"aB I MC NC OC PC hB QC RC"},J:{"36":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"36":"A B"},O:{"1":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","36":"I TC UC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"33":"eC"}},B:5,C:"::placeholder CSS pseudo-element"};


/***/ }),

/***/ 17667:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","2":"C"},C:{"1":"XB R S T kB U V W X Y Z a P b H dB","16":"jB","33":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L","132":"G M N O d e f g h i j k l m n o p q r s t"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","16":"pB eB","132":"I c J D E qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F B xB yB zB 0B YB","132":"C G M N O d e f g gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B","132":"E hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","16":"MC NC","132":"aB I OC PC hB QC RC"},J:{"1":"A","132":"D"},K:{"1":"Q","2":"A B YB","132":"C gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"33":"eC"}},B:1,C:"CSS :read-only and :read-write selectors"};


/***/ }),

/***/ 32723:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","132":"B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB","16":"rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"Rebeccapurple color"};


/***/ }),

/***/ 25056:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","33":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"33":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"pB eB","33":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","33":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"33":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"33":"aB I H MC NC OC PC hB QC RC"},J:{"33":"D A"},K:{"2":"A B C YB gB ZB","33":"Q"},L:{"33":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"33":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"33":"cC"},R:{"33":"dC"},S:{"2":"eC"}},B:7,C:"CSS Reflections"};


/***/ }),

/***/ 32598:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","420":"A B"},B:{"2":"R S T U V W X Y Z a P b H","420":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","36":"G M N O","66":"d e f g h i j k l m n o p q r s"},E:{"2":"I c J C K L G pB eB qB YB ZB uB vB wB","33":"D E F A B rB sB tB fB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"eB 2B hB 3B 4B CC DC EC FC GC HC IC JC KC","33":"E 5B 6B 7B 8B 9B AC BC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"420":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS Regions"};


/***/ }),

/***/ 62787:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB","33":"I c J D E F A B C K L G mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F","33":"A B C K L G M N O d e f g h i j"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB","33":"J qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B","33":"C 1B","36":"YB gB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB","33":"3B 4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB MC NC OC","33":"I PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q ZB","2":"A B","33":"C","36":"YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS Repeating Gradients"};


/***/ }),

/***/ 36660:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","33":"I"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B","132":"ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:4,C:"CSS resize property"};


/***/ }),

/***/ 47190:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"V W X Y Z a P b H","2":"C K L G M N O R S T U"},C:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB lB mB"},D:{"1":"V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB"},F:{"1":"SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB xB yB zB 0B YB gB 1B ZB"},G:{"1":"8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"bC","2":"I TC UC VC WC XC fB YC ZC aC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS revert value"};


/***/ }),

/***/ 87215:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"AB BB CB DB EB FB GB bB HB cB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w xB yB zB 0B YB gB 1B ZB","194":"0 1 2 3 4 5 6 7 8 9 x y z"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I","194":"TC UC VC"},Q:{"2":"cC"},R:{"194":"dC"},S:{"2":"eC"}},B:7,C:"#rrggbbaa hex color notation"};


/***/ }),

/***/ 58544:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","129":"R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t lB mB"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y","129":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","450":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB"},E:{"2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB uB","578":"L G vB wB"},F:{"2":"F B C G M N O d e f g h i j k l xB yB zB 0B YB gB 1B ZB","129":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","450":"0 1 2 3 4 5 m n o p q r s t u v w x y z"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"129":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC VC"},Q:{"129":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSSOM Scroll-behavior"};


/***/ }),

/***/ 52572:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a","194":"P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V","194":"Z a P b H dB nB oB","322":"W X Y"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB xB yB zB 0B YB gB 1B ZB","194":"UB VB WB XB","322":"SB TB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"CSS @scroll-timeline"};


/***/ }),

/***/ 37851:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B iB"},B:{"2":"C K L G M N O","292":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB lB mB","3074":"JB","4100":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"292":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"16":"I c pB eB","292":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","292":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"16":"eB 2B hB 3B 4B","292":"5B","804":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"16":"MC NC","292":"aB I H OC PC hB QC RC"},J:{"292":"D A"},K:{"2":"A B C YB gB ZB","292":"Q"},L:{"292":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"292":"SC"},P:{"292":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"292":"cC"},R:{"292":"dC"},S:{"2":"eC"}},B:7,C:"CSS scrollbar styling"};


/***/ }),

/***/ 92398:
/***/ ((module) => {

module.exports={A:{A:{"1":"D E F A B","2":"iB","8":"J"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS 2.1 selectors"};


/***/ }),

/***/ 40787:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"iB","8":"J","132":"D E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G eB qB rB sB tB fB YB ZB uB vB wB","2":"pB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS3 selectors"};


/***/ }),

/***/ 16302:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","33":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"C Q gB ZB","16":"A B YB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"33":"eC"}},B:5,C:"::selection CSS pseudo-element"};


/***/ }),

/***/ 56938:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","322":"9 AB BB CB DB EB FB GB bB HB cB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r","194":"s t u"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D pB eB qB rB","33":"E F A sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B","33":"E 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:4,C:"CSS Shapes Level 1"};


/***/ }),

/***/ 82776:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","6308":"A","6436":"B"},B:{"1":"R S T U V W X Y Z a P b H","6436":"C K L G M N O"},C:{"1":"NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w lB mB","2052":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB"},D:{"1":"OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB","8258":"LB MB NB"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB","3108":"F A tB fB"},F:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB xB yB zB 0B YB gB 1B ZB","8258":"CB DB EB FB GB HB IB JB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B","3108":"7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"fB YC ZC aC bC","2":"I TC UC VC WC XC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2052":"eC"}},B:4,C:"CSS Scroll Snap"};


/***/ }),

/***/ 67425:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"b H","2":"C K L G","1028":"R S T U V W X Y Z a P","4100":"M N O"},C:{"1":"bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j lB mB","194":"k l m n o p","516":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB"},D:{"1":"b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g v w x y z","322":"h i j k l m n o p q r s t u AB BB CB DB","1028":"EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P"},E:{"1":"K L G uB vB wB","2":"I c J pB eB qB","33":"E F A B C sB tB fB YB ZB","2084":"D rB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w xB yB zB 0B YB gB 1B ZB","322":"x y z","1028":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"FC GC HC IC JC KC","2":"eB 2B hB 3B","33":"E 6B 7B 8B 9B AC BC CC DC EC","2084":"4B 5B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1028":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I TC"},Q:{"1028":"cC"},R:{"2":"dC"},S:{"516":"eC"}},B:5,C:"CSS position:sticky"};


/***/ }),

/***/ 70836:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS Subgrid"};


/***/ }),

/***/ 43295:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","260":"C K L G M N O"},C:{"1":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d lB mB","66":"e f","260":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB"},D:{"1":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l","260":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B","132":"ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"132":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB","132":"ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS.supports() API"};


/***/ }),

/***/ 57271:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"J D iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","132":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS Table display"};


/***/ }),

/***/ 68887:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","4":"C K L G M N O"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B lB mB","33":"0 1 2 3 4 5 6 C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},D:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s","322":"0 1 2 3 4 t u v w x y z"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f xB yB zB 0B YB gB 1B ZB","578":"g h i j k l m n o p q r"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"2":"cC"},R:{"1":"dC"},S:{"33":"eC"}},B:5,C:"CSS3 text-align-last"};


/***/ }),

/***/ 34715:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B iB"},B:{"132":"C K L G M N O","388":"R S T U V W X Y Z a P b H"},C:{"132":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"132":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v","388":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"132":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"132":"F B C G M N O d e f g h i xB yB zB 0B YB gB 1B ZB","388":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"132":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"132":"LC"},I:{"132":"aB I MC NC OC PC hB QC RC","388":"H"},J:{"132":"D A"},K:{"132":"A B C YB gB ZB","388":"Q"},L:{"388":"H"},M:{"132":"P"},N:{"132":"A B"},O:{"132":"SC"},P:{"132":"I","388":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"388":"cC"},R:{"388":"dC"},S:{"132":"eC"}},B:5,C:"CSS text-indent"};


/***/ }),

/***/ 83983:
/***/ ((module) => {

module.exports={A:{A:{"16":"J D iB","132":"E F A B"},B:{"132":"C K L G M N O","322":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB lB mB","1025":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","1602":"CB"},D:{"2":"0 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","322":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C G M N O d e f g h i j k l m n xB yB zB 0B YB gB 1B ZB","322":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","322":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","322":"Q"},L:{"322":"H"},M:{"1025":"P"},N:{"132":"A B"},O:{"2":"SC"},P:{"2":"I","322":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"322":"cC"},R:{"322":"dC"},S:{"2":"eC"}},B:5,C:"CSS text-justify"};


/***/ }),

/***/ 80045:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v lB mB","194":"w x y"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"L G vB wB","2":"I c J D E F pB eB qB rB sB tB","16":"A","33":"B C K fB YB ZB uB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS text-orientation"};


/***/ }),

/***/ 75688:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D iB","161":"E F A B"},B:{"2":"R S T U V W X Y Z a P b H","161":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"16":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"CSS Text 4 text-spacing"};


/***/ }),

/***/ 43548:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","129":"A B"},B:{"1":"R S T U V W X Y Z a P b H","129":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","260":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"4":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"A","4":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"129":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS3 Text-shadow"};


/***/ }),

/***/ 62291:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","132":"B","164":"A"},B:{"1":"R S T U V W X Y Z a P b H","132":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB","260":"DB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","260":"0"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"132":"B","164":"A"},O:{"2":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","16":"I"},Q:{"2":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"CSS touch-action level 2 values"};


/***/ }),

/***/ 8517:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F iB","289":"A"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB","194":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z","1025":"AB BB CB DB EB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g xB yB zB 0B YB gB 1B ZB"},G:{"1":"FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B","516":"8B 9B AC BC CC DC EC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","289":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"194":"eC"}},B:2,C:"CSS touch-action property"};


/***/ }),

/***/ 61964:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","33":"c J D E F A B C K L G","164":"I"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"I c J D E F A B C K L G M N O d e f g h i j"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","33":"J qB","164":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F xB yB","33":"C","164":"B zB 0B YB gB 1B"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","33":"4B","164":"eB 2B hB 3B"},H:{"2":"LC"},I:{"1":"H QC RC","33":"aB I MC NC OC PC hB"},J:{"1":"A","33":"D"},K:{"1":"Q ZB","33":"C","164":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"CSS3 Transitions"};


/***/ }),

/***/ 45257:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","132":"C K L G M N O"},C:{"1":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","33":"0 1 2 3 4 5 6 7 N O d e f g h i j k l m n o p q r s t u v w x y z","132":"jB aB I c J D E F lB mB","292":"A B C K L G M"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c J D E F A B C K L G M","548":"0 1 2 3 4 5 N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"132":"I c J D E pB eB qB rB sB","548":"F A B C K L G tB fB YB ZB uB vB wB"},F:{"132":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"132":"E eB 2B hB 3B 4B 5B 6B","548":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"16":"LC"},I:{"1":"H","16":"aB I MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"1":"Q","16":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"16":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","16":"I"},Q:{"16":"cC"},R:{"16":"dC"},S:{"33":"eC"}},B:4,C:"CSS unicode-bidi property"};


/***/ }),

/***/ 50750:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l xB yB zB 0B YB gB 1B ZB"},G:{"1":"8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS unset value"};


/***/ }),

/***/ 32973:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"M N O R S T U V W X Y Z a P b H","2":"C K L","260":"G"},C:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o lB mB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"6"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB","260":"tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s xB yB zB 0B YB gB 1B ZB","194":"t"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B","260":"8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"2":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:4,C:"CSS Variables (Custom Properties)"};


/***/ }),

/***/ 47477:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D iB","129":"E F"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","129":"F B xB yB zB 0B YB gB 1B"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q ZB","2":"A B C YB gB"},L:{"1":"H"},M:{"2":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:2,C:"CSS widows & orphans"};


/***/ }),

/***/ 47816:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t lB mB","322":"u v w x y"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J","16":"D","33":"0 1 2 3 4 5 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I pB eB","16":"c","33":"J D E F A qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","33":"G M N O d e f g h i j k l m n o p q r s"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB","33":"E 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","2":"MC NC OC","33":"aB I PC hB QC RC"},J:{"33":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"36":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","33":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS writing-mode property"};


/***/ }),

/***/ 26061:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D iB","129":"E F A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB"},H:{"2":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"129":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:7,C:"CSS zoom"};


/***/ }),

/***/ 26203:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"CSS3 attr() function for all properties"};


/***/ }),

/***/ 47610:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","8":"J D iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","33":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"I c J D E F"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","33":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","33":"eB 2B hB"},H:{"1":"LC"},I:{"1":"I H PC hB QC RC","33":"aB MC NC OC"},J:{"1":"A","33":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"CSS3 Box-sizing"};


/***/ }),

/***/ 91578:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","4":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB yB zB 0B YB gB 1B ZB","2":"F","4":"xB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS3 Colors"};


/***/ }),

/***/ 63355:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"G M N O R S T U V W X Y Z a P b H","2":"C K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","33":"jB aB I c J D E F A B C K L G M N O d e f g h i j k lB mB"},D:{"1":"NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB"},E:{"1":"B C K L G YB ZB uB vB wB","33":"I c J D E F A pB eB qB rB sB tB fB"},F:{"1":"C DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F B xB yB zB 0B YB gB","33":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"33":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"33":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:3,C:"CSS grab & grabbing cursors"};


/***/ }),

/***/ 70800:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","33":"jB aB I c J D E F A B C K L G M N O d e f g h lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","33":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F B xB yB zB 0B YB gB","33":"G M N O d e f g h"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"33":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"CSS3 Cursors: zoom-in & zoom-out"};


/***/ }),

/***/ 73281:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","132":"J D E iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","260":"C K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","4":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","4":"I"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","4":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","260":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D","16":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"CSS3 Cursors (original values)"};


/***/ }),

/***/ 87604:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"b H dB","2":"jB aB lB mB","33":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P","164":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e","132":"f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"L G uB vB wB","2":"I c J pB eB qB","132":"D E F A B C K rB sB tB fB YB ZB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F xB yB zB","132":"G M N O d e f g h i j k l m","164":"B C 0B YB gB 1B ZB"},G:{"1":"IC JC KC","2":"eB 2B hB 3B 4B","132":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC"},H:{"164":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB","132":"QC RC"},J:{"132":"D A"},K:{"1":"Q","2":"A","164":"B C YB gB ZB"},L:{"1":"H"},M:{"33":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"164":"eC"}},B:5,C:"CSS3 tab-size"};


/***/ }),

/***/ 66010:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS currentColor value"};


/***/ }),

/***/ 89306:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","8":"A B"},B:{"1":"R","2":"S T U V W X Y Z a P b H","8":"C K L G M N O"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","66":"h i j k l m n","72":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R","2":"I c J D E F A B C K L G M N O d e f g h i j k S T U V W X Y Z a P b H dB nB oB","66":"l m n o p q"},E:{"2":"I c pB eB qB","8":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB","2":"F B C MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","66":"G M N O d"},G:{"2":"eB 2B hB 3B 4B","8":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"RC","2":"aB I H MC NC OC PC hB QC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC","2":"aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"72":"eC"}},B:7,C:"Custom Elements (deprecated V0 spec)"};


/***/ }),

/***/ 68426:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","8":"A B"},B:{"1":"R S T U V W X Y Z a P b H","8":"C K L G M N O"},C:{"1":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n lB mB","8":"0 1 2 3 4 5 6 7 o p q r s t u v w x y z","456":"8 9 AB BB CB DB EB FB GB","712":"bB HB cB IB"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","8":"AB BB","132":"CB DB EB FB GB bB HB cB IB JB Q KB LB"},E:{"2":"I c J D pB eB qB rB sB","8":"E F A tB","132":"B C K L G fB YB ZB uB vB wB"},F:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y xB yB zB 0B YB gB 1B ZB","132":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B","132":"AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I","132":"TC"},Q:{"132":"cC"},R:{"132":"dC"},S:{"8":"eC"}},B:1,C:"Custom Elements (V1)"};


/***/ }),

/***/ 96529:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","132":"F A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c lB mB","132":"J D E F A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I","16":"c J D E K L","388":"F A B C"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I pB eB","16":"c J","388":"qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F xB yB zB 0B","132":"B YB gB"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"2B","16":"eB hB","388":"3B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"MC NC OC","388":"aB I PC hB"},J:{"1":"A","388":"D"},K:{"1":"C Q ZB","2":"A","132":"B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"CustomEvent"};


/***/ }),

/***/ 61338:
/***/ ((module) => {

module.exports={A:{A:{"2":"iB","8":"J D E F","260":"A B"},B:{"1":"R S T U V W X Y Z a P b H","260":"C K L G","1284":"M N O"},C:{"8":"jB aB lB mB","4612":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","8":"I c J D E F A B C K L G M N O d","132":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB"},E:{"1":"K L G ZB uB vB wB","8":"I c J D E F A B C pB eB qB rB sB tB fB YB"},F:{"1":"F B C Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","132":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB"},G:{"8":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC","2049":"EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H RC","8":"aB I MC NC OC PC hB QC"},J:{"1":"A","8":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"516":"P"},N:{"8":"A B"},O:{"8":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"132":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:1,C:"Datalist element"};


/***/ }),

/***/ 80410:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","4":"J D E F A iB"},B:{"1":"C K L G M","129":"N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","4":"jB aB I c lB mB","129":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"3 4 5 6 7 8 9 AB BB CB","4":"I c J","129":"0 1 2 D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"4":"I c pB eB","129":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"C q r s t u v w x y z YB gB 1B ZB","4":"F B xB yB zB 0B","129":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"4":"eB 2B hB","129":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"4":"LC"},I:{"4":"MC NC OC","129":"aB I H PC hB QC RC"},J:{"129":"D A"},K:{"1":"C YB gB ZB","4":"A B","129":"Q"},L:{"129":"H"},M:{"129":"P"},N:{"1":"B","4":"A"},O:{"129":"SC"},P:{"129":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"129":"dC"},S:{"1":"eC"}},B:1,C:"dataset & data-* attributes"};


/***/ }),

/***/ 57593:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D iB","132":"E","260":"F A B"},B:{"1":"R S T U V W X Y Z a P b H","260":"C K G M N O","772":"L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"260":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Data URIs"};


/***/ }),

/***/ 57488:
/***/ ((module) => {

module.exports={A:{A:{"16":"iB","132":"J D E F A B"},B:{"1":"O R S T U V W X Y Z a P b H","132":"C K L G M N"},C:{"1":"EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","132":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB","260":"AB BB CB DB","772":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z"},D:{"1":"PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c J D E F A B C K L G M N O d e f g h","260":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB","772":"i j k l m n o p q r s t u v"},E:{"1":"C K L G ZB uB vB wB","16":"I c pB eB","132":"J D E F A qB rB sB tB","260":"B fB YB"},F:{"1":"FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F B C xB yB zB 0B YB gB 1B","132":"ZB","260":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB","772":"G M N O d e f g h i"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB 3B","132":"E 4B 5B 6B 7B 8B 9B"},H:{"132":"LC"},I:{"1":"H","16":"aB MC NC OC","132":"I PC hB","772":"QC RC"},J:{"132":"D A"},K:{"1":"Q","16":"A B C YB gB","132":"ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"260":"SC"},P:{"1":"XC fB YC ZC aC bC","260":"I TC UC VC WC"},Q:{"260":"cC"},R:{"132":"dC"},S:{"132":"eC"}},B:6,C:"Date.prototype.toLocaleDateString"};


/***/ }),

/***/ 55777:
/***/ ((module) => {

module.exports={A:{A:{"2":"F A B iB","8":"J D E"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB","8":"0 1 2 3 4 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","194":"5 6"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","8":"I c J D E F A B","257":"d e f g h i j k l m n o p q r s t","769":"C K L G M N O"},E:{"1":"C K L G ZB uB vB wB","8":"I c pB eB qB","257":"J D E F A rB sB tB","1025":"B fB YB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"C YB gB 1B ZB","8":"F B xB yB zB 0B"},G:{"1":"E 4B 5B 6B 7B 8B CC DC EC FC GC HC IC JC KC","8":"eB 2B hB 3B","1025":"9B AC BC"},H:{"8":"LC"},I:{"1":"I H PC hB QC RC","8":"aB MC NC OC"},J:{"1":"A","8":"D"},K:{"1":"Q","8":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"769":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Details & Summary elements"};


/***/ }),

/***/ 30111:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","132":"B"},B:{"1":"C K L G M N O","4":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB lB","4":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","8":"I c mB"},D:{"2":"I c J","4":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","4":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"eB 2B","4":"E hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"MC NC OC","4":"aB I H PC hB QC RC"},J:{"2":"D","4":"A"},K:{"1":"C ZB","2":"A B YB gB","4":"Q"},L:{"4":"H"},M:{"4":"P"},N:{"1":"B","2":"A"},O:{"4":"SC"},P:{"4":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"4":"cC"},R:{"4":"dC"},S:{"4":"eC"}},B:4,C:"DeviceOrientation & DeviceMotion events"};


/***/ }),

/***/ 57084:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F B xB yB zB 0B YB gB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"C Q ZB","2":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"Window.devicePixelRatio"};


/***/ }),

/***/ 84530:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB lB mB","194":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R","1218":"S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p","322":"q r s t u"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O xB yB zB 0B YB gB 1B ZB","578":"d e f g h"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"194":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:1,C:"Dialog element"};


/***/ }),

/***/ 63229:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","16":"iB","129":"F A","130":"J D E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G eB qB rB sB tB fB YB ZB uB vB wB","16":"pB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","16":"F"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"1":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","129":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"EventTarget.dispatchEvent"};


/***/ }),

/***/ 15381:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B iB"},B:{"132":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"132":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"132":"0 1 2 3 4 5 6 7 8 9 I c p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","388":"J D E F A B C K L G M N O d e f g h i j k l m n o"},E:{"132":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"132":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"132":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"132":"LC"},I:{"132":"aB I H MC NC OC PC hB QC RC"},J:{"132":"D A"},K:{"132":"A B C Q YB gB ZB"},L:{"132":"H"},M:{"132":"P"},N:{"132":"A B"},O:{"132":"SC"},P:{"132":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"132":"cC"},R:{"132":"dC"},S:{"132":"eC"}},B:6,C:"DNSSEC and DANE"};


/***/ }),

/***/ 3481:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","164":"F A","260":"B"},B:{"1":"N O R S T U V W X Y Z a P b H","260":"C K L G M"},C:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E lB mB","516":"F A B C K L G M N O d e f g h i j k l m n o p"},D:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g"},E:{"1":"J A B C qB tB fB YB","2":"I c K L G pB eB ZB uB vB wB","1028":"D E F rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B YB gB 1B"},G:{"1":"7B 8B 9B AC BC CC DC","2":"eB 2B hB 3B 4B EC FC GC HC IC JC KC","1028":"E 5B 6B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"16":"D","1028":"A"},K:{"1":"Q ZB","16":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"164":"A","260":"B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"Do Not Track API"};


/***/ }),

/***/ 88864:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m"},E:{"1":"E F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"document.currentScript"};


/***/ }),

/***/ 93781:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","16":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","16":"F"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:7,C:"document.evaluate & XPath"};


/***/ }),

/***/ 24147:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","16":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB yB zB 0B YB gB 1B ZB","16":"F xB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B","16":"hB 3B 4B"},H:{"2":"LC"},I:{"1":"H PC hB QC RC","2":"aB I MC NC OC"},J:{"1":"A","2":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"2":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:7,C:"Document.execCommand()"};


/***/ }),

/***/ 39985:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V","132":"W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V","132":"W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB xB yB zB 0B YB gB 1B ZB","132":"QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","132":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","132":"Q"},L:{"132":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Document Policy"};


/***/ }),

/***/ 55988:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","16":"C K"},C:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"document.scrollingElement"};


/***/ }),

/***/ 2001:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB","16":"c"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","2":"F xB yB zB 0B"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"1":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"document.head"};


/***/ }),

/***/ 64198:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"N O R S T U V W X Y Z a P b H","2":"C K L G M"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"AB BB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x xB yB zB 0B YB gB 1B ZB","194":"y"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I TC"},Q:{"194":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"DOM manipulation convenience methods"};


/***/ }),

/***/ 3563:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"iB","8":"J D E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Document Object Model Range"};


/***/ }),

/***/ 38057:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"DOMContentLoaded"};


/***/ }),

/***/ 54275:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L G M N O d e f g h i j"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB","16":"c"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","16":"F B xB yB zB 0B YB gB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB 3B 4B"},H:{"16":"LC"},I:{"1":"I H PC hB QC RC","16":"aB MC NC OC"},J:{"16":"D A"},K:{"1":"Q","16":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"16":"A B"},O:{"16":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"DOMFocusIn & DOMFocusOut events"};


/***/ }),

/***/ 31943:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","132":"A B"},B:{"132":"C K L G M N O","1028":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q lB mB","1028":"OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2564":"0 1 2 3 4 5 6 r s t u v w x y z","3076":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB"},D:{"16":"I c J D","132":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB","388":"E","1028":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"16":"I pB eB","132":"c J D E F A qB rB sB tB fB","1028":"B C K L G YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","132":"0 1 2 3 4 5 G M N O d e f g h i j k l m n o p q r s t u v w x y z","1028":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"16":"eB 2B hB","132":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"132":"I PC hB QC RC","292":"aB MC NC OC","1028":"H"},J:{"16":"D","132":"A"},K:{"2":"A B C YB gB ZB","1028":"Q"},L:{"1028":"H"},M:{"1028":"P"},N:{"132":"A B"},O:{"132":"SC"},P:{"132":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"132":"cC"},R:{"132":"dC"},S:{"2564":"eC"}},B:4,C:"DOMMatrix"};


/***/ }),

/***/ 49291:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Download attribute"};


/***/ }),

/***/ 625:
/***/ ((module) => {

module.exports={A:{A:{"644":"J D E F iB","772":"A B"},B:{"1":"O R S T U V W X Y Z a P b H","260":"C K L G M N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","8":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","8":"F B xB yB zB 0B YB gB 1B"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","1025":"H"},J:{"2":"D A"},K:{"1":"ZB","8":"A B C YB gB","1025":"Q"},L:{"1025":"H"},M:{"2":"P"},N:{"1":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"Drag and Drop"};


/***/ }),

/***/ 54805:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"G M N O R S T U V W X Y Z a P b H","2":"C K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"2":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Element.closest()"};


/***/ }),

/***/ 25808:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","16":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","16":"F xB yB zB 0B"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"1":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"C Q ZB","16":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"document.elementFromPoint()"};


/***/ }),

/***/ 80674:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t lB mB"},D:{"1":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB"},E:{"1":"L G vB wB","2":"I c J D E F pB eB qB rB sB tB","132":"A B C K fB YB ZB uB"},F:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B","132":"9B AC BC CC DC EC FC GC HC IC JC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC VC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:5,C:"Scroll methods on elements (scroll, scrollTo, scrollBy)"};


/***/ }),

/***/ 21671:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","164":"B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s","132":"t u v w x y z"},E:{"1":"C K L G ZB uB vB wB","2":"I c J pB eB qB rB","164":"D E F A B sB tB fB YB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f xB yB zB 0B YB gB 1B ZB","132":"g h i j k l m"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"16":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:2,C:"Encrypted Media Extensions"};


/***/ }),

/***/ 51180:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","2":"iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"EOT - Embedded OpenType fonts"};


/***/ }),

/***/ 62719:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D iB","260":"F","1026":"E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","4":"jB aB lB mB","132":"I c J D E F A B C K L G M N O d e"},D:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","4":"I c J D E F A B C K L G M N O","132":"d e f g"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","4":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","4":"F B C xB yB zB 0B YB gB 1B","132":"ZB"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","4":"eB 2B hB 3B"},H:{"132":"LC"},I:{"1":"H QC RC","4":"aB MC NC OC","132":"PC hB","900":"I"},J:{"1":"A","4":"D"},K:{"1":"Q","4":"A B C YB gB","132":"ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"ECMAScript 5"};


/***/ }),

/***/ 54682:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","2":"C"},C:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","132":"0 1 2 3 4 5 6"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m xB yB zB 0B YB gB 1B ZB","132":"n o p q r s t"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"ES6 classes"};


/***/ }),

/***/ 6483:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"ES6 Generators"};


/***/ }),

/***/ 69972:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB lB mB","194":"LB"},D:{"1":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB"},F:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC VC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"JavaScript modules: dynamic import()"};


/***/ }),

/***/ 33513:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L","4097":"M N O","4290":"G"},C:{"1":"HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB lB mB","322":"CB DB EB FB GB bB"},D:{"1":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB","194":"HB"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB","3076":"fB"},F:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","194":"5"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B","3076":"AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC VC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"JavaScript modules via script tag"};


/***/ }),

/***/ 24785:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G lB mB","132":"M N O d e f g h i","260":"j k l m n o","516":"p"},D:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O","1028":"d e f g h i j k l m n o p q r"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","1028":"G M N O d e"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC","1028":"PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"ES6 Number"};


/***/ }),

/***/ 41908:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"String.prototype.includes"};


/***/ }),

/***/ 76634:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","388":"B"},B:{"257":"R S T U V W X Y Z a P b H","260":"C K L","769":"G M N O"},C:{"2":"jB aB I c lB mB","4":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB","257":"CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"I c J D E F A B C K L G M N O d e","4":"0 1 2 3 4 5 6 7 8 f g h i j k l m n o p q r s t u v w x y z","257":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D pB eB qB rB","4":"E F sB tB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","4":"G M N O d e f g h i j k l m n o p q r s t u v","257":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B","4":"E 5B 6B 7B 8B"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","4":"QC RC","257":"H"},J:{"2":"D","4":"A"},K:{"2":"A B C YB gB ZB","257":"Q"},L:{"257":"H"},M:{"257":"P"},N:{"2":"A","388":"B"},O:{"257":"SC"},P:{"4":"I","257":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"257":"cC"},R:{"4":"dC"},S:{"4":"eC"}},B:6,C:"ECMAScript 2015 (ES6)"};


/***/ }),

/***/ 99513:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","4":"F xB yB zB 0B"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"D A"},K:{"1":"C Q YB gB ZB","4":"A B"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Server-sent events"};


/***/ }),

/***/ 29486:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"L G uB vB wB","2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"ui-serif, ui-sans-serif, ui-monospace and ui-rounded values for font-family"};


/***/ }),

/***/ 6411:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y","2":"C K L G M N O","1025":"Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB lB mB","260":"TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"TB UB VB WB XB R S T U V W X Y","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB","132":"HB cB IB JB Q KB LB MB NB OB PB QB RB SB","1025":"Z a P b H dB nB oB"},E:{"2":"I c J D E F A B pB eB qB rB sB tB fB","772":"C K L G YB ZB uB vB wB"},F:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB","2":"0 1 2 3 4 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","132":"5 6 7 8 9 AB BB CB DB EB FB GB HB","1025":"UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC","772":"CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1025":"H"},M:{"260":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"YC ZC aC bC","2":"I TC UC VC","132":"WC XC fB"},Q:{"132":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"Feature Policy"};


/***/ }),

/***/ 80486:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","2":"C K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r lB mB","1025":"x","1218":"s t u v w"},D:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x","260":"y","772":"z"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k xB yB zB 0B YB gB 1B ZB","260":"l","772":"m"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Fetch"};


/***/ }),

/***/ 35953:
/***/ ((module) => {

module.exports={A:{A:{"16":"iB","132":"E F","388":"J D A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G","16":"M N O d"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB yB zB 0B YB gB 1B ZB","16":"F xB"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B"},H:{"388":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A","260":"B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"disabled attribute of the fieldset element"};


/***/ }),

/***/ 61730:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","260":"A B"},B:{"1":"R S T U V W X Y Z a P b H","260":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB","260":"I c J D E F A B C K L G M N O d e f g h i j k l mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c","260":"K L G M N O d e f g h i j k l m n o p q r s t u v","388":"J D E F A B C"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c pB eB","260":"J D E F rB sB tB","388":"qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B xB yB zB 0B","260":"C G M N O d e f g h i YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B","260":"E 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H RC","2":"MC NC OC","260":"QC","388":"aB I PC hB"},J:{"260":"A","388":"D"},K:{"1":"Q","2":"A B","260":"C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A","260":"B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"File API"};


/***/ }),

/***/ 92314:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","132":"A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB mB","2":"jB aB lB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","2":"F B xB yB zB 0B"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B"},H:{"2":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"A","2":"D"},K:{"1":"C Q YB gB ZB","2":"A B"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"FileReader API"};


/***/ }),

/***/ 80418:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F xB yB","16":"B zB 0B YB gB"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"C Q gB ZB","2":"A","16":"B YB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"FileReaderSync"};


/***/ }),

/***/ 13394:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","33":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"I c J D","33":"0 1 2 3 4 5 6 7 8 9 K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","36":"E F A B C"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","33":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D","33":"A"},K:{"2":"A B C Q YB gB ZB"},L:{"33":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I","33":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Filesystem & FileWriter API"};


/***/ }),

/***/ 37012:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"M N O R S T U V W X Y Z a P b H","2":"C K L G"},C:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","16":"2 3 4","388":"5 6 7 8 9 AB BB CB DB"},E:{"1":"K L G uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB","516":"B C YB ZB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","2":"MC NC OC","16":"aB I PC hB QC RC"},J:{"1":"A","2":"D"},K:{"1":"Q ZB","16":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","129":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:6,C:"FLAC audio format"};


/***/ }),

/***/ 2448:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"V W X Y Z a P b H","2":"C K L G M N O R S T U"},C:{"1":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB lB mB"},D:{"1":"V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U"},E:{"1":"G vB wB","2":"I c J D E F A B C K L pB eB qB rB sB tB fB YB ZB uB"},F:{"1":"SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB xB yB zB 0B YB gB 1B ZB"},G:{"1":"KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"bC","2":"I TC UC VC WC XC fB YC ZC aC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"gap property for Flexbox"};


/***/ }),

/***/ 48976:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","1028":"B","1316":"A"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","164":"jB aB I c J D E F A B C K L G M N O d e f lB mB","516":"g h i j k l"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"f g h i j k l m","164":"I c J D E F A B C K L G M N O d e"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","33":"D E rB sB","164":"I c J pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B C xB yB zB 0B YB gB 1B","33":"G M"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","33":"E 5B 6B","164":"eB 2B hB 3B 4B"},H:{"1":"LC"},I:{"1":"H QC RC","164":"aB I MC NC OC PC hB"},J:{"1":"A","164":"D"},K:{"1":"Q ZB","2":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","292":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS Flexible Box Layout Module"};


/***/ }),

/***/ 37107:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB lB mB"},D:{"1":"GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB"},E:{"1":"K L G uB vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB ZB"},F:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","2":"I TC UC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"display: flow-root"};


/***/ }),

/***/ 3162:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","2":"iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F xB yB zB 0B","16":"B YB gB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"2":"LC"},I:{"1":"I H PC hB QC RC","2":"MC NC OC","16":"aB"},J:{"1":"D A"},K:{"1":"C Q ZB","2":"A","16":"B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"focusin & focusout events"};


/***/ }),

/***/ 9962:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M","132":"N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"preventScroll support in focus"};


/***/ }),

/***/ 92562:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"H dB","2":"0 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","132":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b"},D:{"1":"EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB","260":"BB CB DB"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB","16":"F","132":"A tB fB"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B","132":"7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I TC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"132":"eC"}},B:5,C:"system-ui value for font-family"};


/***/ }),

/***/ 26538:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","33":"G M N O d e f g h i j k l m n o p q r","164":"I c J D E F A B C K L"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G","33":"0 1 2 3 4 5 f g h i j k l m n o p q r s t u v w x y z","292":"M N O d e"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"D E F pB eB rB sB","4":"I c J qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","33":"G M N O d e f g h i j k l m n o p q r s"},G:{"1":"8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E 5B 6B 7B","4":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB","33":"QC RC"},J:{"2":"D","33":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","33":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS font-feature-settings"};


/***/ }),

/***/ 88367:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h lB mB","194":"i j k l m n o p q r"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m","33":"n o p q"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"I c J pB eB qB rB","33":"D E F sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G xB yB zB 0B YB gB 1B ZB","33":"M N O d"},G:{"1":"DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B","33":"E 6B 7B 8B 9B AC BC CC"},H:{"2":"LC"},I:{"1":"H RC","2":"aB I MC NC OC PC hB","33":"QC"},J:{"2":"D","33":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS3 font-kerning"};


/***/ }),

/***/ 90792:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s lB mB","194":"t u v w x y"},D:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"CSS Font Loading"};


/***/ }),

/***/ 24934:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W","194":"X"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"@font-face metrics overrides"};


/***/ }),

/***/ 60647:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","194":"R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB"},D:{"2":"0 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C G M N O d e f g h i j k l m n xB yB zB 0B YB gB 1B ZB","194":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"258":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"194":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"CSS font-size-adjust"};


/***/ }),

/***/ 21936:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","676":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i lB mB","804":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"I","676":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"pB eB","676":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","676":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"804":"eC"}},B:7,C:"CSS font-smooth"};


/***/ }),

/***/ 88108:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","4":"F A B"},B:{"1":"N O R S T U V W X Y Z a P b H","4":"C K L G M"},C:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t lB mB","194":"0 1 u v w x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","4":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t"},E:{"1":"A B C K L G fB YB ZB uB vB wB","4":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","4":"G M N O d e f g"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","4":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","4":"aB I MC NC OC PC hB QC RC"},J:{"2":"D","4":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"4":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","4":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:4,C:"Font unicode-range subsetting"};


/***/ }),

/***/ 90534:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","130":"A B"},B:{"130":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","130":"I c J D E F A B C K L G M N O d e f g h","322":"i j k l m n o p q r"},D:{"2":"I c J D E F A B C K L G","130":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"D E F pB eB rB sB","130":"I c J qB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","130":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 5B 6B 7B","130":"2B hB 3B 4B"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","130":"H QC RC"},J:{"2":"D","130":"A"},K:{"2":"A B C YB gB ZB","130":"Q"},L:{"130":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"130":"SC"},P:{"130":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"130":"cC"},R:{"130":"dC"},S:{"1":"eC"}},B:5,C:"CSS font-variant-alternates"};


/***/ }),

/***/ 35187:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h lB mB","132":"i j k l m n o p q r"},D:{"1":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"132":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:4,C:"CSS font-variant-east-asian "};


/***/ }),

/***/ 85199:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r lB mB"},D:{"1":"AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w xB yB zB 0B YB gB 1B ZB"},G:{"1":"8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D","16":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I TC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:2,C:"CSS font-variant-numeric"};


/***/ }),

/***/ 90829:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","132":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G eB qB rB sB tB fB YB ZB uB vB wB","2":"pB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB yB zB 0B YB gB 1B ZB","2":"F xB"},G:{"1":"E hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","260":"eB 2B"},H:{"2":"LC"},I:{"1":"I H PC hB QC RC","2":"MC","4":"aB NC OC"},J:{"1":"A","4":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"@font-face Web fonts"};


/***/ }),

/***/ 32662:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"M N O R S T U V W X Y Z a P b H","2":"C K L G"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB","16":"c"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"1":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Form attribute"};


/***/ }),

/***/ 37913:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 0B YB gB 1B ZB","2":"F xB","16":"yB zB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"1":"LC"},I:{"1":"I H PC hB QC RC","2":"MC NC OC","16":"aB"},J:{"1":"A","2":"D"},K:{"1":"B C Q YB gB ZB","16":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Attributes for form submission"};


/***/ }),

/***/ 17644:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I pB eB","132":"c J D E F A qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB yB zB 0B YB gB 1B ZB","2":"F xB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"eB","132":"E 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"516":"LC"},I:{"1":"H RC","2":"aB MC NC OC","132":"I PC hB QC"},J:{"1":"A","132":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"260":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"132":"eC"}},B:1,C:"Form validation"};


/***/ }),

/***/ 68112:
/***/ ((module) => {

module.exports={A:{A:{"2":"iB","4":"A B","8":"J D E F"},B:{"1":"M N O R S T U V W X Y Z a P b H","4":"C K L G"},C:{"4":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","8":"jB aB lB mB"},D:{"1":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","4":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB"},E:{"4":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","8":"pB eB"},F:{"1":"F B C AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","4":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z"},G:{"2":"eB","4":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB","4":"QC RC"},J:{"2":"D","4":"A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"4":"P"},N:{"4":"A B"},O:{"1":"SC"},P:{"1":"WC XC fB YC ZC aC bC","4":"I TC UC VC"},Q:{"1":"cC"},R:{"4":"dC"},S:{"4":"eC"}},B:1,C:"HTML5 form features"};


/***/ }),

/***/ 99086:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","548":"B"},B:{"1":"R S T U V W X Y Z a P b H","516":"C K L G M N O"},C:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F lB mB","676":"0 1 2 3 4 A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","1700":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB"},D:{"1":"QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L","676":"G M N O d","804":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB"},E:{"2":"I c pB eB","676":"qB","804":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB"},F:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B C xB yB zB 0B YB gB 1B","804":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC","2052":"DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D","292":"A"},K:{"2":"A B C Q YB gB ZB"},L:{"804":"H"},M:{"1":"P"},N:{"2":"A","548":"B"},O:{"804":"SC"},P:{"1":"fB YC ZC aC bC","804":"I TC UC VC WC XC"},Q:{"804":"cC"},R:{"804":"dC"},S:{"1":"eC"}},B:1,C:"Full Screen API"};


/***/ }),

/***/ 66952:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e","33":"f g h i"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"Gamepad API"};


/***/ }),

/***/ 64161:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"iB","8":"J D E"},B:{"1":"C K L G M N O","129":"R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB lB mB","8":"jB aB","129":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","4":"I","129":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J D E F B C K L G qB rB sB tB fB YB ZB uB vB wB","8":"I pB eB","129":"A"},F:{"1":"B C M N O d e f g h i j k l m n o p q r s t u v w 0B YB gB 1B ZB","2":"F G xB","8":"yB zB","129":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B","129":"9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I MC NC OC PC hB QC RC","129":"H"},J:{"1":"D A"},K:{"1":"B C YB gB ZB","8":"A","129":"Q"},L:{"129":"H"},M:{"129":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I","129":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"129":"cC"},R:{"129":"dC"},S:{"1":"eC"}},B:2,C:"Geolocation"};


/***/ }),

/***/ 73165:
/***/ ((module) => {

module.exports={A:{A:{"644":"J D iB","2049":"F A B","2692":"E"},B:{"1":"R S T U V W X Y Z a P b H","2049":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB","260":"I c J D E F A B","1156":"aB","1284":"lB","1796":"mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 0B YB gB 1B ZB","16":"F xB","132":"yB zB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"1":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","132":"A"},L:{"1":"H"},M:{"1":"P"},N:{"2049":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"Element.getBoundingClientRect()"};


/***/ }),

/***/ 43665:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB","132":"aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","260":"I c J D E F A"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","260":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 0B YB gB 1B ZB","260":"F xB yB zB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","260":"eB 2B hB"},H:{"260":"LC"},I:{"1":"I H PC hB QC RC","260":"aB MC NC OC"},J:{"1":"A","260":"D"},K:{"1":"B C Q YB gB ZB","260":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"getComputedStyle"};


/***/ }),

/***/ 85337:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"iB","8":"J D E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","8":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"getElementsByClassName"};


/***/ }),

/***/ 26199:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","33":"B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A","33":"B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"crypto.getRandomValues()"};


/***/ }),

/***/ 49966:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB","194":"GB bB HB cB IB JB Q KB LB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"Gyroscope"};


/***/ }),

/***/ 89006:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"G M N O R S T U V W X Y Z a P b H","2":"C K L"},C:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u"},E:{"2":"I c J D pB eB qB rB sB","129":"B C K L G fB YB ZB uB vB wB","194":"E F A tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h xB yB zB 0B YB gB 1B ZB"},G:{"2":"eB 2B hB 3B 4B 5B","129":"AC BC CC DC EC FC GC HC IC JC KC","194":"E 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"navigator.hardwareConcurrency"};


/***/ }),

/***/ 62563:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","8":"J D iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB mB","8":"jB aB lB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","8":"I"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","8":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 0B YB gB 1B ZB","8":"F xB yB zB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB"},H:{"2":"LC"},I:{"1":"aB I H NC OC PC hB QC RC","2":"MC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","8":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Hashchange event"};


/***/ }),

/***/ 56666:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A pB eB qB rB sB tB fB","130":"B C K L G YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC","130":"BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"HEIF/ISO Base Media File Format"};


/***/ }),

/***/ 64206:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","132":"B"},B:{"2":"R S T U V W X Y Z a P b H","132":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"K L G uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB","516":"B C YB ZB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","258":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","258":"Q"},L:{"258":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I","258":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"HEVC/H.265 video format"};


/***/ }),

/***/ 6027:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","2":"F B xB yB zB 0B"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"1":"LC"},I:{"1":"I H PC hB QC RC","2":"aB MC NC OC"},J:{"1":"A","2":"D"},K:{"1":"C Q YB gB ZB","2":"A B"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"hidden attribute"};


/***/ }),

/***/ 88772:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d","33":"e f g h"},E:{"1":"E F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"High Resolution Time API"};


/***/ }),

/***/ 81648:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I pB eB","4":"c qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB gB 1B ZB","2":"F B xB yB zB 0B YB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B","4":"hB"},H:{"2":"LC"},I:{"1":"H NC OC hB QC RC","2":"aB I MC PC"},J:{"1":"D A"},K:{"1":"C Q YB gB ZB","2":"A B"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Session history management"};


/***/ }),

/***/ 64940:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"eB 2B hB 3B","129":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC","257":"NC OC"},J:{"1":"A","16":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"516":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"16":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:4,C:"HTML Media Capture"};


/***/ }),

/***/ 72753:
/***/ ((module) => {

module.exports={A:{A:{"2":"iB","8":"J D E","260":"F A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB","132":"aB lB mB","260":"I c J D E F A B C K L G M N O d e"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c","260":"J D E F A B C K L G M N O d e f g h i j"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","132":"I pB eB","260":"c J qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","132":"F B xB yB zB 0B","260":"C YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","132":"eB","260":"2B hB 3B 4B"},H:{"132":"LC"},I:{"1":"H QC RC","132":"MC","260":"aB I NC OC PC hB"},J:{"260":"D A"},K:{"1":"Q","132":"A","260":"B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"260":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"HTML5 semantic elements"};


/***/ }),

/***/ 15638:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O","2":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:7,C:"HTTP Live Streaming (HLS)"};


/***/ }),

/***/ 16824:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","132":"B"},B:{"1":"C K L G M N O","513":"R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t lB mB","513":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 z","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y","513":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB","260":"F A tB fB"},F:{"1":"m n o p q r s t u v","2":"F B C G M N O d e f g h i j k l xB yB zB 0B YB gB 1B ZB","513":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","513":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","513":"Q"},L:{"513":"H"},M:{"513":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I","513":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"513":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"HTTP/2 protocol"};


/***/ }),

/***/ 70549:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"Y Z a P b H","2":"C K L G M N O","322":"R S T U V","578":"W X"},C:{"1":"Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB lB mB","194":"RB SB TB UB VB WB XB R S T kB U V W X Y"},D:{"1":"Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","322":"R S T U V","578":"W X"},E:{"2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB uB","1090":"L G vB wB"},F:{"1":"TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB xB yB zB 0B YB gB 1B ZB","578":"SB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC","66":"JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"194":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"bC","2":"I TC UC VC WC XC fB YC ZC aC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"HTTP/3 protocol"};


/***/ }),

/***/ 76002:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M lB mB","4":"N O d e f g h i j k l"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B"},H:{"2":"LC"},I:{"1":"aB I H NC OC PC hB QC RC","2":"MC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"sandbox attribute for iframes"};


/***/ }),

/***/ 82891:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","66":"e f g h i j k"},E:{"2":"I c J E F A B C K L G pB eB qB rB tB fB YB ZB uB vB wB","130":"D sB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","130":"5B"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"seamless attribute for iframes"};


/***/ }),

/***/ 72100:
/***/ ((module) => {

module.exports={A:{A:{"2":"iB","8":"J D E F A B"},B:{"1":"R S T U V W X Y Z a P b H","8":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB","8":"aB I c J D E F A B C K L G M N O d e f g h i lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K","8":"L G M N O d"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"pB eB","8":"I c qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B xB yB zB 0B","8":"C YB gB 1B ZB"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB","8":"2B hB 3B"},H:{"2":"LC"},I:{"1":"H QC RC","8":"aB I MC NC OC PC hB"},J:{"1":"A","8":"D"},K:{"1":"Q","2":"A B","8":"C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"8":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"srcdoc attribute for iframes"};


/***/ }),

/***/ 16659:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","322":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s lB mB","194":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB","322":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x xB yB zB 0B YB gB 1B ZB","322":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"322":"cC"},R:{"1":"dC"},S:{"194":"eC"}},B:5,C:"ImageCapture API"};


/***/ }),

/***/ 54606:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","161":"B"},B:{"2":"R S T U V W X Y Z a P b H","161":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A","161":"B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"Input Method Editor API"};


/***/ }),

/***/ 35720:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"naturalWidth & naturalHeight image properties"};


/***/ }),

/***/ 64548:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"a P b H","2":"C K L G M N O","194":"R S T U V W X Y Z"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB","194":"TB UB VB WB XB R S T U V W X Y Z"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB xB yB zB 0B YB gB 1B ZB","194":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Import maps"};


/***/ }),

/***/ 72563:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","8":"A B"},B:{"1":"R","2":"S T U V W X Y Z a P b H","8":"C K L G M N O"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n lB mB","8":"o p EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","72":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n S T U V W X Y Z a P b H dB nB oB","66":"o p q r s","72":"t"},E:{"2":"I c pB eB qB","8":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB","2":"F B C G M MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","66":"N O d e f","72":"g"},G:{"2":"eB 2B hB 3B 4B","8":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"8":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC","2":"aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"HTML Imports"};


/***/ }),

/***/ 66518:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB mB","2":"jB aB","16":"lB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F B xB yB zB 0B YB gB"},G:{"1":"EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"2":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"indeterminate checkbox"};


/***/ }),

/***/ 78797:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","132":"A B"},B:{"1":"R S T U V W X Y Z a P b H","132":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","33":"A B C K L G","36":"I c J D E F"},D:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"A","8":"I c J D E F","33":"h","36":"B C K L G M N O d e f g"},E:{"1":"A B C K L G fB YB ZB uB wB","8":"I c J D pB eB qB rB","260":"E F sB tB","516":"vB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F xB yB","8":"B C zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC","8":"eB 2B hB 3B 4B 5B","260":"E 6B 7B 8B","516":"KC"},H:{"2":"LC"},I:{"1":"H QC RC","8":"aB I MC NC OC PC hB"},J:{"1":"A","8":"D"},K:{"1":"Q","2":"A","8":"B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"IndexedDB"};


/***/ }),

/***/ 11395:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","132":"2 3 4","260":"5 6 7 8"},D:{"1":"GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","132":"6 7 8 9","260":"AB BB CB DB EB FB"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s xB yB zB 0B YB gB 1B ZB","132":"t u v w","260":"0 1 2 x y z"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B","16":"9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","2":"I","260":"TC UC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"260":"eC"}},B:4,C:"IndexedDB 2.0"};


/***/ }),

/***/ 7354:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","4":"iB","132":"J D"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","36":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS inline-block"};


/***/ }),

/***/ 40674:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G eB qB rB sB tB fB YB ZB uB vB wB","16":"pB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","16":"F"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"1":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"HTMLElement.innerText"};


/***/ }),

/***/ 60328:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A iB","132":"B"},B:{"132":"C K L G M N O","260":"R S T U V W X Y Z a P b H"},C:{"1":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n lB mB","516":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"N O d e f g h i j k","2":"I c J D E F A B C K L G M","132":"l m n o p q r s t u v w x y","260":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"J qB rB","2":"I c pB eB","2052":"D E F A B C K L G sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"eB 2B hB","1025":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1025":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2052":"A B"},O:{"1025":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"260":"cC"},R:{"1":"dC"},S:{"516":"eC"}},B:1,C:"autocomplete attribute: on & off values"};


/***/ }),

/***/ 24411:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","2":"C K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d"},E:{"1":"K L G ZB uB vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","2":"F G M xB yB zB 0B"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC","129":"EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:1,C:"Color input type"};


/***/ }),

/***/ 41858:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","132":"C"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB lB mB","1090":"BB CB DB EB","2052":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d","2052":"e f g h i"},E:{"2":"I c J D E F A B C K L pB eB qB rB sB tB fB YB ZB uB","4100":"G vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"eB 2B hB","260":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB MC NC OC","514":"I PC hB"},J:{"1":"A","2":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2052":"eC"}},B:1,C:"Date and time input types"};


/***/ }),

/***/ 65488:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H PC hB QC RC","132":"MC NC OC"},J:{"1":"A","132":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Email, telephone & URL input types"};


/***/ }),

/***/ 56301:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","2561":"A B","2692":"F"},B:{"1":"R S T U V W X Y Z a P b H","2561":"C K L G M N O"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","16":"jB","1537":"0 1 2 3 4 5 6 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z mB","1796":"aB lB"},D:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L","1025":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB","1537":"G M N O d e f g h i j k l m n o p q r s"},E:{"1":"L G uB vB wB","16":"I c J pB eB","1025":"D E F A B C rB sB tB fB YB","1537":"qB","4097":"K ZB"},F:{"1":"AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","16":"F B C xB yB zB 0B YB gB","260":"1B","1025":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z","1537":"G M N O d e f"},G:{"16":"eB 2B hB","1025":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","1537":"3B 4B 5B"},H:{"2":"LC"},I:{"16":"MC NC","1025":"H RC","1537":"aB I OC PC hB QC"},J:{"1025":"A","1537":"D"},K:{"1":"A B C YB gB ZB","1025":"Q"},L:{"1":"H"},M:{"1537":"P"},N:{"2561":"A B"},O:{"1537":"SC"},P:{"1025":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1025":"cC"},R:{"1025":"dC"},S:{"1537":"eC"}},B:1,C:"input event"};


/***/ }),

/***/ 3024:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","132":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I","16":"c J D E f g h i j","132":"F A B C K L G M N O d e"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c pB eB qB","132":"J D E F A B rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"2":"4B 5B","132":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","514":"eB 2B hB 3B"},H:{"2":"LC"},I:{"2":"MC NC OC","260":"aB I PC hB","514":"H QC RC"},J:{"132":"A","260":"D"},K:{"2":"A B C YB gB ZB","514":"Q"},L:{"260":"H"},M:{"2":"P"},N:{"514":"A","1028":"B"},O:{"2":"SC"},P:{"260":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"260":"cC"},R:{"260":"dC"},S:{"1":"eC"}},B:1,C:"accept attribute for file input"};


/***/ }),

/***/ 77213:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","2":"C K"},C:{"1":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Directory selection from file input"};


/***/ }),

/***/ 64907:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB mB","2":"jB aB lB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 0B YB gB 1B ZB","2":"F xB yB zB"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B"},H:{"130":"LC"},I:{"130":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"130":"A B C Q YB gB ZB"},L:{"132":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"130":"SC"},P:{"130":"I","132":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"132":"cC"},R:{"132":"dC"},S:{"2":"eC"}},B:1,C:"Multiple file selection"};


/***/ }),

/***/ 75178:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"jB aB I c J D E F A B C K L G M lB mB","4":"N O d e","194":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB","66":"EB FB GB bB HB cB IB JB Q KB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","66":"1 2 3 4 5 6 7 8 9 AB"},G:{"1":"EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"XC fB YC ZC aC bC","2":"I TC UC VC WC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"194":"eC"}},B:1,C:"inputmode attribute"};


/***/ }),

/***/ 90453:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"N O R S T U V W X Y Z a P b H","2":"C K L G M"},C:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:1,C:"Minimum length attribute for input fields"};


/***/ }),

/***/ 90754:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","129":"A B"},B:{"1":"R S T U V W X Y Z a P b H","129":"C K","1025":"L G M N O"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB","513":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"388":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB MC NC OC","388":"I H PC hB QC RC"},J:{"2":"D","388":"A"},K:{"1":"A B C YB gB ZB","388":"Q"},L:{"388":"H"},M:{"641":"P"},N:{"388":"A B"},O:{"388":"SC"},P:{"388":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"388":"cC"},R:{"388":"dC"},S:{"513":"eC"}},B:1,C:"Number input type"};


/***/ }),

/***/ 70620:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I pB eB","16":"c","388":"J D E F A qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB","388":"E 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H RC","2":"aB I MC NC OC PC hB QC"},J:{"1":"A","2":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Pattern attribute for input fields"};


/***/ }),

/***/ 45840:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","132":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB gB 1B ZB","2":"F xB yB zB 0B","132":"B YB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB H MC NC OC hB QC RC","4":"I PC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"input placeholder attribute"};


/***/ }),

/***/ 19303:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"2":"LC"},I:{"1":"H hB QC RC","4":"aB I MC NC OC PC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Range input type"};


/***/ }),

/***/ 86763:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","129":"A B"},B:{"1":"R S T U V W X Y Z a P b H","129":"C K L G M N O"},C:{"2":"jB aB lB mB","129":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L f g h i j","129":"G M N O d e"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F xB yB zB 0B","16":"B YB gB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB"},H:{"129":"LC"},I:{"1":"H QC RC","16":"MC NC","129":"aB I OC PC hB"},J:{"1":"D","129":"A"},K:{"1":"C Q","2":"A","16":"B YB gB","129":"ZB"},L:{"1":"H"},M:{"129":"P"},N:{"129":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"129":"eC"}},B:1,C:"Search input type"};


/***/ }),

/***/ 48804:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 0B YB gB 1B ZB","16":"F xB yB zB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"2":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Selection controls for input & textarea"};


/***/ }),

/***/ 36404:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","16":"F"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Element.insertAdjacentElement() & Element.insertAdjacentText()"};


/***/ }),

/***/ 20379:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","16":"iB","132":"J D E F"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB yB zB 0B YB gB 1B ZB","16":"F xB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"1":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"Element.insertAdjacentHTML()"};


/***/ }),

/***/ 558:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:6,C:"Internationalization API"};


/***/ }),

/***/ 16414:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"YC ZC aC bC","2":"I TC UC VC WC XC fB"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"IntersectionObserver V2"};


/***/ }),

/***/ 93717:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"M N O","2":"C K L","516":"G","1025":"R S T U V W X Y Z a P b H"},C:{"1":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","194":"AB BB CB"},D:{"1":"GB bB HB cB IB JB Q","2":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","516":"9 AB BB CB DB EB FB","1025":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"K L G ZB uB vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB"},F:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v xB yB zB 0B YB gB 1B ZB","516":"0 1 2 w x y z","1025":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","1025":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","1025":"Q"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"516":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","2":"I","516":"TC UC"},Q:{"1025":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"IntersectionObserver"};


/***/ }),

/***/ 14130:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N","130":"O"},C:{"1":"GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB lB mB"},D:{"1":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB"},E:{"1":"K L G uB vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB ZB"},F:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC VC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"Intl.PluralRules API"};


/***/ }),

/***/ 56835:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","1537":"R S T U V W X Y Z a P b H"},C:{"2":"jB","932":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB lB mB","2308":"LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"I c J D E F A B C K L G M N O d e f","545":"0 1 2 3 g h i j k l m n o p q r s t u v w x y z","1537":"4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J pB eB qB","516":"B C K L G YB ZB uB vB wB","548":"F A tB fB","676":"D E rB sB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","513":"s","545":"G M N O d e f g h i j k l m n o p q","1537":"0 1 2 3 4 5 6 7 8 9 r t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"eB 2B hB 3B 4B","516":"JC KC","548":"7B 8B 9B AC BC CC DC EC FC GC HC IC","676":"E 5B 6B"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","545":"QC RC","1537":"H"},J:{"2":"D","545":"A"},K:{"2":"A B C YB gB ZB","1537":"Q"},L:{"1537":"H"},M:{"2308":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"545":"I","1537":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"545":"cC"},R:{"1537":"dC"},S:{"932":"eC"}},B:5,C:"Intrinsic & Extrinsic Sizing"};


/***/ }),

/***/ 99137:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I pB eB","129":"c qB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"JPEG 2000 image format"};


/***/ }),

/***/ 58083:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P","578":"b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a lB mB","322":"P b H dB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P","194":"b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB xB yB zB 0B YB gB 1B ZB","194":"WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"JPEG XL image format"};


/***/ }),

/***/ 70525:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O","2":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"1":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"JPEG XR image format"};


/***/ }),

/***/ 91191:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB lB mB"},D:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC VC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"Lookbehind in JS regular expressions"};


/***/ }),

/***/ 92815:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D iB","129":"E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"JSON parsing"};


/***/ }),

/***/ 37001:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G","132":"M N O"},C:{"1":"AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB","132":"FB GB bB"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB","132":"fB"},F:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","132":"2 3 4"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B","132":"AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"132":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC","132":"VC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"132":"eC"}},B:5,C:"CSS justify-content: space-evenly"};


/***/ }),

/***/ 82612:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"O R S T U V W X Y Z a P b H","2":"C K L G M N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"MC NC OC","132":"aB I PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:7,C:"High-quality kerning pairs & ligatures"};


/***/ }),

/***/ 7891:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","16":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B YB gB 1B","16":"C"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"Q ZB","2":"A B YB gB","16":"C"},L:{"1":"H"},M:{"130":"P"},N:{"130":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:7,C:"KeyboardEvent.charCode"};


/***/ }),

/***/ 39598:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v lB mB"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"0 1 2 3 4 5"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m xB yB zB 0B YB gB 1B ZB","194":"n o p q r s"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"194":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I","194":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"194":"dC"},S:{"1":"eC"}},B:5,C:"KeyboardEvent.code"};


/***/ }),

/***/ 87626:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B G M xB yB zB 0B YB gB 1B","16":"C"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q ZB","2":"A B YB gB","16":"C"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"KeyboardEvent.getModifierState()"};


/***/ }),

/***/ 98685:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","260":"F A B"},B:{"1":"R S T U V W X Y Z a P b H","260":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g lB mB","132":"h i j k l m"},D:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B G M N O d e f g h i j k l m n o p q r s t u v xB yB zB 0B YB gB 1B","16":"C"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"1":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q ZB","2":"A B YB gB","16":"C"},L:{"1":"H"},M:{"1":"P"},N:{"260":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"2":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:5,C:"KeyboardEvent.key"};


/***/ }),

/***/ 90035:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c J D E F A B C K L G M N O d e f g h i j k l m n"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","16":"J pB eB","132":"I c qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B YB gB 1B","16":"C","132":"G M"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB","132":"3B 4B 5B"},H:{"2":"LC"},I:{"1":"H QC RC","16":"MC NC","132":"aB I OC PC hB"},J:{"132":"D A"},K:{"1":"Q ZB","2":"A B YB gB","16":"C"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"KeyboardEvent.location"};


/***/ }),

/***/ 82586:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB","16":"c"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB yB zB 0B YB gB 1B ZB","16":"F xB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB","16":"MC NC","132":"QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"132":"H"},M:{"132":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"2":"I","132":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"132":"dC"},S:{"1":"eC"}},B:7,C:"KeyboardEvent.which"};


/***/ }),

/***/ 23230:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"C K L G M N O","2":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"1":"B","2":"A"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Resource Hints: Lazyload"};


/***/ }),

/***/ 51884:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","2052":"B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","194":"0 1 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O","322":"d e f g h i j k l m n o p q r s t u v w x y","516":"0 1 2 3 4 5 6 z"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB","1028":"A fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","322":"G M N O d e f g h i j k l","516":"m n o p q r s t"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B","1028":"9B AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","516":"I"},Q:{"1":"cC"},R:{"516":"dC"},S:{"1":"eC"}},B:6,C:"let"};


/***/ }),

/***/ 42789:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"DC EC FC GC HC IC JC KC","130":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC"},H:{"130":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D","130":"A"},K:{"1":"Q","130":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"130":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"PNG favicons"};


/***/ }),

/***/ 4506:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R","1537":"S T U V W X Y Z a P b H"},C:{"2":"jB aB lB mB","260":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y","513":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R","1537":"S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"2 3 4 5 6 7 8 9 AB BB","2":"0 1 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z CB DB EB FB GB HB IB JB Q KB LB xB yB zB 0B YB gB 1B ZB","1537":"MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"DC EC FC GC HC IC JC KC","130":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC"},H:{"130":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D","130":"A"},K:{"2":"Q","130":"A B C YB gB ZB"},L:{"1537":"H"},M:{"2":"P"},N:{"130":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC","1537":"aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"513":"eC"}},B:1,C:"SVG favicons"};


/***/ }),

/***/ 66458:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E iB","132":"F"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"jB aB","260":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"16":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"16":"aB I H MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"16":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"16":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","16":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"Resource Hints: dns-prefetch"};


/***/ }),

/***/ 36767:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"XC fB YC ZC aC bC","2":"I TC UC VC WC"},Q:{"16":"cC"},R:{"16":"dC"},S:{"2":"eC"}},B:1,C:"Resource Hints: modulepreload"};


/***/ }),

/***/ 67578:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L","260":"G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","129":"x"},D:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q xB yB zB 0B YB gB 1B ZB"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"16":"P"},N:{"2":"A B"},O:{"16":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"Resource Hints: preconnect"};


/***/ }),

/***/ 31145:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D"},E:{"2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB","194":"L G uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC","194":"IC JC KC"},H:{"2":"LC"},I:{"1":"I H QC RC","2":"aB MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"Resource Hints: prefetch"};


/***/ }),

/***/ 7015:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M","1028":"N O"},C:{"1":"W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB lB mB","132":"EB","578":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V"},D:{"1":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB","322":"B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u xB yB zB 0B YB gB 1B ZB"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC","322":"BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"Resource Hints: preload"};


/***/ }),

/***/ 74778:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"1":"B","2":"A"},O:{"2":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"Resource Hints: prerender"};


/***/ }),

/***/ 11394:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB lB mB","132":"UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB","66":"UB VB"},E:{"2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB","322":"L G uB vB wB"},F:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB xB yB zB 0B YB gB 1B ZB","66":"IB JB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC","322":"IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"132":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"ZC aC bC","2":"I TC UC VC WC XC fB YC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"Lazy loading via attribute for images & iframes"};


/***/ }),

/***/ 89380:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","16":"iB","132":"J D E F A"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","132":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c J D E F A B C K L G M N O d e f g h"},E:{"1":"A B C K L G fB YB ZB uB vB wB","132":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F B C xB yB zB 0B YB gB 1B","132":"ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","132":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"132":"LC"},I:{"1":"H QC RC","132":"aB I MC NC OC PC hB"},J:{"132":"D A"},K:{"1":"Q","16":"A B C YB gB","132":"ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","132":"A"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","132":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"4":"eC"}},B:6,C:"localeCompare()"};


/***/ }),

/***/ 19271:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB","194":"GB bB HB cB IB JB Q KB LB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"194":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"Magnetometer"};


/***/ }),

/***/ 71184:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","36":"F A B"},B:{"1":"G M N O R S T U V W X Y Z a P b H","36":"C K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB","36":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","36":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r"},E:{"1":"E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I pB eB","36":"c J D qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B xB yB zB 0B YB","36":"C G M N O d e gB 1B ZB"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB","36":"2B hB 3B 4B 5B"},H:{"2":"LC"},I:{"1":"H","2":"MC","36":"aB I NC OC PC hB QC RC"},J:{"36":"D A"},K:{"1":"Q","2":"A B","36":"C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"36":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","36":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"matches() DOM method"};


/***/ }),

/***/ 66743:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B C xB yB zB 0B YB gB 1B"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"1":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"A","2":"D"},K:{"1":"Q ZB","2":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"matchMedia"};


/***/ }),

/***/ 35717:
/***/ ((module) => {

module.exports={A:{A:{"2":"F A B iB","8":"J D E"},B:{"2":"C K L G M N O","8":"R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","129":"jB aB lB mB"},D:{"1":"i","8":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","260":"I c J D E F pB eB qB rB sB tB"},F:{"2":"F","4":"B C xB yB zB 0B YB gB 1B ZB","8":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","8":"eB 2B hB"},H:{"8":"LC"},I:{"8":"aB I H MC NC OC PC hB QC RC"},J:{"1":"A","8":"D"},K:{"8":"A B C Q YB gB ZB"},L:{"8":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"4":"SC"},P:{"8":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"8":"cC"},R:{"8":"dC"},S:{"1":"eC"}},B:2,C:"MathML"};


/***/ }),

/***/ 16924:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","16":"iB","900":"J D E F"},B:{"1":"R S T U V W X Y Z a P b H","1025":"C K L G M N O"},C:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","900":"jB aB lB mB","1025":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"c pB","900":"I eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F","132":"B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"2B hB 3B 4B 5B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB","2052":"E 6B"},H:{"132":"LC"},I:{"1":"aB I OC PC hB QC RC","16":"MC NC","4097":"H"},J:{"1":"D A"},K:{"132":"A B C YB gB ZB","4097":"Q"},L:{"4097":"H"},M:{"4097":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"4097":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1025":"eC"}},B:1,C:"maxlength attribute for input and textarea elements"};


/***/ }),

/***/ 23924:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O","16":"R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L lB mB"},D:{"1":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r","2":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H","16":"dB nB oB"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I c pB eB"},F:{"1":"B C G M N O d e f g h i yB zB 0B YB gB 1B ZB","2":"0 1 2 3 4 5 6 7 8 9 F j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB"},H:{"16":"LC"},I:{"1":"I H PC hB QC RC","16":"aB MC NC OC"},J:{"16":"D A"},K:{"1":"C Q ZB","16":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"16":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Media attribute"};


/***/ }),

/***/ 6277:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","132":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r lB mB","132":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"I c J D E F A B C K L G M N","132":"0 1 2 3 4 5 6 7 8 9 O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c pB eB qB","132":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","132":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"eB 2B hB 3B 4B 5B","132":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","132":"H QC RC"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","132":"Q"},L:{"132":"H"},M:{"132":"P"},N:{"132":"A B"},O:{"2":"SC"},P:{"2":"I TC","132":"UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"132":"eC"}},B:2,C:"Media Fragments"};


/***/ }),

/***/ 94413:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB"},E:{"2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB","16":"L G uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"Media Session API"};


/***/ }),

/***/ 84279:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","260":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","324":"9 AB BB CB DB EB FB GB bB HB cB"},E:{"2":"I c J D E F A pB eB qB rB sB tB fB","132":"B C K L G YB ZB uB vB wB"},F:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t xB yB zB 0B YB gB 1B ZB","324":"0 1 2 3 4 5 u v w x y z"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"260":"P"},N:{"2":"A B"},O:{"132":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I","132":"TC UC VC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"260":"eC"}},B:5,C:"Media Capture from DOM Elements API"};


/***/ }),

/***/ 55997:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"5 6"},E:{"1":"G vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB","322":"K L ZB uB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r xB yB zB 0B YB gB 1B ZB","194":"s t"},G:{"1":"KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC","578":"DC EC FC GC HC IC JC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:5,C:"MediaRecorder API"};


/***/ }),

/***/ 32348:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","132":"B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i lB mB","66":"j k l m n o p q r s t u v w x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M","33":"h i j k l m n o","66":"N O d e f g"},E:{"1":"E F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC","260":"FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H RC","2":"aB I MC NC OC PC hB QC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"XC fB YC ZC aC bC","2":"I TC UC VC WC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"Media Source Extensions"};


/***/ }),

/***/ 89056:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D lB mB","132":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V","450":"W X Y Z a P b H dB"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","66":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","66":"0 1 2 3 4 t u v w x y z"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"450":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Context menu item (menuitem element)"};


/***/ }),

/***/ 69895:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w","132":"SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","258":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB"},E:{"1":"G wB","2":"I c J D E F A B C K L pB eB qB rB sB tB fB YB ZB uB vB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"513":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I","16":"TC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"theme-color Meta Tag"};


/***/ }),

/***/ 44701:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","2":"F xB yB zB 0B"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"meter element"};


/***/ }),

/***/ 83250:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"Web MIDI API"};


/***/ }),

/***/ 55879:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","8":"J iB","129":"D","257":"E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"CSS min/max-width/height"};


/***/ }),

/***/ 59447:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","132":"I c J D E F A B C K L G M N O d e f lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","2":"MC NC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"MP3 audio format"};


/***/ }),

/***/ 374:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O","2":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","386":"f g"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"Dynamic Adaptive Streaming over HTTP (MPEG-DASH)"};


/***/ }),

/***/ 33463:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e lB mB","4":"f g h i j k l m n o p q r s"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G eB qB rB sB tB fB YB ZB uB vB wB","2":"pB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H QC RC","4":"aB I MC NC PC hB","132":"OC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"260":"P"},N:{"1":"A B"},O:{"4":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"MPEG-4/H.264 video format"};


/***/ }),

/***/ 19069:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB mB","2":"jB aB lB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS3 Multiple backgrounds"};


/***/ }),

/***/ 24233:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O","516":"R S T U V W X Y Z a P b H"},C:{"132":"AB BB CB DB EB FB GB bB HB cB IB JB Q","164":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","516":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"420":"0 1 2 3 4 5 6 7 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","516":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","132":"F tB","164":"D E sB","420":"I c J pB eB qB rB"},F:{"1":"C YB gB 1B ZB","2":"F B xB yB zB 0B","420":"G M N O d e f g h i j k l m n o p q r s t u","516":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","132":"7B 8B","164":"E 5B 6B","420":"eB 2B hB 3B 4B"},H:{"1":"LC"},I:{"420":"aB I MC NC OC PC hB QC RC","516":"H"},J:{"420":"D A"},K:{"1":"C YB gB ZB","2":"A B","516":"Q"},L:{"516":"H"},M:{"516":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","420":"I"},Q:{"132":"cC"},R:{"132":"dC"},S:{"164":"eC"}},B:4,C:"CSS3 Multiple column layout"};


/***/ }),

/***/ 90072:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","260":"F A B"},B:{"132":"R S T U V W X Y Z a P b H","260":"C K L G M N O"},C:{"2":"jB aB I c lB mB","260":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"16":"I c J D E F A B C K L","132":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"16":"pB eB","132":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"C 1B ZB","2":"F xB yB zB 0B","16":"B YB gB","132":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"16":"eB 2B","132":"E hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"16":"MC NC","132":"aB I H OC PC hB QC RC"},J:{"132":"D A"},K:{"1":"C ZB","2":"A","16":"B YB gB","132":"Q"},L:{"132":"H"},M:{"260":"P"},N:{"260":"A B"},O:{"132":"SC"},P:{"132":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"132":"cC"},R:{"132":"dC"},S:{"260":"eC"}},B:5,C:"Mutation events"};


/***/ }),

/***/ 98212:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E iB","8":"F A"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N","33":"O d e f g h i j k"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB","33":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B","33":"4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB MC NC OC","8":"I PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","8":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Mutation Observer"};


/***/ }),

/***/ 80611:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"iB","8":"J D"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","4":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Web Storage - name/value pairs"};


/***/ }),

/***/ 7576:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","194":"R S T U V W","260":"X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB","194":"TB UB VB WB XB R S T U V W","260":"X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB xB yB zB 0B YB gB 1B ZB","194":"IB JB Q KB LB MB NB OB PB QB","260":"RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"File System Access API"};


/***/ }),

/***/ 73272:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c","33":"J D E F A B C"},E:{"1":"E F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"I H PC hB QC RC","2":"aB MC NC OC"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"Navigation Timing API"};


/***/ }),

/***/ 56212:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"M N O R S T U V W X Y Z a P b H","2":"C K L G"},C:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"16":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"16":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"16":"cC"},R:{"16":"dC"},S:{"1":"eC"}},B:2,C:"Navigator Language API"};


/***/ }),

/***/ 1493:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","1028":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB","1028":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","1028":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"MC QC RC","132":"aB I NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"WC XC fB YC ZC aC bC","132":"I","516":"TC UC VC"},Q:{"1":"cC"},R:{"516":"dC"},S:{"260":"eC"}},B:7,C:"Network Information API"};


/***/ }),

/***/ 54483:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","2":"C K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I","36":"c J D E F A B C K L G M N O d e f"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","36":"H QC RC"},J:{"1":"A","2":"D"},K:{"2":"A B C YB gB ZB","36":"Q"},L:{"513":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"36":"I","258":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"258":"dC"},S:{"1":"eC"}},B:1,C:"Web Notifications"};


/***/ }),

/***/ 69577:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","2":"C K"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D","16":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I TC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:6,C:"Object.entries"};


/***/ }),

/***/ 6228:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G","260":"M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D pB eB qB rB","132":"E F sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F G M N O xB yB zB","33":"B C 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B","132":"E 6B 7B 8B"},H:{"33":"LC"},I:{"1":"H RC","2":"aB I MC NC OC PC hB QC"},J:{"2":"D A"},K:{"1":"Q","2":"A","33":"B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS3 object-fit/object-position"};


/***/ }),

/***/ 63008:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 u v w x y z","2":"8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"h i j k l m n o p q r s t u","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"I","2":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:7,C:"Object.observe data binding"};


/***/ }),

/***/ 55480:
/***/ ((module) => {

module.exports={A:{A:{"8":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","2":"C K"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","8":"0 1 2 3 4 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","8":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB"},E:{"1":"B C K L G fB YB ZB uB vB wB","8":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","8":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","8":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"8":"LC"},I:{"1":"H","8":"aB I MC NC OC PC hB QC RC"},J:{"8":"D A"},K:{"1":"Q","8":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"8":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","8":"I TC"},Q:{"1":"cC"},R:{"8":"dC"},S:{"1":"eC"}},B:6,C:"Object.values method"};


/***/ }),

/***/ 39611:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O","2":"C R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D","130":"A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"Object RTC (ORTC) API for WebRTC"};


/***/ }),

/***/ 45884:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"F iB","8":"J D E"},B:{"1":"C K L G M N O R S T U V","2":"W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U lB mB","2":"V W X Y Z a P b H dB","4":"aB","8":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V","2":"W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","8":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB 0B YB gB 1B ZB","2":"F SB TB UB VB WB XB xB","8":"yB zB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I MC NC OC PC hB QC RC","2":"H"},J:{"1":"D A"},K:{"1":"B C YB gB ZB","2":"A Q"},L:{"2":"H"},M:{"2":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:7,C:"Offline web applications"};


/***/ }),

/***/ 74509:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","194":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB","322":"GB bB HB cB IB JB Q KB LB MB NB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","322":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"194":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"fB YC ZC aC bC","2":"I TC UC VC WC XC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"194":"eC"}},B:1,C:"OffscreenCanvas"};


/***/ }),

/***/ 77081:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"N O R S T U V W X Y Z a P b H","2":"C K L G M"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L pB eB qB rB sB tB fB YB ZB uB","132":"G vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"A","2":"D"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Ogg Vorbis audio format"};


/***/ }),

/***/ 18398:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","8":"F A B"},B:{"1":"N O R S T U V W X Y Z a P b H","8":"C K L G M"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"1":"P"},N:{"8":"A B"},O:{"1":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:6,C:"Ogg/Theora video format"};


/***/ }),

/***/ 67096:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G","16":"M N O d"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB","16":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B YB gB 1B","16":"C"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Reversed attribute of ordered lists"};


/***/ }),

/***/ 79713:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"M N O R S T U V W X Y Z a P b H","2":"C K L G"},C:{"1":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I TC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"\"once\" event listener option"};


/***/ }),

/***/ 11219:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D iB","260":"E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB","516":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y"},D:{"1":"0 1 2 3 4 5 6 7 8 9 L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B","4":"ZB"},G:{"1":"E hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"A","132":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Online/offline status"};


/***/ }),

/***/ 12205:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","2":"C K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q"},E:{"2":"I c J D E F A pB eB qB rB sB tB fB","132":"B C K L G YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC","132":"BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Opus"};


/***/ }),

/***/ 77294:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB","194":"GB bB HB cB IB JB Q KB LB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"Orientation Sensor"};


/***/ }),

/***/ 28311:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D iB","260":"E","388":"F A B"},B:{"1":"G M N O R S T U V W X Y Z a P b H","388":"C K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B","129":"ZB","260":"F B xB yB zB 0B YB gB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"C Q ZB","260":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"388":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS outline properties"};


/***/ }),

/***/ 42502:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"G M N O R S T U V W X Y Z a P b H","2":"C K L"},C:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","2":"I TC UC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:6,C:"String.prototype.padStart(), String.prototype.padEnd()"};


/***/ }),

/***/ 72796:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"PageTransitionEvent"};


/***/ }),

/***/ 87772:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F lB mB","33":"A B C K L G M N"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K","33":"L G M N O d e f g h i j k l m n o p q"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B C xB yB zB 0B YB gB 1B","33":"G M N O d"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB","33":"QC RC"},J:{"1":"A","2":"D"},K:{"1":"Q ZB","2":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","33":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"Page Visibility"};


/***/ }),

/***/ 50754:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"M N O R S T U V W X Y Z a P b H","2":"C K L G"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"Passive event listeners"};


/***/ }),

/***/ 28403:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","16":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b lB mB","16":"H dB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H","16":"dB nB oB"},E:{"1":"C K ZB","2":"I c J D E F A B pB eB qB rB sB tB fB YB","16":"L G uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB xB yB zB 0B YB gB 1B ZB","16":"BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"16":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","16":"H"},J:{"2":"D","16":"A"},K:{"2":"A B C YB gB ZB","16":"Q"},L:{"16":"H"},M:{"16":"P"},N:{"2":"A","16":"B"},O:{"16":"SC"},P:{"2":"I TC UC","16":"VC WC XC fB YC ZC aC bC"},Q:{"16":"cC"},R:{"16":"dC"},S:{"2":"eC"}},B:1,C:"Password Rules"};


/***/ }),

/***/ 13066:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K","132":"L G M N O"},C:{"1":"6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o lB mB","132":"0 1 2 3 4 5 p q r s t u v w x y z"},D:{"1":"NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t","132":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"I c J D pB eB qB rB","132":"E F sB"},F:{"1":"DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g xB yB zB 0B YB gB 1B ZB","132":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B","16":"E","132":"6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"132":"SC"},P:{"1":"fB YC ZC aC bC","132":"I TC UC VC WC XC"},Q:{"132":"cC"},R:{"132":"dC"},S:{"1":"eC"}},B:1,C:"Path2D"};


/***/ }),

/***/ 36954:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K","322":"L","8196":"G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB lB mB","4162":"DB EB FB GB bB HB cB IB JB Q KB","16452":"LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB","194":"BB CB DB EB FB GB","1090":"bB HB","8196":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB"},E:{"1":"K L G ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB","514":"A B fB","8196":"C YB"},F:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x xB yB zB 0B YB gB 1B ZB","194":"0 1 2 3 4 5 y z","8196":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB"},G:{"1":"EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B","514":"9B AC BC","8196":"CC DC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"2049":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"ZC aC bC","2":"I","8196":"TC UC VC WC XC fB YC"},Q:{"8196":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"Payment Request API"};


/***/ }),

/***/ 31504:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","132":"B"},B:{"1":"G M N O R S T U V W X Y Z a P b H","16":"C K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B YB gB 1B"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"16":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"Built-in PDF viewer"};


/***/ }),

/***/ 98901:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:7,C:"Permissions API"};


/***/ }),

/***/ 17093:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","258":"R S T U V W","322":"X Y","388":"Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB lB mB","258":"TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB","258":"HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W","322":"X Y","388":"Z a P b H dB nB oB"},E:{"2":"I c J D E F A B pB eB qB rB sB tB fB","258":"C K L G YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","258":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB","322":"RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC","258":"CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","258":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","258":"Q"},L:{"388":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC","258":"WC XC fB YC ZC aC bC"},Q:{"258":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"Permissions Policy"};


/***/ }),

/***/ 2610:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB lB mB","132":"RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","1090":"MB","1412":"QB","1668":"NB OB PB"},D:{"1":"PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB","2114":"OB"},E:{"1":"L G uB vB wB","2":"I c J D E F pB eB qB rB sB tB","4100":"A B C K fB YB ZB"},F:{"1":"SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u xB yB zB 0B YB gB 1B ZB","8196":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB"},G:{"1":"JC KC","2":"E eB 2B hB 3B 4B 5B 6B","4100":"7B 8B 9B AC BC CC DC EC FC GC HC IC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"16388":"H"},M:{"16388":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Picture-in-Picture"};


/***/ }),

/***/ 85312:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r lB mB","578":"s t u v"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u","194":"v"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h xB yB zB 0B YB gB 1B ZB","322":"i"},G:{"1":"8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Picture element"};


/***/ }),

/***/ 96744:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"N O R S T U V W X Y Z a P b H","2":"C K L G M"},C:{"2":"jB","194":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"194":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"194":"eC"}},B:1,C:"Ping attribute"};


/***/ }),

/***/ 54659:
/***/ ((module) => {

module.exports={A:{A:{"1":"D E F A B","2":"iB","8":"J"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"PNG alpha transparency"};


/***/ }),

/***/ 2224:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB mB","2":"jB aB lB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:7,C:"CSS pointer-events (for HTML)"};


/***/ }),

/***/ 27252:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F iB","164":"A"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c lB mB","8":"J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y","328":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB"},D:{"1":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f","8":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z","584":"AB BB CB"},E:{"1":"K L G uB vB wB","2":"I c J pB eB qB","8":"D E F A B C rB sB tB fB YB","1096":"ZB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","8":"G M N O d e f g h i j k l m n o p q r s t u v w","584":"x y z"},G:{"1":"GC HC IC JC KC","8":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC","6148":"FC"},H:{"2":"LC"},I:{"1":"H","8":"aB I MC NC OC PC hB QC RC"},J:{"8":"D A"},K:{"1":"Q","2":"A","8":"B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","36":"A"},O:{"8":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"TC","8":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"328":"eC"}},B:2,C:"Pointer events"};


/***/ }),

/***/ 50221:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K lB mB","33":"L G M N O d e f g h i j k l m n o p q r s t u v w x y"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G","33":"g h i j k l m n o p q r s t u","66":"M N O d e f"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","33":"G M N O d e f g h"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:2,C:"Pointer Lock API"};


/***/ }),

/***/ 72388:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V","322":"P b H","450":"W X Y Z a"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB","194":"UB VB WB XB R S T U V","322":"X Y Z a P b H dB nB oB","450":"W"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB xB yB zB 0B YB gB 1B ZB","194":"IB JB Q KB LB MB NB OB PB QB RB","322":"SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"450":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Portals"};


/***/ }),

/***/ 93412:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB lB mB"},D:{"1":"VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB"},E:{"1":"K L G ZB uB vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB"},F:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB xB yB zB 0B YB gB 1B ZB"},G:{"1":"FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"ZC aC bC","2":"I TC UC VC WC XC fB YC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"prefers-color-scheme media query"};


/***/ }),

/***/ 21506:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB lB mB"},D:{"1":"TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"YC ZC aC bC","2":"I TC UC VC WC XC fB"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"prefers-reduced-motion media query"};


/***/ }),

/***/ 2344:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB"},E:{"1":"G vB wB","2":"I c J D E F A B C K L pB eB qB rB sB tB fB YB ZB uB"},F:{"1":"IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB xB yB zB 0B YB gB 1B ZB"},G:{"1":"KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"YC ZC aC bC","2":"I TC UC VC WC XC fB"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Private class fields"};


/***/ }),

/***/ 46300:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"V W X Y Z a P b H","2":"C K L G M N O R S T U"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U"},E:{"1":"G vB wB","2":"I c J D E F A B C K L pB eB qB rB sB tB fB YB ZB uB"},F:{"1":"PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB xB yB zB 0B YB gB 1B ZB"},G:{"1":"KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Public class fields"};


/***/ }),

/***/ 31127:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","2":"F xB yB zB 0B"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B","132":"5B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"progress element"};


/***/ }),

/***/ 22438:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"O R S T U V W X Y Z a P b H","2":"C K L G M N"},C:{"1":"GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB lB mB"},D:{"1":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB"},F:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC VC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"Promise.prototype.finally"};


/***/ }),

/***/ 26044:
/***/ ((module) => {

module.exports={A:{A:{"8":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","4":"l m","8":"jB aB I c J D E F A B C K L G M N O d e f g h i j k lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","4":"q","8":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p"},E:{"1":"E F A B C K L G sB tB fB YB ZB uB vB wB","8":"I c J D pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","4":"d","8":"F B C G M N O xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","8":"eB 2B hB 3B 4B 5B"},H:{"8":"LC"},I:{"1":"H RC","8":"aB I MC NC OC PC hB QC"},J:{"8":"D A"},K:{"1":"Q","8":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"8":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Promises"};


/***/ }),

/***/ 93871:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:4,C:"Proximity API"};


/***/ }),

/***/ 88321:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N lB mB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 I c J D E F A B C K L G M N O w x y z","66":"d e f g h i j k l m n o p q r s t u v"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C j k l m n o p q r s t xB yB zB 0B YB gB 1B ZB","66":"G M N O d e f g h i"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:6,C:"Proxy object"};


/***/ }),

/***/ 94312:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB lB mB","4":"PB QB RB SB TB","132":"OB"},D:{"1":"RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB"},E:{"1":"G vB wB","2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB uB","260":"L"},F:{"1":"HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB xB yB zB 0B YB gB 1B ZB"},G:{"1":"JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"YC ZC aC bC","2":"I TC UC VC WC XC fB"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Public class fields"};


/***/ }),

/***/ 29636:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB","2":"F B C G M N O d LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","4":"h","16":"e f g i"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB","2":"YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"HTTP Public Key Pinning"};


/***/ }),

/***/ 39446:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"N O","2":"C K L G M","257":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","257":"2 4 5 6 7 8 9 BB CB DB EB FB GB bB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","1281":"3 AB HB"},D:{"2":"0 1 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","257":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","388":"2 3 4 5 6 7"},E:{"2":"I c J D E F pB eB qB rB sB","514":"A B C K L G tB fB YB ZB uB vB wB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p q r s t u xB yB zB 0B YB gB 1B ZB","16":"v w x y z","257":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"257":"eC"}},B:5,C:"Push API"};


/***/ }),

/***/ 78361:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"iB","8":"J D","132":"E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","8":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB yB zB 0B YB gB 1B ZB","8":"F xB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"querySelector/querySelectorAll"};


/***/ }),

/***/ 21513:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","16":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L G M N O d e f g h i j"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F xB","132":"B C yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB 3B 4B"},H:{"1":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"Q","132":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"257":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"readonly attribute of input and textarea elements"};


/***/ }),

/***/ 68504:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","132":"B"},B:{"1":"R S T U","132":"C K L G M N O","513":"V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t lB mB"},D:{"1":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V","2":"I c J D E F A B C K L G M N O d e","260":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB","513":"W X Y Z a P b H dB nB oB"},E:{"1":"C YB ZB","2":"I c J D pB eB qB rB","132":"E F A B sB tB fB","1025":"K L G uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB","2":"F B C xB yB zB 0B YB gB 1B ZB","513":"SB TB UB VB WB XB"},G:{"1":"DC EC FC GC","2":"eB 2B hB 3B 4B 5B","132":"E 6B 7B 8B 9B AC BC CC","1025":"HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"513":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"Referrer Policy"};


/***/ }),

/***/ 35575:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","129":"R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB"},D:{"2":"I c J D E F A B C","129":"0 1 2 3 4 5 6 7 8 9 K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B xB yB zB 0B YB gB","129":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D","129":"A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"Custom protocol handling"};


/***/ }),

/***/ 67634:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:1,C:"rel=noopener"};


/***/ }),

/***/ 53615:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","132":"B"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","16":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L G"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Link type \"noreferrer\""};


/***/ }),

/***/ 40764:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"O R S T U V W X Y Z a P b H","2":"C K L G M","132":"N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n lB mB"},D:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","132":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E pB eB qB rB sB"},F:{"1":"AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u xB yB zB 0B YB gB 1B ZB","132":"0 1 2 3 4 5 6 7 8 9 v w x y z"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"132":"SC"},P:{"1":"XC fB YC ZC aC bC","2":"I","132":"TC UC VC WC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:1,C:"relList (DOMTokenList)"};


/***/ }),

/***/ 49123:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E iB","132":"F A"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB mB","2":"jB aB lB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F B xB yB zB 0B YB gB"},G:{"1":"E 2B hB 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB","260":"3B"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"C Q ZB","2":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"rem (root em) units"};


/***/ }),

/***/ 10380:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","33":"B C K L G M N O d e f g","164":"I c J D E F A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F","33":"g h","164":"O d e f","420":"A B C K L G M N"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB","33":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B","33":"4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"requestAnimationFrame"};


/***/ }),

/***/ 28670:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB lB mB","194":"BB CB"},D:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB","322":"L G uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC","322":"IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"requestIdleCallback"};


/***/ }),

/***/ 21994:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB lB mB"},D:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB","194":"CB DB EB FB GB bB HB cB IB JB"},E:{"1":"L G uB vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB ZB","66":"K"},F:{"1":"AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y xB yB zB 0B YB gB 1B ZB","194":"0 1 2 3 4 5 6 7 8 9 z"},G:{"1":"IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"XC fB YC ZC aC bC","2":"I TC UC VC WC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Resize Observer"};


/***/ }),

/***/ 28286:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o lB mB","194":"p q r s"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB","260":"B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"Resource Timing"};


/***/ }),

/***/ 42459:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L lB mB"},D:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"2 3 4"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o xB yB zB 0B YB gB 1B ZB","194":"p q r"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Rest parameters"};


/***/ }),

/***/ 17936:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L","516":"G M N O"},C:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f lB mB","33":"0 1 g h i j k l m n o p q r s t u v w x y z"},D:{"1":"EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g","33":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N xB yB zB 0B YB gB 1B ZB","33":"0 O d e f g h i j k l m n o p q r s t u v w x y z"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D","130":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"33":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"33":"cC"},R:{"33":"dC"},S:{"1":"eC"}},B:5,C:"WebRTC Peer-to-peer connections"};


/***/ }),

/***/ 35921:
/***/ ((module) => {

module.exports={A:{A:{"4":"J D E F A B iB"},B:{"4":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","8":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v lB mB"},D:{"4":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","8":"I"},E:{"4":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","8":"I pB eB"},F:{"4":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","8":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"4":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","8":"eB 2B hB"},H:{"8":"LC"},I:{"4":"aB I H PC hB QC RC","8":"MC NC OC"},J:{"4":"A","8":"D"},K:{"4":"Q","8":"A B C YB gB ZB"},L:{"4":"H"},M:{"1":"P"},N:{"4":"A B"},O:{"4":"SC"},P:{"4":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"4":"cC"},R:{"4":"dC"},S:{"1":"eC"}},B:1,C:"Ruby annotation"};


/***/ }),

/***/ 88365:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"J D iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p","2":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J qB","2":"D E F A B C K L G sB tB fB YB ZB uB vB wB","16":"rB","129":"I pB eB"},F:{"1":"F B C G M N O xB yB zB 0B YB gB 1B ZB","2":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"2B hB 3B 4B 5B","2":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","129":"eB"},H:{"1":"LC"},I:{"1":"aB I MC NC OC PC hB QC","2":"H RC"},J:{"1":"D A"},K:{"1":"A B C YB gB ZB","2":"Q"},L:{"2":"H"},M:{"2":"P"},N:{"1":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"display: run-in"};


/***/ }),

/***/ 87529:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","388":"B"},B:{"1":"O R S T U V W","2":"C K L G","129":"M N","513":"X Y Z a P b H"},C:{"1":"HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB lB mB"},D:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R","2":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","513":"S T U V W X Y Z a P b H dB nB oB"},E:{"1":"G vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB YB","2052":"L","3076":"C K ZB uB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w xB yB zB 0B YB gB 1B ZB","513":"QB RB SB TB UB VB WB XB"},G:{"1":"FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC","2052":"DC EC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"513":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"16":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:6,C:"'SameSite' cookie attribute"};


/***/ }),

/***/ 22474:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","164":"B"},B:{"1":"R S T U V W X Y Z a P b H","36":"C K L G M N O"},C:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N lB mB","36":"0 1 O d e f g h i j k l m n o p q r s t u v w x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A","36":"B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","16":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"Screen Orientation"};


/***/ }),

/***/ 1522:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB mB","2":"jB aB lB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB","132":"c"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"2":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"async attribute for external scripts"};


/***/ }),

/***/ 13440:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","132":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","257":"I c J D E F A B C K L G M N O d e f g h i j k l m n o lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"2":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"defer attribute for external scripts"};


/***/ }),

/***/ 39781:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D iB","132":"E F A B"},B:{"1":"R S T U V W X Y Z a P b H","132":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","132":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t lB mB"},D:{"1":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB"},E:{"2":"I c pB eB","132":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F xB yB zB 0B","16":"B YB gB","132":"0 1 2 3 4 5 C G M N O d e f g h i j k l m n o p q r s t u v w x y z 1B ZB"},G:{"16":"eB 2B hB","132":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","16":"MC NC","132":"aB I OC PC hB QC RC"},J:{"132":"D A"},K:{"1":"Q","132":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"132":"SC"},P:{"132":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"132":"dC"},S:{"1":"eC"}},B:5,C:"scrollIntoView"};


/***/ }),

/***/ 12228:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:7,C:"Element.scrollIntoViewIfNeeded()"};


/***/ }),

/***/ 52531:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB","2":"bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB","2":"F B C SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"SDCH Accept-Encoding/Content-Encoding"};


/***/ }),

/***/ 60612:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","16":"iB","260":"J D E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","132":"0 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","2180":"1 2 3 4 5 6 7 8 9"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","132":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"16":"hB","132":"eB 2B","516":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H QC RC","16":"aB I MC NC OC PC","1025":"hB"},J:{"1":"A","16":"D"},K:{"1":"Q","16":"A B C YB gB","132":"ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","16":"A"},O:{"1025":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2180":"eC"}},B:5,C:"Selection API"};


/***/ }),

/***/ 6978:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB lB mB"},D:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB","196":"HB cB IB JB","324":"Q"},E:{"2":"I c J D E F A B C pB eB qB rB sB tB fB YB","516":"K L G ZB uB vB wB"},F:{"1":"AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"Server Timing"};


/***/ }),

/***/ 65958:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"N O R S T U V W X Y Z a P b H","2":"C K L","322":"G M"},C:{"1":"2 4 5 6 7 8 9 BB CB DB EB FB GB bB cB IB JB Q KB LB MB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q lB mB","194":"0 1 r s t u v w x y z","513":"3 AB HB NB"},D:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x","4":"0 1 2 y z"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D E F A B pB eB qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k xB yB zB 0B YB gB 1B ZB","4":"l m n o p"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","4":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","4":"Q"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"4":"dC"},S:{"2":"eC"}},B:4,C:"Service Workers"};


/***/ }),

/***/ 87394:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O","2":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"1":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Efficient Script Yielding: setImmediate()"};


/***/ }),

/***/ 83083:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","2":"iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"16":"LC"},I:{"1":"aB I H NC OC PC hB QC RC","260":"MC"},J:{"1":"D A"},K:{"1":"Q","16":"A B C YB gB ZB"},L:{"1":"H"},M:{"16":"P"},N:{"16":"A B"},O:{"16":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","16":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"SHA-2 SSL certificates"};


/***/ }),

/***/ 29657:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R","2":"C K L G M N O S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","66":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R","2":"I c J D E F A B C K L G M N O d e f g h i S T U V W X Y Z a P b H dB nB oB","33":"j k l m n o p q r s"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB","2":"F B C MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","33":"G M N O d e f"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB","33":"QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC","2":"aC bC","33":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:7,C:"Shadow DOM (deprecated V0 spec)"};


/***/ }),

/***/ 32860:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB lB mB","322":"GB","578":"bB HB cB IB"},D:{"1":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB"},E:{"1":"A B C K L G fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x xB yB zB 0B YB gB 1B ZB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B","132":"9B AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I","4":"TC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"Shadow DOM (V1)"};


/***/ }),

/***/ 71306:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G","194":"M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB lB mB","194":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB","450":"TB UB VB WB XB","513":"R S T kB U V W X Y Z a P b H dB"},D:{"1":"NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB","194":"HB cB IB JB Q KB LB MB","513":"b H dB nB oB"},E:{"2":"I c J D E F A pB eB qB rB sB tB","194":"B C K L G fB YB ZB uB vB wB"},F:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","194":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B","194":"AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"513":"H"},M:{"513":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"Shared Array Buffer"};


/***/ }),

/***/ 42568:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"c J qB","2":"I D E F A B C K L G pB eB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 0B YB gB 1B ZB","2":"F xB yB zB"},G:{"1":"3B 4B","2":"E eB 2B hB 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"B C YB gB ZB","2":"Q","16":"A"},L:{"2":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"I","2":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:1,C:"Shared Web Workers"};


/***/ }),

/***/ 18689:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J iB","132":"D E"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB"},H:{"1":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"A","2":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Server Name Indication"};


/***/ }),

/***/ 35867:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","2":"9 jB aB I c J D E F A B C AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","2":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"E F A B C tB fB YB","2":"I c J D pB eB qB rB sB","129":"K L G ZB uB vB wB"},F:{"1":"0 2 G M N O d e f g h i j k l m n o p q r s t u v w x ZB","2":"1 3 4 5 6 7 8 9 F B C y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC","2":"eB 2B hB 3B 4B 5B","257":"EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I PC hB QC RC","2":"H MC NC OC"},J:{"2":"D A"},K:{"1":"ZB","2":"A B C Q YB gB"},L:{"2":"H"},M:{"2":"P"},N:{"1":"B","2":"A"},O:{"2":"SC"},P:{"1":"I","2":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"16":"dC"},S:{"1":"eC"}},B:7,C:"SPDY protocol"};


/***/ }),

/***/ 7773:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","1026":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f lB mB","322":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i","164":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L pB eB qB rB sB tB fB YB ZB uB","2084":"G vB wB"},F:{"2":"F B C G M N O d e f g h i j k xB yB zB 0B YB gB 1B ZB","1026":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC","2084":"KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"164":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"164":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"164":"cC"},R:{"164":"dC"},S:{"322":"eC"}},B:7,C:"Speech Recognition API"};


/***/ }),

/***/ 38623:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O","2":"C K","257":"R S T U V W X Y Z a P b H"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o lB mB","194":"0 1 2 3 4 5 6 p q r s t u v w x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q","257":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB","2":"F B C G M N O d e f g h i j k xB yB zB 0B YB gB 1B ZB","257":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:7,C:"Speech Synthesis API"};


/***/ }),

/***/ 79418:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"4":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"4":"LC"},I:{"4":"aB I H MC NC OC PC hB QC RC"},J:{"1":"A","4":"D"},K:{"4":"A B C Q YB gB ZB"},L:{"4":"H"},M:{"4":"P"},N:{"4":"A B"},O:{"4":"SC"},P:{"4":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"4":"dC"},S:{"2":"eC"}},B:1,C:"Spellcheck attribute"};


/***/ }),

/***/ 88502:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C pB eB qB rB sB tB fB YB ZB","2":"K L G uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC","2":"FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:7,C:"Web SQL Database"};


/***/ }),

/***/ 31740:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"M N O R S T U V W X Y Z a P b H","260":"C","514":"K L G"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p lB mB","194":"q r s t u v"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r","260":"s t u v"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D pB eB qB rB","260":"E sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e xB yB zB 0B YB gB 1B ZB","260":"f g h i"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B","260":"E 6B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Srcset and sizes attributes"};


/***/ }),

/***/ 83192:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M lB mB","129":"u v w x y z","420":"N O d e f g h i j k l m n o p q r s t"},D:{"1":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e","420":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v w x y z AB"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B G M N xB yB zB 0B YB gB 1B","420":"C O d e f g h i j k l m n o p q r s t u v w x ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC","513":"IC JC KC","1537":"BC CC DC EC FC GC HC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D","420":"A"},K:{"1":"Q","2":"A B YB gB","420":"C ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","420":"I TC"},Q:{"1":"cC"},R:{"420":"dC"},S:{"2":"eC"}},B:4,C:"getUserMedia/Stream API"};


/***/ }),

/***/ 54664:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","130":"B"},B:{"1":"a P b H","16":"C K","260":"L G","1028":"R S T U V W X Y Z","5124":"M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB lB mB","6148":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","6722":"FB GB bB HB cB IB JB Q"},D:{"1":"a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","260":"AB BB CB DB EB FB GB","1028":"bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z"},E:{"2":"I c J D E F pB eB qB rB sB tB","1028":"G vB wB","3076":"A B C K L fB YB ZB uB"},F:{"1":"VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w xB yB zB 0B YB gB 1B ZB","260":"0 1 2 3 x y z","1028":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B","16":"9B","1028":"AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"6148":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC","1028":"VC WC XC fB YC ZC aC bC"},Q:{"1028":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"Streams"};


/***/ }),

/***/ 24046:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A iB","129":"B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B YB gB 1B"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Strict Transport Security"};


/***/ }),

/***/ 39846:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v w x y z AB BB CB","2":"jB aB I c J D E F A B C K L G M N O d e cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","322":"DB EB FB GB bB HB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","194":"e f g h i j k l m n o p q r s t u"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:7,C:"Scoped CSS"};


/***/ }),

/***/ 50847:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"N O R S T U V W X Y Z a P b H","2":"C K L G M"},C:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p xB yB zB 0B YB gB 1B ZB"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC","194":"BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"Subresource Integrity"};


/***/ }),

/***/ 52279:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"M N O R S T U V W X Y Z a P b H","516":"C K L G"},C:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","260":"I c J D E F A B C K L G M N O d e f g h"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","4":"I"},E:{"1":"c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB","132":"I eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"E hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","132":"eB 2B"},H:{"260":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"D A"},K:{"1":"Q","260":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"SVG in CSS backgrounds"};


/***/ }),

/***/ 24682:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I","4":"c J D"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"SVG filters"};


/***/ }),

/***/ 18443:
/***/ ((module) => {

module.exports={A:{A:{"2":"F A B iB","8":"J D E"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v","2":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","130":"0 1 2 3 4 5 6 7 8 w x y z"},E:{"1":"I c J D E F A B C K L G eB qB rB sB tB fB YB ZB uB vB wB","2":"pB"},F:{"1":"F B C G M N O d e f g h i xB yB zB 0B YB gB 1B ZB","2":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","130":"j k l m n o p q r s t u"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"258":"LC"},I:{"1":"aB I PC hB QC RC","2":"H MC NC OC"},J:{"1":"D A"},K:{"1":"A B C YB gB ZB","2":"Q"},L:{"130":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"I","130":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"130":"dC"},S:{"2":"eC"}},B:2,C:"SVG fonts"};


/***/ }),

/***/ 32036:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","260":"F A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L lB mB"},D:{"1":"8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t","132":"0 1 2 3 4 5 6 7 u v w x y z"},E:{"1":"C K L G YB ZB uB vB wB","2":"I c J D F A B pB eB qB rB tB fB","132":"E sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"G M N O d e f g","4":"B C yB zB 0B YB gB 1B","16":"F xB","132":"h i j k l m n o p q r s t u"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B 7B 8B 9B AC BC","132":"E 6B"},H:{"1":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D","132":"A"},K:{"1":"Q ZB","4":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","132":"I"},Q:{"1":"cC"},R:{"132":"dC"},S:{"1":"eC"}},B:4,C:"SVG fragment identifiers"};


/***/ }),

/***/ 18617:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","388":"F A B"},B:{"4":"R S T U V W X Y Z a P b H","260":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB","4":"aB"},D:{"4":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"pB eB","4":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"4":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"4":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","4":"H QC RC"},J:{"1":"A","2":"D"},K:{"4":"A B C Q YB gB ZB"},L:{"4":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"4":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"4":"cC"},R:{"4":"dC"},S:{"1":"eC"}},B:2,C:"SVG effects for HTML"};


/***/ }),

/***/ 94098:
/***/ ((module) => {

module.exports={A:{A:{"2":"iB","8":"J D E","129":"F A B"},B:{"1":"N O R S T U V W X Y Z a P b H","129":"C K L G M"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","8":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","8":"I c J"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","8":"I c pB eB","129":"J D E qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"B 0B YB gB","8":"F xB yB zB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","8":"eB 2B hB","129":"E 3B 4B 5B 6B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"MC NC OC","129":"aB I PC hB"},J:{"1":"A","129":"D"},K:{"1":"C Q ZB","8":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"129":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Inline SVG in HTML5"};


/***/ }),

/***/ 86703:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c J D E F A B C K L G M N O d e f g h i j k l"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"pB","4":"eB","132":"I c J D E qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","132":"E eB 2B hB 3B 4B 5B 6B"},H:{"1":"LC"},I:{"1":"H QC RC","2":"MC NC OC","132":"aB I PC hB"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"SVG in HTML img element"};


/***/ }),

/***/ 91827:
/***/ ((module) => {

module.exports={A:{A:{"2":"iB","8":"J D E F A B"},B:{"1":"R S T U V W X Y Z a P b H","8":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","8":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","4":"I"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","8":"pB eB","132":"I c qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","132":"eB 2B hB 3B"},H:{"2":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"8":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"SVG SMIL animation"};


/***/ }),

/***/ 44087:
/***/ ((module) => {

module.exports={A:{A:{"2":"iB","8":"J D E","772":"F A B"},B:{"1":"R S T U V W X Y Z a P b H","513":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","4":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G eB qB rB sB tB fB YB ZB uB vB wB","4":"pB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"H QC RC","2":"MC NC OC","132":"aB I PC hB"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"257":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"SVG (basic support)"};


/***/ }),

/***/ 12832:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB","132":"QB RB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"16":"SC"},P:{"1":"YC ZC aC bC","2":"I TC UC VC WC XC fB"},Q:{"16":"cC"},R:{"16":"dC"},S:{"2":"eC"}},B:6,C:"Signed HTTP Exchanges (SXG)"};


/***/ }),

/***/ 40960:
/***/ ((module) => {

module.exports={A:{A:{"1":"D E F A B","16":"J iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"16":"jB aB lB mB","129":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"16":"I c pB eB","257":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","16":"F"},G:{"769":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"16":"LC"},I:{"16":"aB I H MC NC OC PC hB QC RC"},J:{"16":"D A"},K:{"16":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"16":"A B"},O:{"16":"SC"},P:{"16":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"16":"dC"},S:{"129":"eC"}},B:1,C:"tabindex global attribute"};


/***/ }),

/***/ 7507:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"K L G M N O R S T U V W X Y Z a P b H","16":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y"},E:{"1":"A B K L G tB fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB","129":"C"},F:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m xB yB zB 0B YB gB 1B ZB"},G:{"1":"7B 8B 9B AC BC CC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B","129":"DC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"ES6 Template Literals (Template Strings)"};


/***/ }),

/***/ 52873:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"G M N O R S T U V W X Y Z a P b H","2":"C","388":"K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j","132":"k l m n o p q r s"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","2":"I c J D pB eB qB","388":"E sB","514":"rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","132":"G M N O d e f"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B","388":"E 6B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"HTML templates"};


/***/ }),

/***/ 85105:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"Temporal"};


/***/ }),

/***/ 40831:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E A B iB","16":"F"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","16":"I c"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"B C"},E:{"2":"I J pB eB qB","16":"c D E F A B C K L G rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B gB 1B ZB","16":"YB"},G:{"2":"eB 2B hB 3B 4B","16":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC PC hB QC RC","16":"OC"},J:{"2":"A","16":"D"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Test feature - updated"};


/***/ }),

/***/ 6866:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","2052":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c lB mB","1028":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","1060":"J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i j","226":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB","2052":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D pB eB qB rB","772":"K L G ZB uB vB wB","804":"E F A B C tB fB YB","1316":"sB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p q r s xB yB zB 0B YB gB 1B ZB","226":"0 1 t u v w x y z","2052":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"eB 2B hB 3B 4B 5B","292":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"2052":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2052":"SC"},P:{"2":"I TC UC","2052":"VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"1":"dC"},S:{"1028":"eC"}},B:4,C:"text-decoration styling"};


/***/ }),

/***/ 76001:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","164":"R S T U V W X Y Z a P b H"},C:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","322":"3"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i","164":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB","164":"D rB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","164":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB","164":"H QC RC"},J:{"2":"D","164":"A"},K:{"2":"A B C YB gB ZB","164":"Q"},L:{"164":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"164":"SC"},P:{"164":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"164":"cC"},R:{"164":"dC"},S:{"1":"eC"}},B:4,C:"text-emphasis styling"};


/***/ }),

/***/ 73033:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","2":"iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","8":"jB aB I c J lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","33":"F xB yB zB 0B"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"Q ZB","33":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS3 Text-overflow"};


/***/ }),

/***/ 2368:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","33":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j l m n o p q r s t u v w x y z AB BB","258":"k"},E:{"2":"I c J D E F A B C K L G pB eB rB sB tB fB YB ZB uB vB wB","258":"qB"},F:{"1":"1 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 2 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"eB 2B hB","33":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"33":"P"},N:{"161":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"CSS text-size-adjust"};


/***/ }),

/***/ 10481:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L","33":"R S T U V W X Y Z a P b H","161":"G M N O"},C:{"2":"0 1 2 3 4 5 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","161":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","450":"6"},D:{"33":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"33":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","33":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"33":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","36":"eB"},H:{"2":"LC"},I:{"2":"aB","33":"I H MC NC OC PC hB QC RC"},J:{"33":"D A"},K:{"2":"A B C YB gB ZB","33":"Q"},L:{"33":"H"},M:{"161":"P"},N:{"2":"A B"},O:{"33":"SC"},P:{"33":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"33":"cC"},R:{"33":"dC"},S:{"161":"eC"}},B:7,C:"CSS text-stroke and text-fill"};


/***/ }),

/***/ 13785:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB lB mB","130":"OB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"K L G ZB uB vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"text-underline-offset"};


/***/ }),

/***/ 2846:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G eB qB rB sB tB fB YB ZB uB vB wB","16":"pB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","16":"F"},G:{"1":"E 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB"},H:{"1":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Node.textContent"};


/***/ }),

/***/ 96073:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O lB mB","132":"d"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"TextEncoder & TextDecoder"};


/***/ }),

/***/ 76376:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D iB","66":"E F A"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB","2":"jB aB I c J D E F A B C K L G M N O d e f g lB mB","66":"h","129":"NB OB PB QB RB SB TB UB VB WB","388":"XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V","2":"I c J D E F A B C K L G M N O d e f","1540":"W X Y Z a P b H dB nB oB"},E:{"1":"D E F A B C K sB tB fB YB ZB","2":"I c J pB eB qB rB","513":"L G uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB ZB","2":"F B C xB yB zB 0B YB gB 1B","1540":"SB TB UB VB WB XB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"1":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"1":"A","2":"D"},K:{"1":"Q ZB","2":"A B C YB gB"},L:{"1":"H"},M:{"129":"P"},N:{"1":"B","66":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"TLS 1.1"};


/***/ }),

/***/ 99062:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D iB","66":"E F A"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h lB mB","66":"i j k"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F G xB","66":"B C yB zB 0B YB gB 1B ZB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"1":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"1":"A","2":"D"},K:{"1":"Q ZB","2":"A B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","66":"A"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"TLS 1.2"};


/***/ }),

/***/ 5423:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","132":"HB cB IB","450":"9 AB BB CB DB EB FB GB bB"},D:{"1":"PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB","706":"CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB"},E:{"1":"L G vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB","1028":"K ZB uB"},F:{"1":"FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB xB yB zB 0B YB gB 1B ZB","706":"CB DB EB"},G:{"1":"EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"fB YC ZC aC bC","2":"I TC UC VC WC XC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:6,C:"TLS 1.3"};


/***/ }),

/***/ 51858:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L","194":"R S T U V W X Y Z a P b H","257":"G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b lB mB","16":"H dB"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w","16":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB","194":"GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E pB eB qB rB sB","16":"F A B C K L G tB fB YB ZB uB vB wB"},F:{"2":"F B C G M N O d e f g h i j k l m n xB yB zB 0B YB gB 1B ZB","16":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B","16":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"16":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","16":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","16":"Q"},L:{"16":"H"},M:{"16":"P"},N:{"2":"A","16":"B"},O:{"16":"SC"},P:{"16":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"16":"cC"},R:{"16":"dC"},S:{"2":"eC"}},B:6,C:"Token Binding"};


/***/ }),

/***/ 61653:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","8":"A B"},B:{"1":"R S T U V W X Y Z a P b H","578":"C K L G M N O"},C:{"1":"O d e f g h i AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","4":"I c J D E F A B C K L G M N","194":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"8":"A","260":"B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:2,C:"Touch events"};


/***/ }),

/***/ 98415:
/***/ ((module) => {

module.exports={A:{A:{"2":"iB","8":"J D E","129":"A B","161":"F"},B:{"1":"N O R S T U V W X Y Z a P b H","129":"C K L G M"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","33":"I c J D E F A B C K L G lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","33":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F xB yB","33":"B C G M N O d e f g zB 0B YB gB 1B"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","33":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","33":"aB I MC NC OC PC hB QC RC"},J:{"33":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"CSS3 2D Transforms"};


/***/ }),

/***/ 48912:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","132":"A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F lB mB","33":"A B C K L G"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B","33":"C K L G M N O d e f g h i j k l m n o p q r s t"},E:{"2":"pB eB","33":"I c J D E qB rB sB","257":"F A B C K L G tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","33":"G M N O d e f g"},G:{"33":"E eB 2B hB 3B 4B 5B 6B","257":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"MC NC OC","33":"aB I PC hB QC RC"},J:{"33":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"CSS3 3D Transforms"};


/***/ }),

/***/ 58552:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"U V W X Y Z a P b H","2":"C K L G M N O R S T"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"aC bC","2":"I TC UC VC WC XC fB YC ZC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Trusted Types for DOM manipulation"};


/***/ }),

/***/ 23126:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","132":"F A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB yB zB 0B YB gB 1B ZB","2":"F xB"},G:{"1":"E hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B"},H:{"2":"LC"},I:{"1":"aB I H NC OC PC hB QC RC","2":"MC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"TTF/OTF - TrueType and OpenType font support"};


/***/ }),

/***/ 71426:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F iB","132":"A"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB","260":"qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F B xB yB zB 0B YB gB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B","260":"hB"},H:{"1":"LC"},I:{"1":"I H PC hB QC RC","2":"aB MC NC OC"},J:{"1":"A","2":"D"},K:{"1":"C Q ZB","2":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Typed Arrays"};


/***/ }),

/***/ 61405:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","513":"R S T U V W X Y Z a P b H"},C:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","322":"5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB"},D:{"2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v","130":"w x y","513":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"K L G uB vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB ZB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x z xB yB zB 0B YB gB 1B ZB","513":"0 1 2 3 4 5 6 7 8 9 y AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"322":"eC"}},B:6,C:"FIDO U2F API"};


/***/ }),

/***/ 43287:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB lB mB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t xB yB zB 0B YB gB 1B ZB"},G:{"1":"CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC","16":"BC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:1,C:"unhandledrejection/rejectionhandled events"};


/***/ }),

/***/ 97798:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"N O R S T U V W X Y Z a P b H","2":"C K L G M"},C:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"Upgrade Insecure Requests"};


/***/ }),

/***/ 52411:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"U V W X Y Z a P b H","2":"C K L G M N O","66":"R S T"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB","66":"TB UB VB WB XB R S"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB xB yB zB 0B YB gB 1B ZB","66":"LB MB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"aC bC","2":"I TC UC VC WC XC fB YC ZC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"URL Scroll-To-Text Fragment"};


/***/ }),

/***/ 80081:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g","130":"h i j k l m n o p"},E:{"1":"E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB rB","130":"D"},F:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","130":"G M N O"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B","130":"5B"},H:{"2":"LC"},I:{"1":"H RC","2":"aB I MC NC OC PC hB","130":"QC"},J:{"2":"D","130":"A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"URL API"};


/***/ }),

/***/ 17586:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"N O R S T U V W X Y Z a P b H","2":"C K L G M"},C:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB","132":"0 1 n o p q r s t u v w x y z"},D:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"B C K L G fB YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t xB yB zB 0B YB gB 1B ZB"},G:{"1":"AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","2":"I"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:1,C:"URLSearchParams"};


/***/ }),

/***/ 33500:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I pB eB","132":"c qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F B xB yB zB 0B YB gB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"1":"LC"},I:{"1":"aB I H PC hB QC RC","2":"MC NC OC"},J:{"1":"D A"},K:{"1":"C Q gB ZB","2":"A B YB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"ECMAScript 5 Strict Mode"};


/***/ }),

/***/ 85671:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","33":"A B"},B:{"1":"R S T U V W X Y Z a P b H","33":"C K L G M N O"},C:{"1":"OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","33":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB lB mB"},D:{"1":"CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","33":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB"},E:{"33":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","33":"G M N O d e f g h i j k l m n o p q r s t u v w x y"},G:{"33":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","33":"aB I MC NC OC PC hB QC RC"},J:{"33":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"33":"A B"},O:{"2":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","33":"I TC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"33":"eC"}},B:5,C:"CSS user-select: none"};


/***/ }),

/***/ 98345:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"User Timing API"};


/***/ }),

/***/ 56153:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"N O R S T U V W X Y Z a P b H","2":"C K L G M"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB lB mB","4609":"IB JB Q KB LB MB NB OB PB","4674":"cB","5698":"HB","7490":"BB CB DB EB FB","7746":"GB bB","8705":"QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB","4097":"LB","4290":"bB HB cB","6148":"IB JB Q KB"},E:{"1":"G wB","2":"I c J D E F A pB eB qB rB sB tB fB","4609":"B C YB ZB","8193":"K L uB vB"},F:{"1":"CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","4097":"BB","6148":"7 8 9 AB"},G:{"1":"FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC","4097":"BC CC DC EC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"4097":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC","4097":"WC XC fB YC ZC aC bC"},Q:{"4097":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"Variable fonts"};


/***/ }),

/***/ 18563:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","2":"F B xB yB zB 0B YB gB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB"},H:{"1":"LC"},I:{"1":"H QC RC","16":"aB I MC NC OC PC hB"},J:{"16":"D A"},K:{"1":"C Q ZB","2":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"SVG vector-effect: non-scaling-stroke"};


/***/ }),

/***/ 78480:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A lB mB","33":"B C K L G"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"Vibration API"};


/***/ }),

/***/ 69345:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","260":"I c J D E F A B C K L G M N O d lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A qB rB sB tB fB","2":"pB eB","513":"B C K L G YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC","513":"BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","132":"MC NC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Video element"};


/***/ }),

/***/ 32495:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O","322":"R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q lB mB","194":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"0 1 2 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","322":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c J pB eB qB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p xB yB zB 0B YB gB 1B ZB","322":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"322":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"194":"eC"}},B:1,C:"Video Tracks"};


/***/ }),

/***/ 23396:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","132":"F","260":"A B"},B:{"1":"M N O R S T U V W X Y Z a P b H","260":"C K L G"},C:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d","260":"e f g h i j"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB","260":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B","516":"5B","772":"4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"260":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"Viewport units: vw, vh, vmin, vmax"};


/***/ }),

/***/ 32102:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D iB","4":"E F A B"},B:{"4":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"4":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"4":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"pB eB","4":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F","4":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"4":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"4":"LC"},I:{"2":"aB I MC NC OC PC hB","4":"H QC RC"},J:{"2":"D A"},K:{"4":"A B C Q YB gB ZB"},L:{"4":"H"},M:{"4":"P"},N:{"4":"A B"},O:{"2":"SC"},P:{"4":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"4":"cC"},R:{"4":"dC"},S:{"4":"eC"}},B:2,C:"WAI-ARIA Accessibility features"};


/***/ }),

/***/ 44534:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"P b H","2":"C K L G M N O","194":"R S T U V W X Y Z a"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB","194":"QB RB SB TB UB VB WB XB R S T U V"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB xB yB zB 0B YB gB 1B ZB","194":"GB HB IB JB Q KB LB MB NB OB PB QB RB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"bC","2":"I TC UC VC WC XC fB YC ZC aC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:4,C:"Screen Wake Lock API"};


/***/ }),

/***/ 95495:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"M N O R S T U V W X Y Z a P b H","2":"C K L","578":"G"},C:{"1":"BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB","194":"5 6 7 8 9","1025":"AB"},D:{"1":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","322":"9 AB BB CB DB EB"},E:{"1":"B C K L G YB ZB uB vB wB","2":"I c J D E F A pB eB qB rB sB tB fB"},F:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v xB yB zB 0B YB gB 1B ZB","322":"0 1 w x y z"},G:{"1":"BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","2":"I TC UC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"194":"eC"}},B:6,C:"WebAssembly"};


/***/ }),

/***/ 22174:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB zB 0B YB gB 1B ZB","2":"F xB yB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","16":"A"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"Wav audio format"};


/***/ }),

/***/ 91075:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D iB","2":"E F A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G eB qB rB sB tB fB YB ZB uB vB wB","16":"pB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","16":"F"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB"},H:{"1":"LC"},I:{"1":"aB I H OC PC hB QC RC","16":"MC NC"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"wbr (word break opportunity) element"};


/***/ }),

/***/ 17713:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"V W X Y Z a P b H","2":"C K L G M N O","260":"R S T U"},C:{"1":"T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q lB mB","260":"bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB","516":"5 6 7 8 9 AB BB CB DB EB FB GB","580":"0 1 2 3 4 r s t u v w x y z","2049":"UB VB WB XB R S"},D:{"1":"V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t","132":"u v w","260":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U"},E:{"1":"G wB","2":"I c J D E F A pB eB qB rB sB tB fB","1090":"B C K YB ZB","2049":"L uB vB"},F:{"1":"QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g xB yB zB 0B YB gB 1B ZB","132":"h i j","260":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC","1090":"BC CC DC EC FC GC HC","2049":"IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"260":"SC"},P:{"260":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"260":"cC"},R:{"260":"dC"},S:{"516":"eC"}},B:5,C:"Web Animations API"};


/***/ }),

/***/ 48215:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M","130":"N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB X Y Z a P b H dB lB mB","578":"VB WB XB R S T kB U V W"},D:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC","260":"CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"2":"eC"}},B:5,C:"Add to home screen (A2HS)"};


/***/ }),

/***/ 46475:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","1025":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","194":"3 4 5 6 7 8 9 AB","706":"BB CB DB","1025":"EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C G M N O d e f g h i j k l m n o p q r s t xB yB zB 0B YB gB 1B ZB","450":"u v w x","706":"0 y z","1025":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC RC","1025":"H"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","1025":"Q"},L:{"1025":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"UC VC WC XC fB YC ZC aC bC","2":"I TC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Web Bluetooth"};


/***/ }),

/***/ 86902:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"a P b H","2":"C K L G M N O","66":"R S T U V W X Y Z"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB","66":"XB R S T U V W X Y Z"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q xB yB zB 0B YB gB 1B ZB","66":"KB LB MB NB OB PB QB RB SB TB UB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Web Serial API"};


/***/ }),

/***/ 1574:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R S","516":"T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z","130":"O d e f g h i","1028":"a P b H dB nB oB"},E:{"1":"L G vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB","2049":"K ZB uB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC","2049":"EC FC GC HC IC"},H:{"2":"LC"},I:{"2":"aB I MC NC OC PC hB QC","258":"H RC"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","258":"Q"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I","258":"TC UC VC"},Q:{"2":"cC"},R:{"16":"dC"},S:{"2":"eC"}},B:5,C:"Web Share API"};


/***/ }),

/***/ 8423:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"O R S T U V W X Y Z a P b H","2":"C","226":"K L G M N"},C:{"1":"HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB lB mB"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB"},E:{"1":"K L G uB vB wB","2":"I c J D E F A B C pB eB qB rB sB tB fB YB","322":"ZB"},F:{"1":"CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB xB yB zB 0B YB gB 1B ZB"},G:{"1":"KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC","578":"GC","2052":"JC","3076":"HC IC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:2,C:"Web Authentication API"};


/***/ }),

/***/ 34889:
/***/ ((module) => {

module.exports={A:{A:{"2":"iB","8":"J D E F A","129":"B"},B:{"1":"R S T U V W X Y Z a P b H","129":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","129":"I c J D E F A B C K L G M N O d e f g h"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D","129":"E F A B C K L G M N O d e f g h i j k l m n o p q"},E:{"1":"E F A B C K L G tB fB YB ZB uB vB wB","2":"I c pB eB","129":"J D qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B xB yB zB 0B YB gB 1B","129":"C G M N O ZB"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B 5B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"1":"A","2":"D"},K:{"1":"C Q ZB","2":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"8":"A","129":"B"},O:{"129":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"129":"eC"}},B:6,C:"WebGL - 3D Canvas graphics"};


/***/ }),

/***/ 75593:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i lB mB","194":"0 1 2","450":"j k l m n o p q r s t u v w x y z","2242":"3 4 5 6 7 8"},D:{"1":"EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z","578":"1 2 3 4 5 6 7 8 9 AB BB CB DB"},E:{"1":"G wB","2":"I c J D E F A pB eB qB rB sB tB","1090":"B C K L fB YB ZB uB vB"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"0 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC","1090":"DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"VC WC XC fB YC ZC aC bC","2":"I TC UC"},Q:{"578":"cC"},R:{"2":"dC"},S:{"2242":"eC"}},B:6,C:"WebGL 2.0"};


/***/ }),

/***/ 98935:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R","578":"S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB lB mB","194":"JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R","578":"S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B pB eB qB rB sB tB fB","322":"C K L G YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB xB yB zB 0B YB gB 1B ZB","578":"SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"194":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"WebGPU"};


/***/ }),

/***/ 51706:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"a P b H","2":"C K L G M N O","66":"R S T U V W X Y Z"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB","66":"XB R S T U V W X Y Z"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"VB WB XB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB xB yB zB 0B YB gB 1B ZB","66":"LB MB NB OB PB QB RB SB TB UB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"WebHID API"};


/***/ }),

/***/ 27580:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","132":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"16":"I c J D E F A B C K L G","132":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"F B C xB yB zB 0B YB gB 1B ZB","132":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"CSS -webkit-user-drag property"};


/***/ }),

/***/ 19936:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E iB","520":"F A B"},B:{"1":"R S T U V W X Y Z a P b H","8":"C K","388":"L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","132":"I c J D E F A B C K L G M N O d e f g h i j k l"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c","132":"J D E F A B C K L G M N O d e f g h i"},E:{"2":"pB","8":"I c eB qB","520":"J D E F A B C rB sB tB fB YB","1028":"K ZB uB","7172":"L","8196":"G vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F xB yB zB","132":"B C G 0B YB gB 1B ZB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC","1028":"EC FC GC HC IC","3076":"JC KC"},H:{"2":"LC"},I:{"1":"H","2":"MC NC","132":"aB I OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"8":"A B"},O:{"1":"SC"},P:{"1":"TC UC VC WC XC fB YC ZC aC bC","132":"I"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:6,C:"WebM video format"};


/***/ }),

/***/ 57179:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O R a P b H","450":"S T U V W X Y Z"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R a P b H dB nB oB","450":"S T U V W X Y Z"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB xB yB zB 0B YB gB 1B ZB","450":"MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"257":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"Web NFC"};


/***/ }),

/***/ 95001:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"O R S T U V W X Y Z a P b H","2":"C K L G M N"},C:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","8":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q"},D:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c","8":"J D E","132":"F A B C K L G M N O d e f g","260":"h i j k l m n o p"},E:{"2":"I c J D E F A B C K pB eB qB rB sB tB fB YB ZB uB","516":"L G vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F xB yB zB","8":"B 0B","132":"YB gB 1B","260":"C G M N O ZB"},G:{"1":"JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC"},H:{"1":"LC"},I:{"1":"H hB QC RC","2":"aB MC NC OC","132":"I PC"},J:{"2":"D A"},K:{"1":"C Q YB gB ZB","2":"A","132":"B"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"8":"eC"}},B:7,C:"WebP image format"};


/***/ }),

/***/ 9648:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB lB mB","132":"I c","292":"J D E F A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c J D E F A B C K L","260":"G"},E:{"1":"D E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I pB eB","132":"c qB","260":"J rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F xB yB zB 0B","132":"B C YB gB 1B"},G:{"1":"E 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B","132":"hB 3B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","129":"D"},K:{"1":"Q ZB","2":"A","132":"B C YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Web Sockets"};


/***/ }),

/***/ 75310:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB","66":"CB DB EB FB GB bB HB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h i j k l m n o p q r s t u v w x y xB yB zB 0B YB gB 1B ZB","66":"0 1 2 3 4 5 z"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"1":"WC XC fB YC ZC aC bC","2":"I TC UC VC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:7,C:"WebUSB"};


/***/ }),

/***/ 28335:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L S T U V W X Y Z a P b H","66":"R","257":"G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB lB mB","129":"DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","194":"CB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB S T U V W X Y Z a P b H dB nB oB","66":"FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","66":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB Q KB LB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C Q YB gB ZB"},L:{"2":"H"},M:{"2":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"513":"I","516":"TC UC VC WC XC fB YC ZC aC bC"},Q:{"2":"cC"},R:{"66":"dC"},S:{"2":"eC"}},B:7,C:"WebVR API"};


/***/ }),

/***/ 53707:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"2":"jB aB I c J D E F A B C K L G M N O d e f g h lB mB","66":"i j k l m n o","129":"0 1 2 3 4 5 6 7 8 9 p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N"},E:{"1":"J D E F A B C K L G rB sB tB fB YB ZB uB vB wB","2":"I c pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB I MC NC OC PC hB"},J:{"1":"A","2":"D"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"B","2":"A"},O:{"2":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"129":"eC"}},B:5,C:"WebVTT - Web Video Text Tracks"};


/***/ }),

/***/ 82501:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"iB","8":"J D E F"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","8":"jB aB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","8":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 0B YB gB 1B ZB","2":"F xB","8":"yB zB"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"2":"LC"},I:{"1":"H MC QC RC","2":"aB I NC OC PC hB"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","8":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Web Workers"};


/***/ }),

/***/ 85515:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"2":"C K L G M N O","132":"R S T U V W X Y Z a P b H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB lB mB","322":"WB XB R S T kB U V W X Y Z a P b H dB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q","66":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB","132":"R S T U V W X Y Z a P b H dB nB oB"},E:{"2":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z xB yB zB 0B YB gB 1B ZB","66":"AB BB CB DB EB FB GB HB IB JB Q KB","132":"LB MB NB OB PB QB RB SB TB UB VB WB XB"},G:{"2":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"2":"LC"},I:{"2":"aB I H MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"2":"A B C YB gB ZB","16":"Q"},L:{"132":"H"},M:{"322":"P"},N:{"2":"A B"},O:{"2":"SC"},P:{"2":"I TC UC VC WC XC fB YC","132":"ZC aC bC"},Q:{"2":"cC"},R:{"2":"dC"},S:{"2":"eC"}},B:5,C:"WebXR Device API"};


/***/ }),

/***/ 70441:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"R S T U V W X Y Z a P b H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m lB mB","194":"n o p q r s t"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t"},E:{"1":"A B C K L G tB fB YB ZB uB vB wB","2":"I c J D E F pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g h xB yB zB 0B YB gB 1B ZB"},G:{"1":"8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"CSS will-change property"};


/***/ }),

/***/ 15216:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB mB","2":"jB aB lB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I"},E:{"1":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"I c pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB gB 1B ZB","2":"F B xB yB zB 0B"},G:{"1":"E 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB"},H:{"2":"LC"},I:{"1":"H QC RC","2":"aB MC NC OC PC hB","130":"I"},J:{"1":"D A"},K:{"1":"B C Q YB gB ZB","2":"A"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:2,C:"WOFF - Web Open Font Format"};


/***/ }),

/***/ 92249:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B iB"},B:{"1":"L G M N O R S T U V W X Y Z a P b H","2":"C K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","2":"I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t"},E:{"1":"C K L G ZB uB vB wB","2":"I c J D E F pB eB qB rB sB tB","132":"A B fB YB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C G M N O d e f g xB yB zB 0B YB gB 1B ZB"},G:{"1":"9B AC BC CC DC EC FC GC HC IC JC KC","2":"E eB 2B hB 3B 4B 5B 6B 7B 8B"},H:{"2":"LC"},I:{"1":"H","2":"aB I MC NC OC PC hB QC RC"},J:{"2":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"2":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"WOFF 2.0 - Web Open Font Format"};


/***/ }),

/***/ 72383:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB I c J D E F A B C K L lB mB"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","4":"0 1 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z"},E:{"1":"F A B C K L G tB fB YB ZB uB vB wB","4":"I c J D E pB eB qB rB sB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","2":"F B C xB yB zB 0B YB gB 1B ZB","4":"G M N O d e f g h i j k l m n o"},G:{"1":"7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","4":"E eB 2B hB 3B 4B 5B 6B"},H:{"2":"LC"},I:{"1":"H","4":"aB I MC NC OC PC hB QC RC"},J:{"4":"D A"},K:{"1":"Q","2":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"4":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"4":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:5,C:"CSS3 word-break"};


/***/ }),

/***/ 40133:
/***/ ((module) => {

module.exports={A:{A:{"4":"J D E F A B iB"},B:{"1":"O R S T U V W X Y Z a P b H","4":"C K L G M N"},C:{"1":"7 8 9 AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","4":"0 1 2 3 4 5 6 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","4":"I c J D E F A B C K L G M N O d e f g"},E:{"1":"D E F A B C K L G rB sB tB fB YB ZB uB vB wB","4":"I c J pB eB qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F xB yB","4":"B C zB 0B YB gB 1B"},G:{"1":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","4":"eB 2B hB 3B 4B"},H:{"4":"LC"},I:{"1":"H QC RC","4":"aB I MC NC OC PC hB"},J:{"1":"A","4":"D"},K:{"1":"Q","4":"A B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"4":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"4":"eC"}},B:5,C:"CSS3 Overflow-wrap"};


/***/ }),

/***/ 3334:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D iB","132":"E F","260":"A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB","2":"jB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","2":"pB eB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB","2":"F"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"4":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"Cross-document messaging"};


/***/ }),

/***/ 52711:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"J D iB"},B:{"1":"C K L G M N O","4":"R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB","4":"I c J D E F A B C K L G M N PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","16":"jB aB lB mB"},D:{"4":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J D E F A B C K L G M N O d e f g h i j"},E:{"4":"J D E F A B C K L G qB rB sB tB fB YB ZB uB vB wB","16":"I c pB eB"},F:{"4":"0 1 2 3 4 5 6 7 8 9 C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB 1B ZB","16":"F B xB yB zB 0B YB gB"},G:{"4":"E 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","16":"eB 2B hB 3B 4B"},H:{"2":"LC"},I:{"4":"I H PC hB QC RC","16":"aB MC NC OC"},J:{"4":"D A"},K:{"4":"Q ZB","16":"A B C YB gB"},L:{"4":"H"},M:{"4":"P"},N:{"1":"A B"},O:{"4":"SC"},P:{"4":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"4":"cC"},R:{"4":"dC"},S:{"1":"eC"}},B:6,C:"X-Frame-Options HTTP header"};


/***/ }),

/***/ 94381:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F iB","132":"A B"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","2":"jB aB","260":"A B","388":"J D E F","900":"I c lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","16":"I c J","132":"n o","388":"D E F A B C K L G M N O d e f g h i j k l m"},E:{"1":"E F A B C K L G sB tB fB YB ZB uB vB wB","2":"I pB eB","132":"D rB","388":"c J qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB","2":"F B xB yB zB 0B YB gB 1B","132":"G M N"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","2":"eB 2B hB","132":"5B","388":"3B 4B"},H:{"2":"LC"},I:{"1":"H RC","2":"MC NC OC","388":"QC","900":"aB I PC hB"},J:{"132":"A","388":"D"},K:{"1":"C Q ZB","2":"A B YB gB"},L:{"1":"H"},M:{"1":"P"},N:{"132":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:1,C:"XMLHttpRequest advanced features"};


/***/ }),

/***/ 92605:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"1":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"1":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"1":"LC"},I:{"1":"aB I H MC NC OC PC hB QC RC"},J:{"1":"D A"},K:{"1":"A B C Q YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"2":"dC"},S:{"1":"eC"}},B:1,C:"XHTML served as application/xhtml+xml"};


/***/ }),

/***/ 7278:
/***/ ((module) => {

module.exports={A:{A:{"2":"F A B iB","4":"J D E"},B:{"2":"C K L G M N O","8":"R S T U V W X Y Z a P b H"},C:{"8":"0 1 2 3 4 5 6 7 8 9 jB aB I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB lB mB"},D:{"8":"0 1 2 3 4 5 6 7 8 9 I c J D E F A B C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB"},E:{"8":"I c J D E F A B C K L G pB eB qB rB sB tB fB YB ZB uB vB wB"},F:{"8":"0 1 2 3 4 5 6 7 8 9 F B C G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB xB yB zB 0B YB gB 1B ZB"},G:{"8":"E eB 2B hB 3B 4B 5B 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC"},H:{"8":"LC"},I:{"8":"aB I H MC NC OC PC hB QC RC"},J:{"8":"D A"},K:{"8":"A B C Q YB gB ZB"},L:{"8":"H"},M:{"8":"P"},N:{"2":"A B"},O:{"8":"SC"},P:{"8":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"8":"cC"},R:{"8":"dC"},S:{"8":"eC"}},B:7,C:"XHTML+SMIL animation"};


/***/ }),

/***/ 12227:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","260":"J D E F iB"},B:{"1":"C K L G M N O R S T U V W X Y Z a P b H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 C K L G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB","132":"B","260":"jB aB I c J D lB mB","516":"E F A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB","132":"I c J D E F A B C K L G M N O d e f g h i j k l m n o"},E:{"1":"E F A B C K L G sB tB fB YB ZB uB vB wB","132":"I c J D pB eB qB rB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB","16":"F xB","132":"B C G M N yB zB 0B YB gB 1B ZB"},G:{"1":"E 6B 7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC","132":"eB 2B hB 3B 4B 5B"},H:{"132":"LC"},I:{"1":"H QC RC","132":"aB I MC NC OC PC hB"},J:{"132":"D A"},K:{"1":"Q","16":"A","132":"B C YB gB ZB"},L:{"1":"H"},M:{"1":"P"},N:{"1":"A B"},O:{"1":"SC"},P:{"1":"I TC UC VC WC XC fB YC ZC aC bC"},Q:{"1":"cC"},R:{"1":"dC"},S:{"1":"eC"}},B:4,C:"DOM Parsing and Serialization"};


/***/ }),

/***/ 20793:
/***/ ((module) => {

module.exports = {
  1: 'ls', // WHATWG Living Standard
  2: 'rec', // W3C Recommendation
  3: 'pr', // W3C Proposed Recommendation
  4: 'cr', // W3C Candidate Recommendation
  5: 'wd', // W3C Working Draft
  6: 'other', // Non-W3C, but reputable
  7: 'unoff' // Unofficial, Editor's Draft or W3C "Note"
}


/***/ }),

/***/ 31708:
/***/ ((module) => {

module.exports = {
  y: 1 << 0,
  n: 1 << 1,
  a: 1 << 2,
  p: 1 << 3,
  u: 1 << 4,
  x: 1 << 5,
  d: 1 << 6
}


/***/ }),

/***/ 87462:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const browsers = __nccwpck_require__(56609).browsers
const versions = __nccwpck_require__(73958).browserVersions
const agentsData = __nccwpck_require__(306)

function unpackBrowserVersions(versionsData) {
  return Object.keys(versionsData).reduce((usage, version) => {
    usage[versions[version]] = versionsData[version]
    return usage
  }, {})
}

module.exports.agents = Object.keys(agentsData).reduce((map, key) => {
  let versionsData = agentsData[key]
  map[browsers[key]] = Object.keys(versionsData).reduce((data, entry) => {
    if (entry === 'A') {
      data.usage_global = unpackBrowserVersions(versionsData[entry])
    } else if (entry === 'C') {
      data.versions = versionsData[entry].reduce((list, version) => {
        if (version === '') {
          list.push(null)
        } else {
          list.push(versions[version])
        }
        return list
      }, [])
    } else if (entry === 'D') {
      data.prefix_exceptions = unpackBrowserVersions(versionsData[entry])
    } else if (entry === 'E') {
      data.browser = versionsData[entry]
    } else if (entry === 'F') {
      data.release_date = Object.keys(versionsData[entry]).reduce(
        (map2, key2) => {
          map2[versions[key2]] = versionsData[entry][key2]
          return map2
        },
        {}
      )
    } else {
      // entry is B
      data.prefix = versionsData[entry]
    }
    return data
  }, {})
  return map
}, {})


/***/ }),

/***/ 73958:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports.browserVersions = __nccwpck_require__(95582)


/***/ }),

/***/ 56609:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports.browsers = __nccwpck_require__(60257)


/***/ }),

/***/ 13206:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const statuses = __nccwpck_require__(20793)
const supported = __nccwpck_require__(31708)
const browsers = __nccwpck_require__(56609).browsers
const versions = __nccwpck_require__(73958).browserVersions

const MATH2LOG = Math.log(2)

function unpackSupport(cipher) {
  // bit flags
  let stats = Object.keys(supported).reduce((list, support) => {
    if (cipher & supported[support]) list.push(support)
    return list
  }, [])

  // notes
  let notes = cipher >> 7
  let notesArray = []
  while (notes) {
    let note = Math.floor(Math.log(notes) / MATH2LOG) + 1
    notesArray.unshift(`#${note}`)
    notes -= Math.pow(2, note - 1)
  }

  return stats.concat(notesArray).join(' ')
}

function unpackFeature(packed) {
  let unpacked = { status: statuses[packed.B], title: packed.C }
  unpacked.stats = Object.keys(packed.A).reduce((browserStats, key) => {
    let browser = packed.A[key]
    browserStats[browsers[key]] = Object.keys(browser).reduce(
      (stats, support) => {
        let packedVersions = browser[support].split(' ')
        let unpacked2 = unpackSupport(support)
        packedVersions.forEach(v => (stats[versions[v]] = unpacked2))
        return stats
      },
      {}
    )
    return browserStats
  }, {})
  return unpacked
}

module.exports = unpackFeature
module.exports.default = unpackFeature


/***/ }),

/***/ 65334:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*
 * Load this dynamically so that it
 * doesn't appear in the rollup bundle.
 */

module.exports.features = __nccwpck_require__(28649)


/***/ }),

/***/ 64006:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports.agents = __nccwpck_require__(87462).agents
module.exports.feature = __nccwpck_require__(13206)
module.exports.features = __nccwpck_require__(65334).features
module.exports.region = __nccwpck_require__(53506)


/***/ }),

/***/ 53506:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const browsers = __nccwpck_require__(56609).browsers

function unpackRegion(packed) {
  return Object.keys(packed).reduce((list, browser) => {
    let data = packed[browser]
    list[browsers[browser]] = Object.keys(data).reduce((memo, key) => {
      let stats = data[key]
      if (key === '_') {
        stats.split(' ').forEach(version => (memo[version] = null))
      } else {
        memo[key] = stats
      }
      return memo
    }, {})
    return list
  }, {})
}

module.exports = unpackRegion
module.exports.default = unpackRegion


/***/ }),

/***/ 43:
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({value:!0}));var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},o=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},a=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},s=/^#([0-9a-f]{3,8})$/i,i=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,o=Math.max(t,n,e),a=o-Math.min(t,n,e),s=a?o===t?(n-e)/a:o===n?2+(e-t)/a:4+(t-n)/a:0;return{h:60*(s<0?s+6:s),s:o?a/o*100:0,v:o/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var o=Math.floor(t),a=e*(1-n),s=e*(1-(t-o)*n),i=e*(1-(1-t+o)*n),h=o%6;return{r:255*[e,s,a,a,i,e][h],g:255*[i,e,e,s,a,a][h],b:255*[a,a,i,e,e,s][h],a:u}},d=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},g=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},p=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,c=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=s.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:o({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||c.exec(t);if(!n)return null;var e,u,o=d({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(o)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,a=r.a,s=void 0===a?1:a;return t(n)&&t(e)&&t(u)?o({r:Number(n),g:Number(e),b:Number(u),a:Number(s)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,o=r.a,a=void 0===o?1:o;if(!t(n)||!t(e)||!t(u))return null;var s=d({h:Number(n),s:Number(e),l:Number(u),a:Number(a)});return f(s)},"hsl"],[function(r){var n=r.h,o=r.s,a=r.v,s=r.a,i=void 0===s?1:s;if(!t(n)||!t(o)||!t(a))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(o),v:Number(a),a:Number(i)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},M=function(r,t){var n=p(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},I=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},H=function(r,t){var n=p(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},$=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(I(this.rgba),2)},r.prototype.isDark=function(){return I(this.rgba)<.5},r.prototype.isLight=function(){return I(this.rgba)>=.5},r.prototype.toHex=function(){return r=a(this.rgba),t=r.r,e=r.g,u=r.b,s=(o=r.a)<1?i(n(255*o)):"","#"+i(t)+i(e)+i(u)+s;var r,t,e,u,o,s},r.prototype.toRgb=function(){return a(this.rgba)},r.prototype.toRgbString=function(){return r=a(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return g(p(this.rgba))},r.prototype.toHslString=function(){return r=g(p(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return j({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,-r))},r.prototype.grayscale=function(){return j(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),j(H(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),j(H(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?j({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=p(this.rgba);return"number"==typeof r?j({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===j(r).toHex()},r}(),j=function(r){return r instanceof $?r:new $(r)},w=[];exports.Colord=$,exports.colord=j,exports.extend=function(r){r.forEach(function(r){w.indexOf(r)<0&&(r($,y),w.push(r))})},exports.getFormat=function(r){return x(r)[1]},exports.random=function(){return new $({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};


/***/ }),

/***/ 44517:
/***/ ((module) => {

module.exports=function(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,o=r[this.toHex()];if(o)return o;if(null==f?void 0:f.closest){var n=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=n,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])};


/***/ }),

/***/ 36863:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attributeRules = void 0;
var boolbase_1 = __nccwpck_require__(44159);
/**
 * All reserved characters in a regex, used for escaping.
 *
 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
 */
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
    return value.replace(reChars, "\\$&");
}
/**
 * Attribute selectors
 */
exports.attributeRules = {
    equals: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length === value.length &&
                    attr.toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
    },
    hyphen: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function hyphenIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    (attr.length === len || attr.charAt(len) === "-") &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                (attr.length === len || attr.charAt(len) === "-") &&
                attr.substr(0, len) === value &&
                next(elem));
        };
    },
    element: function (next, _a, _b) {
        var name = _a.name, value = _a.value, ignoreCase = _a.ignoreCase;
        var adapter = _b.adapter;
        if (/\s/.test(value)) {
            return boolbase_1.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)" + escapeRegex(value) + "(?:$|\\s)", ignoreCase ? "i" : "");
        return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                attr.length >= value.length &&
                regex.test(attr) &&
                next(elem));
        };
    },
    exists: function (next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };
    },
    start: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
            return boolbase_1.falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= len &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
                next(elem);
        };
    },
    end: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
            return boolbase_1.falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var _a;
                return ((_a = adapter
                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
                next(elem);
        };
    },
    any: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
            return boolbase_1.falseFunc;
        }
        if (data.ignoreCase) {
            var regex_1 = new RegExp(escapeRegex(value), "i");
            return function anyIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= value.length &&
                    regex_1.test(attr) &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
                next(elem);
        };
    },
    not: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
            return function (elem) {
                return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
        }
        else if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return ((attr == null ||
                    attr.length !== value.length ||
                    attr.toLowerCase() !== value) &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
    },
};


/***/ }),

/***/ 35030:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
var css_what_1 = __nccwpck_require__(19218);
var boolbase_1 = __nccwpck_require__(44159);
var sort_1 = __importDefault(__nccwpck_require__(57320));
var procedure_1 = __nccwpck_require__(47396);
var general_1 = __nccwpck_require__(45374);
var subselects_1 = __nccwpck_require__(15813);
/**
 * Compiles a selector to an executable function.
 *
 * @param selector Selector to compile.
 * @param options Compilation options.
 * @param context Optional context for the selector.
 */
function compile(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return subselects_1.ensureIsTag(next, options.adapter);
}
exports.compile = compile;
function compileUnsafe(selector, options, context) {
    var token = typeof selector === "string" ? css_what_1.parse(selector, options) : selector;
    return compileToken(token, options, context);
}
exports.compileUnsafe = compileUnsafe;
function includesScopePseudo(t) {
    return (t.type === "pseudo" &&
        (t.name === "scope" ||
            (Array.isArray(t.data) &&
                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
}
var DESCENDANT_TOKEN = { type: "descendant" };
var FLEXIBLE_DESCENDANT_TOKEN = {
    type: "_flexibleDescendant",
};
var SCOPE_TOKEN = { type: "pseudo", name: "scope", data: null };
/*
 * CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
 * http://www.w3.org/TR/selectors4/#absolutizing
 */
function absolutize(token, _a, context) {
    var adapter = _a.adapter;
    // TODO Use better check if the context is a document
    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return e === subselects_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
    }));
    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t = token_1[_i];
        if (t.length > 0 && procedure_1.isTraversal(t[0]) && t[0].type !== "descendant") {
            // Don't continue in else branch
        }
        else if (hasContext && !t.some(includesScopePseudo)) {
            t.unshift(DESCENDANT_TOKEN);
        }
        else {
            continue;
        }
        t.unshift(SCOPE_TOKEN);
    }
}
function compileToken(token, options, context) {
    var _a;
    token = token.filter(function (t) { return t.length > 0; });
    token.forEach(sort_1.default);
    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
    var isArrayContext = Array.isArray(context);
    var finalContext = context && (Array.isArray(context) ? context : [context]);
    absolutize(token, options, finalContext);
    var shouldTestNextSiblings = false;
    var query = token
        .map(function (rules) {
        if (rules.length >= 2) {
            var first = rules[0], second = rules[1];
            if (first.type !== "pseudo" || first.name !== "scope") {
                // Ignore
            }
            else if (isArrayContext && second.type === "descendant") {
                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
            }
            else if (second.type === "adjacent" ||
                second.type === "sibling") {
                shouldTestNextSiblings = true;
            }
        }
        return compileRules(rules, options, finalContext);
    })
        .reduce(reduceRules, boolbase_1.falseFunc);
    query.shouldTestNextSiblings = shouldTestNextSiblings;
    return query;
}
exports.compileToken = compileToken;
function compileRules(rules, options, context) {
    var _a;
    return rules.reduce(function (previous, rule) {
        return previous === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : general_1.compileGeneralSelector(previous, rule, options, context, compileToken);
    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
}
function reduceRules(a, b) {
    if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
        return a;
    }
    if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
        return b;
    }
    return function combine(elem) {
        return a(elem) || b(elem);
    };
}


/***/ }),

/***/ 45374:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compileGeneralSelector = void 0;
var attributes_1 = __nccwpck_require__(36863);
var pseudo_selectors_1 = __nccwpck_require__(89312);
/*
 * All available rules
 */
function compileGeneralSelector(next, selector, options, context, compileToken) {
    var adapter = options.adapter, equals = options.equals;
    switch (selector.type) {
        case "pseudo-element":
            throw new Error("Pseudo-elements are not supported by css-select");
        case "attribute":
            return attributes_1.attributeRules[selector.action](next, selector, options);
        case "pseudo":
            return pseudo_selectors_1.compilePseudoSelector(next, selector, options, context, compileToken);
        // Tags
        case "tag":
            return function tag(elem) {
                return adapter.getName(elem) === selector.name && next(elem);
            };
        // Traversal
        case "descendant":
            if (options.cacheResults === false ||
                typeof WeakSet === "undefined") {
                return function descendant(elem) {
                    var current = elem;
                    while ((current = adapter.getParent(current))) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            // @ts-expect-error `ElementNode` is not extending object
            // eslint-disable-next-line no-case-declarations
            var isFalseCache_1 = new WeakSet();
            return function cachedDescendant(elem) {
                var current = elem;
                while ((current = adapter.getParent(current))) {
                    if (!isFalseCache_1.has(current)) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                        isFalseCache_1.add(current);
                    }
                }
                return false;
            };
        case "_flexibleDescendant":
            // Include element itself, only used while querying an array
            return function flexibleDescendant(elem) {
                var current = elem;
                do {
                    if (adapter.isTag(current) && next(current))
                        return true;
                } while ((current = adapter.getParent(current)));
                return false;
            };
        case "parent":
            return function parent(elem) {
                return adapter
                    .getChildren(elem)
                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });
            };
        case "child":
            return function child(elem) {
                var parent = adapter.getParent(elem);
                return parent != null && adapter.isTag(parent) && next(parent);
            };
        case "sibling":
            return function sibling(elem) {
                var siblings = adapter.getSiblings(elem);
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling) && next(currentSibling)) {
                        return true;
                    }
                }
                return false;
            };
        case "adjacent":
            return function adjacent(elem) {
                var siblings = adapter.getSiblings(elem);
                var lastElement;
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling)) {
                        lastElement = currentSibling;
                    }
                }
                return !!lastElement && next(lastElement);
            };
        case "universal":
            return next;
    }
}
exports.compileGeneralSelector = compileGeneralSelector;


/***/ }),

/***/ 4508:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
var DomUtils = __importStar(__nccwpck_require__(11754));
var boolbase_1 = __nccwpck_require__(44159);
var compile_1 = __nccwpck_require__(35030);
var subselects_1 = __nccwpck_require__(15813);
var defaultEquals = function (a, b) { return a === b; };
var defaultOptions = {
    adapter: DomUtils,
    equals: defaultEquals,
};
function convertOptionFormats(options) {
    var _a, _b, _c, _d;
    /*
     * We force one format of options to the other one.
     */
    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
    var opts = options !== null && options !== void 0 ? options : defaultOptions;
    // @ts-expect-error Same as above.
    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
    // @ts-expect-error `equals` does not exist on `Options`
    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
    return opts;
}
function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
    };
}
/**
 * Compiles the query, returns a function.
 */
exports.compile = wrapCompile(compile_1.compile);
exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
exports._compileToken = wrapCompile(compile_1.compileToken);
function getSelectorFunc(searchFunc) {
    return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
            query = compile_1.compileUnsafe(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
    };
}
function prepareContext(elems, adapter, shouldTestNextSiblings) {
    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }
    /*
     * Add siblings if the query requires them.
     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
     */
    if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems)
        ? adapter.removeSubsets(elems)
        : adapter.getChildren(elems);
}
exports.prepareContext = prepareContext;
function appendNextSiblings(elem, adapter) {
    // Order matters because jQuery seems to check the children before the siblings
    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    for (var i = 0; i < elems.length; i++) {
        var nextSiblings = subselects_1.getNextSiblings(elems[i], adapter);
        elems.push.apply(elems, nextSiblings);
    }
    return elems;
}
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns All matching elements.
 *
 */
exports.selectAll = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.falseFunc || !elems || elems.length === 0
        ? []
        : options.adapter.findAll(query, elems);
});
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns the first match, or null if there was no match.
 */
exports.selectOne = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.falseFunc || !elems || elems.length === 0
        ? null
        : options.adapter.findOne(query, elems);
});
/**
 * Tests whether or not an element is matched by query.
 *
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elem The element to test if it matches the query.
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns
 */
function is(elem, query, options) {
    var opts = convertOptionFormats(options);
    return (typeof query === "function" ? query : compile_1.compile(query, opts))(elem);
}
exports.is = is;
/**
 * Alias for selectAll(query, elems, options).
 * @see [compile] for supported selector queries.
 */
exports.default = exports.selectAll;
// Export filters, pseudos and aliases to allow users to supply their own.
var pseudo_selectors_1 = __nccwpck_require__(89312);
Object.defineProperty(exports, "filters", ({ enumerable: true, get: function () { return pseudo_selectors_1.filters; } }));
Object.defineProperty(exports, "pseudos", ({ enumerable: true, get: function () { return pseudo_selectors_1.pseudos; } }));
Object.defineProperty(exports, "aliases", ({ enumerable: true, get: function () { return pseudo_selectors_1.aliases; } }));


/***/ }),

/***/ 47396:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTraversal = exports.procedure = void 0;
exports.procedure = {
    universal: 50,
    tag: 30,
    attribute: 1,
    pseudo: 0,
    "pseudo-element": 0,
    descendant: -1,
    child: -1,
    parent: -1,
    sibling: -1,
    adjacent: -1,
    _flexibleDescendant: -1,
};
function isTraversal(t) {
    return exports.procedure[t.type] < 0;
}
exports.isTraversal = isTraversal;


/***/ }),

/***/ 24176:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aliases = void 0;
/**
 * Aliases are pseudos that are expressed as selectors.
 */
exports.aliases = {
    // Links
    "any-link": ":is(a, area, link)[href]",
    link: ":any-link:not(:visited)",
    // Forms
    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
    enabled: ":not(:disabled)",
    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
    required: ":is(input, select, textarea)[required]",
    optional: ":is(input, select, textarea):not([required])",
    // JQuery extensions
    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
    checkbox: "[type=checkbox]",
    file: "[type=file]",
    password: "[type=password]",
    radio: "[type=radio]",
    reset: "[type=reset]",
    image: "[type=image]",
    submit: "[type=submit]",
    parent: ":not(:empty)",
    header: ":is(h1, h2, h3, h4, h5, h6)",
    button: ":is(button, input[type=button])",
    input: ":is(input, textarea, select, button)",
    text: "input:is(:not([type!='']), [type=text])",
};


/***/ }),

/***/ 51686:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filters = void 0;
var nth_check_1 = __importDefault(__nccwpck_require__(51260));
var boolbase_1 = __nccwpck_require__(44159);
function getChildFunc(next, adapter) {
    return function (elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
    };
}
exports.filters = {
    contains: function (next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
            return next(elem) && adapter.getText(elem).includes(text);
        };
    },
    icontains: function (next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
            return (next(elem) &&
                adapter.getText(elem).toLowerCase().includes(itext));
        };
    },
    // Location specific methods
    "nth-child": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
                if (equals(elem, siblings[i]))
                    break;
                if (adapter.isTag(siblings[i])) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-last-child": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
                if (equals(elem, siblings[i]))
                    break;
                if (adapter.isTag(siblings[i])) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-of-type": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    break;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === adapter.getName(elem)) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-last-of-type": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    break;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === adapter.getName(elem)) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    // TODO determine the actual root element
    root: function (next, _rule, _a) {
        var adapter = _a.adapter;
        return function (elem) {
            var parent = adapter.getParent(elem);
            return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
    },
    scope: function (next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
            // Equivalent to :root
            return exports.filters.root(next, rule, options);
        }
        if (context.length === 1) {
            // NOTE: can't be unpacked, as :has uses this for side-effects
            return function (elem) { return equals(context[0], elem) && next(elem); };
        }
        return function (elem) { return context.includes(elem) && next(elem); };
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive"),
};
/**
 * Dynamic state pseudos. These depend on optional Adapter methods.
 *
 * @param name The name of the adapter method to call.
 * @returns Pseudo for the `filters` object.
 */
function dynamicStatePseudo(name) {
    return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
            return boolbase_1.falseFunc;
        }
        return function active(elem) {
            return func(elem) && next(elem);
        };
    };
}


/***/ }),

/***/ 89312:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
/*
 * Pseudo selectors
 *
 * Pseudo selectors are available in three forms:
 *
 * 1. Filters are called when the selector is compiled and return a function
 *  that has to return either false, or the results of `next()`.
 * 2. Pseudos are called on execution. They have to return a boolean.
 * 3. Subselects work like filters, but have an embedded selector that will be run separately.
 *
 * Filters are great if you want to do some pre-processing, or change the call order
 * of `next()` and your code.
 * Pseudos should be used to implement simple checks.
 */
var boolbase_1 = __nccwpck_require__(44159);
var css_what_1 = __nccwpck_require__(19218);
var filters_1 = __nccwpck_require__(51686);
Object.defineProperty(exports, "filters", ({ enumerable: true, get: function () { return filters_1.filters; } }));
var pseudos_1 = __nccwpck_require__(8952);
Object.defineProperty(exports, "pseudos", ({ enumerable: true, get: function () { return pseudos_1.pseudos; } }));
var aliases_1 = __nccwpck_require__(24176);
Object.defineProperty(exports, "aliases", ({ enumerable: true, get: function () { return aliases_1.aliases; } }));
var subselects_1 = __nccwpck_require__(15813);
function compilePseudoSelector(next, selector, options, context, compileToken) {
    var name = selector.name, data = selector.data;
    if (Array.isArray(data)) {
        return subselects_1.subselects[name](next, data, options, context, compileToken);
    }
    if (name in aliases_1.aliases) {
        if (data != null) {
            throw new Error("Pseudo " + name + " doesn't have any arguments");
        }
        // The alias has to be parsed here, to make sure options are respected.
        var alias = css_what_1.parse(aliases_1.aliases[name], options);
        return subselects_1.subselects.is(next, alias, options, context, compileToken);
    }
    if (name in filters_1.filters) {
        return filters_1.filters[name](next, data, options, context);
    }
    if (name in pseudos_1.pseudos) {
        var pseudo_1 = pseudos_1.pseudos[name];
        pseudos_1.verifyPseudoArgs(pseudo_1, name, data);
        return pseudo_1 === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : next === boolbase_1.trueFunc
                ? function (elem) { return pseudo_1(elem, options, data); }
                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };
    }
    throw new Error("unmatched pseudo-class :" + name);
}
exports.compilePseudoSelector = compilePseudoSelector;


/***/ }),

/***/ 8952:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyPseudoArgs = exports.pseudos = void 0;
// While filters are precompiled, pseudos get called when they are needed
exports.pseudos = {
    empty: function (elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function (elem) {
            // FIXME: `getText` call is potentially expensive.
            return adapter.isTag(elem) || adapter.getText(elem) !== "";
        });
    },
    "first-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var firstChild = adapter
            .getSiblings(elem)
            .find(function (elem) { return adapter.isTag(elem); });
        return firstChild != null && equals(elem, firstChild);
    },
    "last-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
                return true;
            if (adapter.isTag(siblings[i]))
                break;
        }
        return false;
    },
    "first-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "last-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "only-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter
            .getSiblings(elem)
            .every(function (sibling) {
            return equals(elem, sibling) ||
                !adapter.isTag(sibling) ||
                adapter.getName(sibling) !== elemName;
        });
    },
    "only-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter
            .getSiblings(elem)
            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });
    },
};
function verifyPseudoArgs(func, name, subselect) {
    if (subselect === null) {
        if (func.length > 2) {
            throw new Error("pseudo-selector :" + name + " requires an argument");
        }
    }
    else if (func.length === 2) {
        throw new Error("pseudo-selector :" + name + " doesn't have any arguments");
    }
}
exports.verifyPseudoArgs = verifyPseudoArgs;


/***/ }),

/***/ 15813:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
var boolbase_1 = __nccwpck_require__(44159);
var procedure_1 = __nccwpck_require__(47396);
/** Used as a placeholder for :has. Will be replaced with the actual element. */
exports.PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next, adapter) {
    if (next === boolbase_1.falseFunc)
        return boolbase_1.falseFunc;
    return function (elem) { return adapter.isTag(elem) && next(elem); };
}
exports.ensureIsTag = ensureIsTag;
function getNextSiblings(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (siblings.length <= 1)
        return [];
    var elemIndex = siblings.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
}
exports.getNextSiblings = getNextSiblings;
var is = function (next, token, options, context, compileToken) {
    var opts = {
        xmlMode: !!options.xmlMode,
        adapter: options.adapter,
        equals: options.equals,
    };
    var func = compileToken(token, opts, context);
    return function (elem) { return func(elem) && next(elem); };
};
/*
 * :not, :has, :is and :matches have to compile selectors
 * doing this in src/pseudos.ts would lead to circular dependencies,
 * so we add them here
 */
exports.subselects = {
    is: is,
    /**
     * `:matches` is an alias for `:is`.
     */
    matches: is,
    not: function (next, token, options, context, compileToken) {
        var opts = {
            xmlMode: !!options.xmlMode,
            adapter: options.adapter,
            equals: options.equals,
        };
        var func = compileToken(token, opts, context);
        if (func === boolbase_1.falseFunc)
            return next;
        if (func === boolbase_1.trueFunc)
            return boolbase_1.falseFunc;
        return function not(elem) {
            return !func(elem) && next(elem);
        };
    },
    has: function (next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = {
            xmlMode: !!options.xmlMode,
            adapter: adapter,
            equals: options.equals,
        };
        // @ts-expect-error Uses an array as a pointer to the current element (side effects)
        var context = subselect.some(function (s) {
            return s.some(procedure_1.isTraversal);
        })
            ? [exports.PLACEHOLDER_ELEMENT]
            : undefined;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (compiled === boolbase_1.trueFunc) {
            return function (elem) {
                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
            };
        }
        var hasElement = ensureIsTag(compiled, adapter);
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;
        /*
         * `shouldTestNextSiblings` will only be true if the query starts with
         * a traversal (sibling or adjacent). That means we will always have a context.
         */
        if (context) {
            return function (elem) {
                context[0] = elem;
                var childs = adapter.getChildren(elem);
                var nextElements = shouldTestNextSiblings
                    ? __spreadArray(__spreadArray([], childs), getNextSiblings(elem, adapter)) : childs;
                return (next(elem) && adapter.existsOne(hasElement, nextElements));
            };
        }
        return function (elem) {
            return next(elem) &&
                adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
    },
};


/***/ }),

/***/ 57320:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var procedure_1 = __nccwpck_require__(47396);
var attributes = {
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4,
};
/**
 * Sort the parts of the passed selector,
 * as there is potential for optimization
 * (some types of selectors are faster than others)
 *
 * @param arr Selector to sort
 */
function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
            continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
        }
    }
}
exports.default = sortByProcedure;
function getProcedure(token) {
    var proc = procedure_1.procedure[token.type];
    if (token.type === "attribute") {
        proc = attributes[token.action];
        if (proc === attributes.equals && token.name === "id") {
            // Prefer ID selectors (eg. #ID)
            proc = 9;
        }
        if (token.ignoreCase) {
            /*
             * IgnoreCase adds some overhead, prefer "normal" token
             * this is a binary operation, to ensure it's still an int
             */
            proc >>= 1;
        }
    }
    else if (token.type === "pseudo") {
        if (!token.data) {
            proc = 3;
        }
        else if (token.name === "has" || token.name === "contains") {
            proc = 0; // Expensive in any case
        }
        else if (Array.isArray(token.data)) {
            // "matches" and "not"
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
                // TODO better handling of complex selectors
                if (token.data[i].length !== 1)
                    continue;
                var cur = getProcedure(token.data[i][0]);
                // Avoid executing :has or :contains
                if (cur === 0) {
                    proc = 0;
                    break;
                }
                if (cur > proc)
                    proc = cur;
            }
            if (token.data.length > 1 && proc > 0)
                proc -= 1;
        }
        else {
            proc = 1;
        }
    }
    return proc;
}


/***/ }),

/***/ 67355:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const mdnAtrules = __nccwpck_require__(53523);
const mdnProperties = __nccwpck_require__(95863);
const mdnSyntaxes = __nccwpck_require__(49023);
const patch = __nccwpck_require__(15909);
const extendSyntax = /^\s*\|\s*/;

function preprocessAtrules(dict) {
    const result = Object.create(null);

    for (const atruleName in dict) {
        const atrule = dict[atruleName];
        let descriptors = null;

        if (atrule.descriptors) {
            descriptors = Object.create(null);

            for (const descriptor in atrule.descriptors) {
                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
            }
        }

        result[atruleName.substr(1)] = {
            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
            descriptors
        };
    }

    return result;
}

function patchDictionary(dict, patchDict) {
    const result = {};

    // copy all syntaxes for an original dict
    for (const key in dict) {
        result[key] = dict[key].syntax || dict[key];
    }

    // apply a patch
    for (const key in patchDict) {
        if (key in dict) {
            if (patchDict[key].syntax) {
                result[key] = extendSyntax.test(patchDict[key].syntax)
                    ? result[key] + ' ' + patchDict[key].syntax.trim()
                    : patchDict[key].syntax;
            } else {
                delete result[key];
            }
        } else {
            if (patchDict[key].syntax) {
                result[key] = patchDict[key].syntax.replace(extendSyntax, '');
            }
        }
    }

    return result;
}

function unpackSyntaxes(dict) {
    const result = {};

    for (const key in dict) {
        result[key] = dict[key].syntax;
    }

    return result;
}

function patchAtrules(dict, patchDict) {
    const result = {};

    // copy all syntaxes for an original dict
    for (const key in dict) {
        const patchDescriptors = (patchDict[key] && patchDict[key].descriptors) || null;

        result[key] = {
            prelude: key in patchDict && 'prelude' in patchDict[key]
                ? patchDict[key].prelude
                : dict[key].prelude || null,
            descriptors: dict[key].descriptors
                ? patchDictionary(dict[key].descriptors, patchDescriptors || {})
                : patchDescriptors && unpackSyntaxes(patchDescriptors)
        };
    }

    // apply a patch
    for (const key in patchDict) {
        if (!hasOwnProperty.call(dict, key)) {
            result[key] = {
                prelude: patchDict[key].prelude || null,
                descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)
            };
        }
    }

    return result;
}

module.exports = {
    types: patchDictionary(mdnSyntaxes, patch.syntaxes),
    atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),
    properties: patchDictionary(mdnProperties, patch.properties)
};


/***/ }),

/***/ 11282:
/***/ ((module) => {

//
//                              list
//                            
//             head 
//                            tail
//                                         
//                                                 
//            item        item        item        item
//                      
//  null prev prev prev prev 
//           next next next next null
//                      
//           data      data      data      data 
//                      
//

function createItem(data) {
    return {
        prev: null,
        next: null,
        data: data
    };
}

function allocateCursor(node, prev, next) {
    var cursor;

    if (cursors !== null) {
        cursor = cursors;
        cursors = cursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = node.cursor;
    } else {
        cursor = {
            prev: prev,
            next: next,
            cursor: node.cursor
        };
    }

    node.cursor = cursor;

    return cursor;
}

function releaseCursor(node) {
    var cursor = node.cursor;

    node.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = cursors;
    cursors = cursor;
}

var cursors = null;
var List = function() {
    this.cursor = null;
    this.head = null;
    this.tail = null;
};

List.createItem = createItem;
List.prototype.createItem = createItem;

List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
        if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
        }

        if (cursor.next === nextOld) {
            cursor.next = nextNew;
        }

        cursor = cursor.cursor;
    }
};

List.prototype.getSize = function() {
    var size = 0;
    var cursor = this.head;

    while (cursor) {
        size++;
        cursor = cursor.next;
    }

    return size;
};

List.prototype.fromArray = function(array) {
    var cursor = null;

    this.head = null;

    for (var i = 0; i < array.length; i++) {
        var item = createItem(array[i]);

        if (cursor !== null) {
            cursor.next = item;
        } else {
            this.head = item;
        }

        item.prev = cursor;
        cursor = item;
    }

    this.tail = cursor;

    return this;
};

List.prototype.toArray = function() {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
};

List.prototype.toJSON = List.prototype.toArray;

List.prototype.isEmpty = function() {
    return this.head === null;
};

List.prototype.first = function() {
    return this.head && this.head.data;
};

List.prototype.last = function() {
    return this.tail && this.tail.data;
};

List.prototype.each = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.forEach = List.prototype.each;

List.prototype.eachRight = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.forEachRight = List.prototype.eachRight;

List.prototype.reduce = function(fn, initialValue, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);
    var acc = initialValue;

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        acc = fn.call(context, acc, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);

    return acc;
};

List.prototype.reduceRight = function(fn, initialValue, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);
    var acc = initialValue;

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        acc = fn.call(context, acc, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);

    return acc;
};

List.prototype.nextUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, start);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.prevUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, start, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.some = function(fn, context) {
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            return true;
        }

        cursor = cursor.next;
    }

    return false;
};

List.prototype.map = function(fn, context) {
    var result = new List();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        result.appendData(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
    }

    return result;
};

List.prototype.filter = function(fn, context) {
    var result = new List();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
        }
        cursor = cursor.next;
    }

    return result;
};

List.prototype.clear = function() {
    this.head = null;
    this.tail = null;
};

List.prototype.copy = function() {
    var result = new List();
    var cursor = this.head;

    while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
    }

    return result;
};

List.prototype.prepend = function(item) {
    //      head
    //    ^
    // item
    this.updateCursors(null, item, this.head, item);

    // insert to the beginning of the list
    if (this.head !== null) {
        // new item <- first item
        this.head.prev = item;

        // new item -> first item
        item.next = this.head;
    } else {
        // if list has no head, then it also has no tail
        // in this case tail points to the new item
        this.tail = item;
    }

    // head always points to new item
    this.head = item;

    return this;
};

List.prototype.prependData = function(data) {
    return this.prepend(createItem(data));
};

List.prototype.append = function(item) {
    return this.insert(item);
};

List.prototype.appendData = function(data) {
    return this.insert(createItem(data));
};

List.prototype.insert = function(item, before) {
    if (before !== undefined && before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
            // insert to the beginning of list
            if (this.head !== before) {
                throw new Error('before doesn\'t belong to list');
            }

            // since head points to before therefore list doesn't empty
            // no need to check tail
            this.head = item;
            before.prev = item;
            item.next = before;

            this.updateCursors(null, item);
        } else {

            // insert between two items
            before.prev.next = item;
            item.prev = before.prev;

            before.prev = item;
            item.next = before;
        }
    } else {
        // tail
        //      ^
        //      item
        this.updateCursors(this.tail, item, null, item);

        // insert to the ending of the list
        if (this.tail !== null) {
            // last item -> new item
            this.tail.next = item;

            // last item <- new item
            item.prev = this.tail;
        } else {
            // if list has no tail, then it also has no head
            // in this case head points to new item
            this.head = item;
        }

        // tail always points to new item
        this.tail = item;
    }

    return this;
};

List.prototype.insertData = function(data, before) {
    return this.insert(createItem(data), before);
};

List.prototype.remove = function(item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
        item.prev.next = item.next;
    } else {
        if (this.head !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.head = item.next;
    }

    if (item.next !== null) {
        item.next.prev = item.prev;
    } else {
        if (this.tail !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
};

List.prototype.push = function(data) {
    this.insert(createItem(data));
};

List.prototype.pop = function() {
    if (this.tail !== null) {
        return this.remove(this.tail);
    }
};

List.prototype.unshift = function(data) {
    this.prepend(createItem(data));
};

List.prototype.shift = function() {
    if (this.head !== null) {
        return this.remove(this.head);
    }
};

List.prototype.prependList = function(list) {
    return this.insertList(list, this.head);
};

List.prototype.appendList = function(list) {
    return this.insertList(list);
};

List.prototype.insertList = function(list, before) {
    // ignore empty lists
    if (list.head === null) {
        return this;
    }

    if (before !== undefined && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);

        // insert in the middle of dist list
        if (before.prev !== null) {
            // before.prev <-> list.head
            before.prev.next = list.head;
            list.head.prev = before.prev;
        } else {
            this.head = list.head;
        }

        before.prev = list.tail;
        list.tail.next = before;
    } else {
        this.updateCursors(this.tail, list.tail, null, list.head);

        // insert to end of the list
        if (this.tail !== null) {
            // if destination list has a tail, then it also has a head,
            // but head doesn't change

            // dest tail -> source head
            this.tail.next = list.head;

            // dest tail <- source head
            list.head.prev = this.tail;
        } else {
            // if list has no a tail, then it also has no a head
            // in this case points head to new item
            this.head = list.head;
        }

        // tail always start point to new item
        this.tail = list.tail;
    }

    list.head = null;
    list.tail = null;

    return this;
};

List.prototype.replace = function(oldItem, newItemOrList) {
    if ('head' in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
    } else {
        this.insert(newItemOrList, oldItem);
    }

    this.remove(oldItem);
};

module.exports = List;


/***/ }),

/***/ 77634:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var adoptBuffer = __nccwpck_require__(63156);
var isBOM = __nccwpck_require__(69549).isBOM;

var N = 10;
var F = 12;
var R = 13;

function computeLinesAndColumns(host, source) {
    var sourceLength = source.length;
    var lines = adoptBuffer(host.lines, sourceLength); // +1
    var line = host.startLine;
    var columns = adoptBuffer(host.columns, sourceLength);
    var column = host.startColumn;
    var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;

    for (var i = startOffset; i < sourceLength; i++) { // -1
        var code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N || code === R || code === F) {
            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[i] = line;
    columns[i] = column;

    host.lines = lines;
    host.columns = columns;
}

var OffsetToLocation = function() {
    this.lines = null;
    this.columns = null;
    this.linesAndColumnsComputed = false;
};

OffsetToLocation.prototype = {
    setSource: function(source, startOffset, startLine, startColumn) {
        this.source = source;
        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
        this.linesAndColumnsComputed = false;
    },

    ensureLinesAndColumnsComputed: function() {
        if (!this.linesAndColumnsComputed) {
            computeLinesAndColumns(this, this.source);
            this.linesAndColumnsComputed = true;
        }
    },
    getLocation: function(offset, filename) {
        this.ensureLinesAndColumnsComputed();

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    },
    getLocationRange: function(start, end, filename) {
        this.ensureLinesAndColumnsComputed();

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    }
};

module.exports = OffsetToLocation;


/***/ }),

/***/ 83981:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var createCustomError = __nccwpck_require__(20195);
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = '    ';

function sourceFragment(error, extraLines) {
    function processLines(start, end) {
        return lines.slice(start, end).map(function(line, idx) {
            var num = String(start + idx + 1);

            while (num.length < maxNumLength) {
                num = ' ' + num;
            }

            return num + ' |' + line;
        }).join('\n');
    }

    var lines = error.source.split(/\r\n?|\n|\f/);
    var line = error.line;
    var column = error.column;
    var startLine = Math.max(1, line - extraLines) - 1;
    var endLine = Math.min(line + extraLines, lines.length + 1);
    var maxNumLength = Math.max(4, String(endLine).length) + 1;
    var cutLeft = 0;

    // column correction according to replaced tab before column
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (var i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].filter(Boolean).join('\n');
}

var SyntaxError = function(message, source, offset, line, column) {
    var error = createCustomError('SyntaxError', message);

    error.source = source;
    error.offset = offset;
    error.line = line;
    error.column = column;

    error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    };
    Object.defineProperty(error, 'formattedMessage', {
        get: function() {
            return (
                'Parse error: ' + error.message + '\n' +
                sourceFragment(error, 2)
            );
        }
    });

    // for backward capability
    error.parseError = {
        offset: offset,
        line: line,
        column: column
    };

    return error;
};

module.exports = SyntaxError;


/***/ }),

/***/ 89490:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var constants = __nccwpck_require__(62478);
var TYPE = constants.TYPE;
var NAME = constants.NAME;

var utils = __nccwpck_require__(29292);
var cmpStr = utils.cmpStr;

var EOF = TYPE.EOF;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;

var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;

var TokenStream = function() {
    this.offsetAndType = null;
    this.balance = null;

    this.reset();
};

TokenStream.prototype = {
    reset: function() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
    },

    lookupType: function(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
        }

        return EOF;
    },
    lookupOffset: function(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK;
        }

        return this.source.length;
    },
    lookupValue: function(offset, referenceStr) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return cmpStr(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK,
                this.offsetAndType[offset] & OFFSET_MASK,
                referenceStr
            );
        }

        return false;
    },
    getTokenStart: function(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
        }

        if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount
                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }

        return this.firstCharOffset;
    },

    // TODO: -> skipUntilBalanced
    getRawLength: function(startToken, mode) {
        var cursor = startToken;
        var balanceEnd;
        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
        var type;

        loop:
        for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];

            // stop scanning on balance edge that points to offset before start token
            if (balanceEnd < startToken) {
                break loop;
            }

            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

            // check token is stop type
            switch (mode(type, this.source, offset)) {
                case 1:
                    break loop;

                case 2:
                    cursor++;
                    break loop;

                default:
                    // fast forward to the end of balanced block
                    if (this.balance[balanceEnd] === cursor) {
                        cursor = balanceEnd;
                    }

                    offset = this.offsetAndType[cursor] & OFFSET_MASK;
            }
        }

        return cursor - this.tokenIndex;
    },
    isBalanceEdge: function(pos) {
        return this.balance[this.tokenIndex] < pos;
    },
    isDelim: function(code, offset) {
        if (offset) {
            return (
                this.lookupType(offset) === TYPE.Delim &&
                this.source.charCodeAt(this.lookupOffset(offset)) === code
            );
        }

        return (
            this.tokenType === TYPE.Delim &&
            this.source.charCodeAt(this.tokenStart) === code
        );
    },

    getTokenValue: function() {
        return this.source.substring(this.tokenStart, this.tokenEnd);
    },
    getTokenLength: function() {
        return this.tokenEnd - this.tokenStart;
    },
    substrToCursor: function(start) {
        return this.source.substring(start, this.tokenStart);
    },

    skipWS: function() {
        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
                break;
            }
        }

        if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
        }
    },
    skipSC: function() {
        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
            this.next();
        }
    },
    skip: function(tokenCount) {
        var next = this.tokenIndex + tokenCount;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.tokenIndex = this.tokenCount;
            this.next();
        }
    },
    next: function() {
        var next = this.tokenIndex + 1;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.tokenIndex = this.tokenCount;
            this.eof = true;
            this.tokenType = EOF;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    },

    forEachToken(fn) {
        for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
            var start = offset;
            var item = this.offsetAndType[i];
            var end = item & OFFSET_MASK;
            var type = item >> TYPE_SHIFT;

            offset = end;

            fn(type, start, end, i);
        }
    },

    dump() {
        var tokens = new Array(this.tokenCount);

        this.forEachToken((type, start, end, index) => {
            tokens[index] = {
                idx: index,
                type: NAME[type],
                chunk: this.source.substring(start, end),
                balance: this.balance[index]
            };
        });

        return tokens;
    }
};

module.exports = TokenStream;


/***/ }),

/***/ 63156:
/***/ ((module) => {

var MIN_SIZE = 16 * 1024;
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

module.exports = function adoptBuffer(buffer, size) {
    if (buffer === null || buffer.length < size) {
        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
    }

    return buffer;
};


/***/ }),

/***/ 19719:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var List = __nccwpck_require__(11282);

module.exports = function createConvertors(walk) {
    return {
        fromPlainObject: function(ast) {
            walk(ast, {
                enter: function(node) {
                    if (node.children && node.children instanceof List === false) {
                        node.children = new List().fromArray(node.children);
                    }
                }
            });

            return ast;
        },
        toPlainObject: function(ast) {
            walk(ast, {
                leave: function(node) {
                    if (node.children && node.children instanceof List) {
                        node.children = node.children.toArray();
                    }
                }
            });

            return ast;
        }
    };
};


/***/ }),

/***/ 5929:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var createCustomError = __nccwpck_require__(20195);

module.exports = function SyntaxError(message, input, offset) {
    var error = createCustomError('SyntaxError', message);

    error.input = input;
    error.offset = offset;
    error.rawMessage = message;
    error.message = error.rawMessage + '\n' +
        '  ' + error.input + '\n' +
        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

    return error;
};


/***/ }),

/***/ 79590:
/***/ ((module) => {

function noop(value) {
    return value;
}

function generateMultiplier(multiplier) {
    if (multiplier.min === 0 && multiplier.max === 0) {
        return '*';
    }

    if (multiplier.min === 0 && multiplier.max === 1) {
        return '?';
    }

    if (multiplier.min === 1 && multiplier.max === 0) {
        return multiplier.comma ? '#' : '+';
    }

    if (multiplier.min === 1 && multiplier.max === 1) {
        return '';
    }

    return (
        (multiplier.comma ? '#' : '') +
        (multiplier.min === multiplier.max
            ? '{' + multiplier.min + '}'
            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
        )
    );
}

function generateTypeOpts(node) {
    switch (node.type) {
        case 'Range':
            return (
                ' [' +
                (node.min === null ? '-' : node.min) +
                ',' +
                (node.max === null ? '' : node.max) +
                ']'
            );

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }
}

function generateSequence(node, decorate, forceBraces, compact) {
    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
    var result = node.terms.map(function(term) {
        return generate(term, decorate, forceBraces, compact);
    }).join(combinator);

    if (node.explicit || forceBraces) {
        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
    }

    return result;
}

function generate(node, decorate, forceBraces, compact) {
    var result;

    switch (node.type) {
        case 'Group':
            result =
                generateSequence(node, decorate, forceBraces, compact) +
                (node.disallowEmpty ? '!' : '');
            break;

        case 'Multiplier':
            // return since node is a composition
            return (
                generate(node.term, decorate, forceBraces, compact) +
                decorate(generateMultiplier(node), node)
            );

        case 'Type':
            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
            break;

        case 'Property':
            result = '<\'' + node.name + '\'>';
            break;

        case 'Keyword':
            result = node.name;
            break;

        case 'AtKeyword':
            result = '@' + node.name;
            break;

        case 'Function':
            result = node.name + '(';
            break;

        case 'String':
        case 'Token':
            result = node.value;
            break;

        case 'Comma':
            result = ',';
            break;

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }

    return decorate(result, node);
}

module.exports = function(node, options) {
    var decorate = noop;
    var forceBraces = false;
    var compact = false;

    if (typeof options === 'function') {
        decorate = options;
    } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === 'function') {
            decorate = options.decorate;
        }
    }

    return generate(node, decorate, forceBraces, compact);
};


/***/ }),

/***/ 32267:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
    SyntaxError: __nccwpck_require__(5929),
    parse: __nccwpck_require__(50362),
    generate: __nccwpck_require__(79590),
    walk: __nccwpck_require__(62692)
};


/***/ }),

/***/ 50362:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Tokenizer = __nccwpck_require__(77377);
var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;
var EXCLAMATIONMARK = 33;    // !
var NUMBERSIGN = 35;         // #
var AMPERSAND = 38;          // &
var APOSTROPHE = 39;         // '
var LEFTPARENTHESIS = 40;    // (
var RIGHTPARENTHESIS = 41;   // )
var ASTERISK = 42;           // *
var PLUSSIGN = 43;           // +
var COMMA = 44;              // ,
var HYPERMINUS = 45;         // -
var LESSTHANSIGN = 60;       // <
var GREATERTHANSIGN = 62;    // >
var QUESTIONMARK = 63;       // ?
var COMMERCIALAT = 64;       // @
var LEFTSQUAREBRACKET = 91;  // [
var RIGHTSQUAREBRACKET = 93; // ]
var LEFTCURLYBRACKET = 123;  // {
var VERTICALLINE = 124;      // |
var RIGHTCURLYBRACKET = 125; // }
var INFINITY = 8734;         // 
var NAME_CHAR = createCharMap(function(ch) {
    return /[a-zA-Z0-9\-]/.test(ch);
});
var COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
};

function createCharMap(fn) {
    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
    for (var i = 0; i < 128; i++) {
        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
    }
    return array;
}

function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(
        tokenizer.findWsEnd(tokenizer.pos)
    );
}

function scanWord(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a keyword');
    }

    return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a number');
    }

    return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
        tokenizer.pos = tokenizer.str.length;
        tokenizer.error('Expect an apostrophe');
    }

    return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer) {
    var min = null;
    var max = null;

    tokenizer.eat(LEFTCURLYBRACKET);

    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
        }
    } else {
        max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET);

    return {
        min: Number(min),
        max: max ? Number(max) : 0
    };
}

function readMultiplier(tokenizer) {
    var range = null;
    var comma = false;

    switch (tokenizer.charCode()) {
        case ASTERISK:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 0
            };

            break;

        case PLUSSIGN:
            tokenizer.pos++;

            range = {
                min: 1,
                max: 0
            };

            break;

        case QUESTIONMARK:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 1
            };

            break;

        case NUMBERSIGN:
            tokenizer.pos++;

            comma = true;

            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
                range = readMultiplierRange(tokenizer);
            } else {
                range = {
                    min: 1,
                    max: 0
                };
            }

            break;

        case LEFTCURLYBRACKET:
            range = readMultiplierRange(tokenizer);
            break;

        default:
            return null;
    }

    return {
        type: 'Multiplier',
        comma: comma,
        min: range.min,
        max: range.max,
        term: null
    };
}

function maybeMultiplied(tokenizer, node) {
    var multiplier = readMultiplier(tokenizer);

    if (multiplier !== null) {
        multiplier.term = node;
        return multiplier;
    }

    return node;
}

function maybeToken(tokenizer) {
    var ch = tokenizer.peek();

    if (ch === '') {
        return null;
    }

    return {
        type: 'Token',
        value: ch
    };
}

function readProperty(tokenizer) {
    var name;

    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE);

    name = scanWord(tokenizer);

    tokenizer.eat(APOSTROPHE);
    tokenizer.eat(GREATERTHANSIGN);

    return maybeMultiplied(tokenizer, {
        type: 'Property',
        name: name
    });
}

// https://drafts.csswg.org/css-values-3/#numeric-ranges
// 4.1. Range Restrictions and Range Definition Notation
//
// Range restrictions can be annotated in the numeric type notation using CSS bracketed
// range notation[min,max]within the angle brackets, after the identifying keyword,
// indicating a closed range between (and including) min and max.
// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
function readTypeRange(tokenizer) {
    // use null for Infinity to make AST format JSON serializable/deserializable
    var min = null; // -Infinity
    var max = null; // Infinity
    var sign = 1;

    tokenizer.eat(LEFTSQUAREBRACKET);

    if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
    }

    if (sign == -1 && tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        min = sign * Number(scanNumber(tokenizer));
    }

    scanSpaces(tokenizer);
    tokenizer.eat(COMMA);
    scanSpaces(tokenizer);

    if (tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        sign = 1;

        if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
        }

        max = sign * Number(scanNumber(tokenizer));
    }

    tokenizer.eat(RIGHTSQUAREBRACKET);

    // If no range is indicated, either by using the bracketed range notation
    // or in the property description, then [,] is assumed.
    if (min === null && max === null) {
        return null;
    }

    return {
        type: 'Range',
        min: min,
        max: max
    };
}

function readType(tokenizer) {
    var name;
    var opts = null;

    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS &&
        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
        tokenizer.pos += 2;
        name += '()';
    }

    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
        scanSpaces(tokenizer);
        opts = readTypeRange(tokenizer);
    }

    tokenizer.eat(GREATERTHANSIGN);

    return maybeMultiplied(tokenizer, {
        type: 'Type',
        name: name,
        opts: opts
    });
}

function readKeywordOrFunction(tokenizer) {
    var name;

    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS) {
        tokenizer.pos++;

        return {
            type: 'Function',
            name: name
        };
    }

    return maybeMultiplied(tokenizer, {
        type: 'Keyword',
        name: name
    });
}

function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
        return {
            type: 'Group',
            terms: terms,
            combinator: combinator,
            disallowEmpty: false,
            explicit: false
        };
    }

    combinators = Object.keys(combinators).sort(function(a, b) {
        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
    });

    while (combinators.length > 0) {
        var combinator = combinators.shift();
        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
            var term = terms[i];
            if (term.type === 'Combinator') {
                if (term.value === combinator) {
                    if (subgroupStart === -1) {
                        subgroupStart = i - 1;
                    }
                    terms.splice(i, 1);
                    i--;
                } else {
                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
                        terms.splice(
                            subgroupStart,
                            i - subgroupStart,
                            createGroup(terms.slice(subgroupStart, i), combinator)
                        );
                        i = subgroupStart + 1;
                    }
                    subgroupStart = -1;
                }
            }
        }

        if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
            );
        }
    }

    return combinator;
}

function readImplicitGroup(tokenizer) {
    var terms = [];
    var combinators = {};
    var token;
    var prevToken = null;
    var prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
        if (token.type !== 'Spaces') {
            if (token.type === 'Combinator') {
                // check for combinator in group beginning and double combinator sequence
                if (prevToken === null || prevToken.type === 'Combinator') {
                    tokenizer.pos = prevTokenPos;
                    tokenizer.error('Unexpected combinator');
                }

                combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
                combinators[' '] = true;  // a b
                terms.push({
                    type: 'Combinator',
                    value: ' '
                });
            }

            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
        }
    }

    // check for combinator in group ending
    if (prevToken !== null && prevToken.type === 'Combinator') {
        tokenizer.pos -= prevTokenPos;
        tokenizer.error('Unexpected combinator');
    }

    return {
        type: 'Group',
        terms: terms,
        combinator: regroupTerms(terms, combinators) || ' ',
        disallowEmpty: false,
        explicit: false
    };
}

function readGroup(tokenizer) {
    var result;

    tokenizer.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET);

    result.explicit = true;

    if (tokenizer.charCode() === EXCLAMATIONMARK) {
        tokenizer.pos++;
        result.disallowEmpty = true;
    }

    return result;
}

function peek(tokenizer) {
    var code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
        case RIGHTSQUAREBRACKET:
            // don't eat, stop scan a group
            break;

        case LEFTSQUAREBRACKET:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));

        case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE
                ? readProperty(tokenizer)
                : readType(tokenizer);

        case VERTICALLINE:
            return {
                type: 'Combinator',
                value: tokenizer.substringToPos(
                    tokenizer.nextCharCode() === VERTICALLINE
                        ? tokenizer.pos + 2
                        : tokenizer.pos + 1
                )
            };

        case AMPERSAND:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND);

            return {
                type: 'Combinator',
                value: '&&'
            };

        case COMMA:
            tokenizer.pos++;
            return {
                type: 'Comma'
            };

        case APOSTROPHE:
            return maybeMultiplied(tokenizer, {
                type: 'String',
                value: scanString(tokenizer)
            });

        case SPACE:
        case TAB:
        case N:
        case R:
        case F:
            return {
                type: 'Spaces',
                value: scanSpaces(tokenizer)
            };

        case COMMERCIALAT:
            code = tokenizer.nextCharCode();

            if (code < 128 && NAME_CHAR[code] === 1) {
                tokenizer.pos++;
                return {
                    type: 'AtKeyword',
                    name: scanWord(tokenizer)
                };
            }

            return maybeToken(tokenizer);

        case ASTERISK:
        case PLUSSIGN:
        case QUESTIONMARK:
        case NUMBERSIGN:
        case EXCLAMATIONMARK:
            // prohibited tokens (used as a multiplier start)
            break;

        case LEFTCURLYBRACKET:
            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
            // check next char isn't a number, because it's likely a disjoined multiplier
            code = tokenizer.nextCharCode();

            if (code < 48 || code > 57) {
                return maybeToken(tokenizer);
            }

            break;

        default:
            return maybeToken(tokenizer);
    }
}

function parse(source) {
    var tokenizer = new Tokenizer(source);
    var result = readImplicitGroup(tokenizer);

    if (tokenizer.pos !== source.length) {
        tokenizer.error('Unexpected input');
    }

    // reduce redundant groups with single group term
    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
        result = result.terms[0];
    }

    return result;
}

// warm up parse to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

module.exports = parse;


/***/ }),

/***/ 77377:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var SyntaxError = __nccwpck_require__(5929);

var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;

var Tokenizer = function(str) {
    this.str = str;
    this.pos = 0;
};

Tokenizer.prototype = {
    charCodeAt: function(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    },
    charCode: function() {
        return this.charCodeAt(this.pos);
    },
    nextCharCode: function() {
        return this.charCodeAt(this.pos + 1);
    },
    nextNonWsCode: function(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
    },
    findWsEnd: function(pos) {
        for (; pos < this.str.length; pos++) {
            var code = this.str.charCodeAt(pos);
            if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
                break;
            }
        }

        return pos;
    },
    substringToPos: function(end) {
        return this.str.substring(this.pos, this.pos = end);
    },
    eat: function(code) {
        if (this.charCode() !== code) {
            this.error('Expect `' + String.fromCharCode(code) + '`');
        }

        this.pos++;
    },
    peek: function() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    },
    error: function(message) {
        throw new SyntaxError(message, this.str, this.pos);
    }
};

module.exports = Tokenizer;


/***/ }),

/***/ 62692:
/***/ ((module) => {

var noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

module.exports = function(node, options, context) {
    function walk(node) {
        enter.call(context, node);

        switch (node.type) {
            case 'Group':
                node.terms.forEach(walk);
                break;

            case 'Multiplier':
                walk(node.term);
                break;

            case 'Type':
            case 'Property':
            case 'Keyword':
            case 'AtKeyword':
            case 'Function':
            case 'String':
            case 'Token':
            case 'Comma':
                break;

            default:
                throw new Error('Unknown type: ' + node.type);
        }

        leave.call(context, node);
    }

    var enter = noop;
    var leave = noop;

    if (typeof options === 'function') {
        enter = options;
    } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
    }

    if (enter === noop && leave === noop) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node, context);
};


/***/ }),

/***/ 37703:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var sourceMap = __nccwpck_require__(68345);
var hasOwnProperty = Object.prototype.hasOwnProperty;

function processChildren(node, delimeter) {
    var list = node.children;
    var prev = null;

    if (typeof delimeter !== 'function') {
        list.forEach(this.node, this);
    } else {
        list.forEach(function(node) {
            if (prev !== null) {
                delimeter.call(this, prev);
            }

            this.node(node);
            prev = node;
        }, this);
    }
}

module.exports = function createGenerator(config) {
    function processNode(node) {
        if (hasOwnProperty.call(types, node.type)) {
            types[node.type].call(this, node);
        } else {
            throw new Error('Unknown node type: ' + node.type);
        }
    }

    var types = {};

    if (config.node) {
        for (var name in config.node) {
            types[name] = config.node[name].generate;
        }
    }

    return function(node, options) {
        var buffer = '';
        var handlers = {
            children: processChildren,
            node: processNode,
            chunk: function(chunk) {
                buffer += chunk;
            },
            result: function() {
                return buffer;
            }
        };

        if (options) {
            if (typeof options.decorator === 'function') {
                handlers = options.decorator(handlers);
            }

            if (options.sourceMap) {
                handlers = sourceMap(handlers);
            }
        }

        handlers.node(node);

        return handlers.result();
    };
};


/***/ }),

/***/ 68345:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var SourceMapGenerator = __nccwpck_require__(66558)/* .SourceMapGenerator */ .h;
var trackNodes = {
    Atrule: true,
    Selector: true,
    Declaration: true
};

module.exports = function generateSourceMap(handlers) {
    var map = new SourceMapGenerator();
    var line = 1;
    var column = 0;
    var generated = {
        line: 1,
        column: 0
    };
    var original = {
        line: 0, // should be zero to add first mapping
        column: 0
    };
    var sourceMappingActive = false;
    var activatedGenerated = {
        line: 1,
        column: 0
    };
    var activatedMapping = {
        generated: activatedGenerated
    };

    var handlersNode = handlers.node;
    handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
            var nodeLine = node.loc.start.line;
            var nodeColumn = node.loc.start.column - 1;

            if (original.line !== nodeLine ||
                original.column !== nodeColumn) {
                original.line = nodeLine;
                original.column = nodeColumn;

                generated.line = line;
                generated.column = column;

                if (sourceMappingActive) {
                    sourceMappingActive = false;
                    if (generated.line !== activatedGenerated.line ||
                        generated.column !== activatedGenerated.column) {
                        map.addMapping(activatedMapping);
                    }
                }

                sourceMappingActive = true;
                map.addMapping({
                    source: node.loc.source,
                    original: original,
                    generated: generated
                });
            }
        }

        handlersNode.call(this, node);

        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
        }
    };

    var handlersChunk = handlers.chunk;
    handlers.chunk = function(chunk) {
        for (var i = 0; i < chunk.length; i++) {
            if (chunk.charCodeAt(i) === 10) { // \n
                line++;
                column = 0;
            } else {
                column++;
            }
        }

        handlersChunk(chunk);
    };

    var handlersResult = handlers.result;
    handlers.result = function() {
        if (sourceMappingActive) {
            map.addMapping(activatedMapping);
        }

        return {
            css: handlersResult(),
            map: map
        };
    };

    return handlers;
};


/***/ }),

/***/ 65035:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(40469);


/***/ }),

/***/ 77906:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var SyntaxReferenceError = __nccwpck_require__(83974).SyntaxReferenceError;
var SyntaxMatchError = __nccwpck_require__(83974).SyntaxMatchError;
var names = __nccwpck_require__(87602);
var generic = __nccwpck_require__(20452);
var parse = __nccwpck_require__(50362);
var generate = __nccwpck_require__(79590);
var walk = __nccwpck_require__(62692);
var prepareTokens = __nccwpck_require__(81595);
var buildMatchGraph = __nccwpck_require__(79987).buildMatchGraph;
var matchAsTree = __nccwpck_require__(22092).matchAsTree;
var trace = __nccwpck_require__(78078);
var search = __nccwpck_require__(33036);
var getStructureFromConfig = __nccwpck_require__(20846).getStructureFromConfig;
var cssWideKeywords = buildMatchGraph('inherit | initial | unset');
var cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');

function dumpMapSyntax(map, compact, syntaxAsAst) {
    var result = {};

    for (var name in map) {
        if (map[name].syntax) {
            result[name] = syntaxAsAst
                ? map[name].syntax
                : generate(map[name].syntax, { compact: compact });
        }
    }

    return result;
}

function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
            prelude: atrule.prelude && (
                syntaxAsAst
                    ? atrule.prelude.syntax
                    : generate(atrule.prelude.syntax, { compact })
            ),
            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
    }

    return result;
}

function valueHasVar(tokens) {
    for (var i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === 'var(') {
            return true;
        }
    }

    return false;
}

function buildMatchResult(match, error, iterations) {
    return {
        matched: match,
        iterations: iterations,
        error: error,
        getTrace: trace.getTrace,
        isType: trace.isType,
        isProperty: trace.isProperty,
        isKeyword: trace.isKeyword
    };
}

function matchSyntax(lexer, syntax, value, useCommon) {
    var tokens = prepareTokens(value, lexer.syntax);
    var result;

    if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    if (useCommon) {
        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
    }

    if (!useCommon || !result.match) {
        result = matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
            return buildMatchResult(
                null,
                new SyntaxMatchError(result.reason, syntax.syntax, value, result),
                result.iterations
            );
        }
    }

    return buildMatchResult(result.match, null, result.iterations);
}

var Lexer = function(config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.atrules = {};
    this.properties = {};
    this.types = {};
    this.structure = structure || getStructureFromConfig(config);

    if (config) {
        if (config.types) {
            for (var name in config.types) {
                this.addType_(name, config.types[name]);
            }
        }

        if (config.generic) {
            this.generic = true;
            for (var name in generic) {
                this.addType_(name, generic[name]);
            }
        }

        if (config.atrules) {
            for (var name in config.atrules) {
                this.addAtrule_(name, config.atrules[name]);
            }
        }

        if (config.properties) {
            for (var name in config.properties) {
                this.addProperty_(name, config.properties[name]);
            }
        }
    }
};

Lexer.prototype = {
    structure: {},
    checkStructure: function(ast) {
        function collectWarning(node, message) {
            warns.push({
                node: node,
                message: message
            });
        }

        var structure = this.structure;
        var warns = [];

        this.syntax.walk(ast, function(node) {
            if (structure.hasOwnProperty(node.type)) {
                structure[node.type].check(node, collectWarning);
            } else {
                collectWarning(node, 'Unknown node type `' + node.type + '`');
            }
        });

        return warns.length ? warns : false;
    },

    createDescriptor: function(syntax, type, name, parent = null) {
        var ref = {
            type: type,
            name: name
        };
        var descriptor = {
            type: type,
            name: name,
            parent: parent,
            syntax: null,
            match: null
        };

        if (typeof syntax === 'function') {
            descriptor.match = buildMatchGraph(syntax, ref);
        } else {
            if (typeof syntax === 'string') {
                // lazy parsing on first access
                Object.defineProperty(descriptor, 'syntax', {
                    get: function() {
                        Object.defineProperty(descriptor, 'syntax', {
                            value: parse(syntax)
                        });

                        return descriptor.syntax;
                    }
                });
            } else {
                descriptor.syntax = syntax;
            }

            // lazy graph build on first access
            Object.defineProperty(descriptor, 'match', {
                get: function() {
                    Object.defineProperty(descriptor, 'match', {
                        value: buildMatchGraph(descriptor.syntax, ref)
                    });

                    return descriptor.match;
                }
            });
        }

        return descriptor;
    },
    addAtrule_: function(name, syntax) {
        if (!syntax) {
            return;
        }

        this.atrules[name] = {
            type: 'Atrule',
            name: name,
            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
            descriptors: syntax.descriptors
                ? Object.keys(syntax.descriptors).reduce((res, descName) => {
                    res[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);
                    return res;
                }, {})
                : null
        };
    },
    addProperty_: function(name, syntax) {
        if (!syntax) {
            return;
        }

        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    },
    addType_: function(name, syntax) {
        if (!syntax) {
            return;
        }

        this.types[name] = this.createDescriptor(syntax, 'Type', name);

        if (syntax === generic['-ms-legacy-expression']) {
            this.valueCommonSyntax = cssWideKeywordsWithExpression;
        }
    },

    checkAtruleName: function(atruleName) {
        if (!this.getAtrule(atruleName)) {
            return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);
        }
    },
    checkAtrulePrelude: function(atruleName, prelude) {
        let error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        var atrule = this.getAtrule(atruleName);

        if (!atrule.prelude && prelude) {
            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');
        }

        if (atrule.prelude && !prelude) {
            return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');
        }
    },
    checkAtruleDescriptorName: function(atruleName, descriptorName) {
        let error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        var atrule = this.getAtrule(atruleName);
        var descriptor = names.keyword(descriptorName);

        if (!atrule.descriptors) {
            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');
        }

        if (!atrule.descriptors[descriptor.name] &&
            !atrule.descriptors[descriptor.basename]) {
            return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);
        }
    },
    checkPropertyName: function(propertyName) {
        var property = names.property(propertyName);

        // don't match syntax for a custom property
        if (property.custom) {
            return new Error('Lexer matching doesn\'t applicable for custom properties');
        }

        if (!this.getProperty(propertyName)) {
            return new SyntaxReferenceError('Unknown property', propertyName);
        }
    },

    matchAtrulePrelude: function(atruleName, prelude) {
        var error = this.checkAtrulePrelude(atruleName, prelude);

        if (error) {
            return buildMatchResult(null, error);
        }

        if (!prelude) {
            return buildMatchResult(null, null);
        }

        return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);
    },
    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
        var error = this.checkAtruleDescriptorName(atruleName, descriptorName);

        if (error) {
            return buildMatchResult(null, error);
        }

        var atrule = this.getAtrule(atruleName);
        var descriptor = names.keyword(descriptorName);

        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    },
    matchDeclaration: function(node) {
        if (node.type !== 'Declaration') {
            return buildMatchResult(null, new Error('Not a Declaration node'));
        }

        return this.matchProperty(node.property, node.value);
    },
    matchProperty: function(propertyName, value) {
        var error = this.checkPropertyName(propertyName);

        if (error) {
            return buildMatchResult(null, error);
        }

        return matchSyntax(this, this.getProperty(propertyName), value, true);
    },
    matchType: function(typeName, value) {
        var typeSyntax = this.getType(typeName);

        if (!typeSyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
        }

        return matchSyntax(this, typeSyntax, value, false);
    },
    match: function(syntax, value) {
        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
        }

        if (typeof syntax === 'string' || !syntax.match) {
            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
        }

        return matchSyntax(this, syntax, value, false);
    },

    findValueFragments: function(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    },
    findDeclarationValueFragments: function(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    },
    findAllFragments: function(ast, type, name) {
        var result = [];

        this.syntax.walk(ast, {
            visit: 'Declaration',
            enter: function(declaration) {
                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
            }.bind(this)
        });

        return result;
    },

    getAtrule: function(atruleName, fallbackBasename = true) {
        var atrule = names.keyword(atruleName);
        var atruleEntry = atrule.vendor && fallbackBasename
            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
            : this.atrules[atrule.name];

        return atruleEntry || null;
    },
    getAtrulePrelude: function(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);

        return atrule && atrule.prelude || null;
    },
    getAtruleDescriptor: function(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
            ? this.atrules[atruleName].declarators[name] || null
            : null;
    },
    getProperty: function(propertyName, fallbackBasename = true) {
        var property = names.property(propertyName);
        var propertyEntry = property.vendor && fallbackBasename
            ? this.properties[property.name] || this.properties[property.basename]
            : this.properties[property.name];

        return propertyEntry || null;
    },
    getType: function(name) {
        return this.types.hasOwnProperty(name) ? this.types[name] : null;
    },

    validate: function() {
        function validate(syntax, name, broken, descriptor) {
            if (broken.hasOwnProperty(name)) {
                return broken[name];
            }

            broken[name] = false;
            if (descriptor.syntax !== null) {
                walk(descriptor.syntax, function(node) {
                    if (node.type !== 'Type' && node.type !== 'Property') {
                        return;
                    }

                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                        broken[name] = true;
                    }
                }, this);
            }
        }

        var brokenTypes = {};
        var brokenProperties = {};

        for (var key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
        }

        for (var key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
        }

        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
            return brokenTypes[name];
        });
        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
            return brokenProperties[name];
        });

        if (brokenTypes.length || brokenProperties.length) {
            return {
                types: brokenTypes,
                properties: brokenProperties
            };
        }

        return null;
    },
    dump: function(syntaxAsAst, pretty) {
        return {
            generic: this.generic,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
    },
    toString: function() {
        return JSON.stringify(this.dump());
    }
};

module.exports = Lexer;


/***/ }),

/***/ 83974:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const createCustomError = __nccwpck_require__(20195);
const generate = __nccwpck_require__(79590);
const defaultLoc = { offset: 0, line: 1, column: 1 };

function locateMismatch(matchResult, node) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = '';
    let start;
    let end;

    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].value;

        if (i === longestMatch) {
            mismatchLength = token.length;
            mismatchOffset = css.length;
        }

        if (badNode !== null && tokens[i].node === badNode) {
            if (i <= longestMatch) {
                entries++;
            } else {
                entries = 0;
            }
        }

        css += token;
    }

    if (longestMatch === tokens.length || entries > 1) { // last
        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);
        end = buildLoc(start);
    } else {
        start = fromLoc(badNode, 'start') ||
            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, 'end') ||
            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }

    return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    };
}

function fromLoc(node, point) {
    const value = node && node.loc && node.loc[point];

    if (value) {
        return 'line' in value ? buildLoc(value) : value;
    }

    return null;
}

function buildLoc({ offset, line, column }, extra) {
    const loc = {
        offset,
        line,
        column
    };

    if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);

        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }

    return loc;
}

const SyntaxReferenceError = function(type, referenceName) {
    const error = createCustomError(
        'SyntaxReferenceError',
        type + (referenceName ? ' `' + referenceName + '`' : '')
    );

    error.reference = referenceName;

    return error;
};

const SyntaxMatchError = function(message, syntax, node, matchResult) {
    const error = createCustomError('SyntaxMatchError', message);
    const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    } = locateMismatch(matchResult, node);

    error.rawMessage = message;
    error.syntax = syntax ? generate(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + '\n' +
        '  syntax: ' + error.syntax + '\n' +
        '   value: ' + (css || '<empty string>') + '\n' +
        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

    Object.assign(error, start);
    error.loc = {
        source: (node && node.loc && node.loc.source) || '<unknown>',
        start,
        end
    };

    return error;
};

module.exports = {
    SyntaxReferenceError,
    SyntaxMatchError
};


/***/ }),

/***/ 45220:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isDigit = __nccwpck_require__(69549).isDigit;
var cmpChar = __nccwpck_require__(69549).cmpChar;
var TYPE = __nccwpck_require__(69549).TYPE;

var DELIM = TYPE.Delim;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function isDelim(token, code) {
    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
}

function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === WHITESPACE || token.type === COMMENT)) {
        token = getNextToken(++offset);
    }

    return offset;
}

function checkInteger(token, valueOffset, disallowSign, offset) {
    if (!token) {
        return 0;
    }

    var code = token.value.charCodeAt(valueOffset);

    if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
            // Number sign is not allowed
            return 0;
        }
        valueOffset++;
    }

    for (; valueOffset < token.value.length; valueOffset++) {
        if (!isDigit(token.value.charCodeAt(valueOffset))) {
            // Integer is expected
            return 0;
        }
    }

    return offset + 1;
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB(token, offset_, getNextToken) {
    var sign = false;
    var offset = skipSC(token, offset_, getNextToken);

    token = getNextToken(offset);

    if (token === null) {
        return offset_;
    }

    if (token.type !== NUMBER) {
        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);

            if (token === null && token.type !== NUMBER) {
                return 0;
            }
        } else {
            return offset_;
        }
    }

    if (!sign) {
        var code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN && code !== HYPHENMINUS) {
            // Number sign is expected
            return 0;
        }
    }

    return checkInteger(token, sign ? 0 : 1, sign, offset);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
module.exports = function anPlusB(token, getNextToken) {
    /* eslint-disable brace-style*/
    var offset = 0;

    if (!token) {
        return 0;
    }

    // <integer>
    if (token.type === NUMBER) {
        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
    }

    // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS) {
        // expect 1st char is N
        if (!cmpChar(token.value, 1, N)) {
            return 0;
        }

        switch (token.value.length) {
            // -n
            // -n <signed-integer>
            // -n ['+' | '-'] <signless-integer>
            case 2:
                return consumeB(getNextToken(++offset), offset, getNextToken);

            // -n- <signless-integer>
            case 3:
                if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger(token, 0, DISALLOW_SIGN, offset);

            // <dashndashdigit-ident>
            default:
                if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                    return 0;
                }

                return checkInteger(token, 3, DISALLOW_SIGN, offset);
        }
    }

    // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
        // just ignore a plus
        if (token.type !== IDENT) {
            token = getNextToken(++offset);
        }

        if (token === null || !cmpChar(token.value, 0, N)) {
            return 0;
        }

        switch (token.value.length) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
                return consumeB(getNextToken(++offset), offset, getNextToken);

            // '+'? n- <signless-integer>
            case 2:
                if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger(token, 0, DISALLOW_SIGN, offset);

            // '+'? <ndashdigit-ident>
            default:
                if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                    return 0;
                }

                return checkInteger(token, 2, DISALLOW_SIGN, offset);
        }
    }

    // <ndashdigit-dimension>
    // <ndash-dimension> <signless-integer>
    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    else if (token.type === DIMENSION) {
        var code = token.value.charCodeAt(0);
        var sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;

        for (var i = sign; i < token.value.length; i++) {
            if (!isDigit(token.value.charCodeAt(i))) {
                break;
            }
        }

        if (i === sign) {
            // Integer is expected
            return 0;
        }

        if (!cmpChar(token.value, i, N)) {
            return 0;
        }

        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        if (i + 1 === token.value.length) {
            return consumeB(getNextToken(++offset), offset, getNextToken);
        } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
                return 0;
            }

            // <ndash-dimension> <signless-integer>
            if (i + 2 === token.value.length) {
                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger(token, 0, DISALLOW_SIGN, offset);
            }
            // <ndashdigit-dimension>
            else {
                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
            }
        }
    }

    return 0;
};


/***/ }),

/***/ 48752:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isHexDigit = __nccwpck_require__(69549).isHexDigit;
var cmpChar = __nccwpck_require__(69549).cmpChar;
var TYPE = __nccwpck_require__(69549).TYPE;

var IDENT = TYPE.Ident;
var DELIM = TYPE.Delim;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)
var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function isDelim(token, code) {
    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
}

function startsWith(token, code) {
    return token.value.charCodeAt(0) === code;
}

function hexSequence(token, offset, allowDash) {
    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
        var code = token.value.charCodeAt(pos);

        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
                return 6; // dissallow following question marks
            }

            return 0; // dash at the ending of a hex sequence is not allowed
        }

        if (!isHexDigit(code)) {
            return 0; // not a hex digit
        }

        if (++hexlen > 6) {
            return 0; // too many hex digits
        };
    }

    return hexlen;
}

function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
        return 0; // nothing consumed
    }

    while (isDelim(getNextToken(length), QUESTIONMARK)) {
        if (++consumed > 6) {
            return 0; // too many question marks
        }

        length++;
    }

    return length;
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
module.exports = function urange(token, getNextToken) {
    var length = 0;

    // should start with `u` or `U`
    if (token === null || token.type !== IDENT || !cmpChar(token.value, 0, U)) {
        return 0;
    }

    token = getNextToken(++length);
    if (token === null) {
        return 0;
    }

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (isDelim(token, PLUSSIGN)) {
        token = getNextToken(++length);
        if (token === null) {
            return 0;
        }

        if (token.type === IDENT) {
            // u '+' <ident-token> '?'*
            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }

        if (isDelim(token, QUESTIONMARK)) {
            // u '+' '?'+
            return withQuestionMarkSequence(1, ++length, getNextToken);
        }

        // Hex digit or question mark is expected
        return 0;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (token.type === NUMBER) {
        if (!startsWith(token, PLUSSIGN)) {
            return 0;
        }

        var consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
            return 0;
        }

        token = getNextToken(++length);
        if (token === null) {
            // u <number-token> <eof>
            return length;
        }

        if (token.type === DIMENSION || token.type === NUMBER) {
            // u <number-token> <dimension-token>
            // u <number-token> <number-token>
            if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
                return 0;
            }

            return length + 1;
        }

        // u <number-token> '?'*
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    }

    // u <dimension-token> '?'*
    if (token.type === DIMENSION) {
        if (!startsWith(token, PLUSSIGN)) {
            return 0;
        }

        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }

    return 0;
};


/***/ }),

/***/ 20452:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var tokenizer = __nccwpck_require__(69549);
var isIdentifierStart = tokenizer.isIdentifierStart;
var isHexDigit = tokenizer.isHexDigit;
var isDigit = tokenizer.isDigit;
var cmpStr = tokenizer.cmpStr;
var consumeNumber = tokenizer.consumeNumber;
var TYPE = tokenizer.TYPE;
var anPlusB = __nccwpck_require__(45220);
var urange = __nccwpck_require__(48752);

var cssWideKeywords = ['unset', 'initial', 'inherit'];
var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

// https://www.w3.org/TR/css-values-3/#lengths
var LENGTH = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,
    'q': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

var ANGLE = {
    'deg': true,
    'grad': true,
    'rad': true,
    'turn': true
};

var TIME = {
    's': true,
    'ms': true
};

var FREQUENCY = {
    'hz': true,
    'khz': true
};

// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
var RESOLUTION = {
    'dpi': true,
    'dpcm': true,
    'dppx': true,
    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
};

// https://drafts.csswg.org/css-grid/#fr-unit
var FLEX = {
    'fr': true
};

// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
var DECIBEL = {
    'db': true
};

// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
var SEMITONES = {
    'st': true
};

// safe char code getter
function charCode(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
}

function eqStr(actual, expected) {
    return cmpStr(actual, 0, actual.length, expected);
}

function eqStrAny(actual, expected) {
    for (var i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
            return true;
        }
    }

    return false;
}

// IE postfix hack, i.e. 123\0 or 123px\9
function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
        return false;
    }

    return (
        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
        isDigit(str.charCodeAt(offset + 1))
    );
}

function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === 'Range') {
        var num = Number(
            numEnd !== undefined && numEnd !== value.length
                ? value.substr(0, numEnd)
                : value
        );

        if (isNaN(num)) {
            return true;
        }

        if (opts.min !== null && num < opts.min) {
            return true;
        }

        if (opts.max !== null && num > opts.max) {
            return true;
        }
    }

    return false;
}

function consumeFunction(token, getNextToken) {
    var startIdx = token.index;
    var length = 0;

    // balanced token consuming
    do {
        length++;

        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function calc(next) {
    return function(token, getNextToken, opts) {
        if (token === null) {
            return 0;
        }

        if (token.type === TYPE.Function && eqStrAny(token.value, calcFunctionNames)) {
            return consumeFunction(token, getNextToken);
        }

        return next(token, getNextToken, opts);
    };
}

function tokenType(expectedTokenType) {
    return function(token) {
        if (token === null || token.type !== expectedTokenType) {
            return 0;
        }

        return 1;
    };
}

function func(name) {
    name = name + '(';

    return function(token, getNextToken) {
        if (token !== null && eqStr(token.value, name)) {
            return consumeFunction(token, getNextToken);
        }

        return 0;
    };
}

// =========================
// Complex types
//

// https://drafts.csswg.org/css-values-4/#custom-idents
// 4.2. Author-defined Identifiers: the <custom-ident> type
// Some properties accept arbitrary author-defined identifiers as a component value.
// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
// that would not be misinterpreted as a pre-defined keyword in that propertys value definition.
//
// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
function customIdent(token) {
    if (token === null || token.type !== TYPE.Ident) {
        return 0;
    }

    var name = token.value.toLowerCase();

    // The CSS-wide keywords are not valid <custom-ident>s
    if (eqStrAny(name, cssWideKeywords)) {
        return 0;
    }

    // The default keyword is reserved and is also not a valid <custom-ident>
    if (eqStr(name, 'default')) {
        return 0;
    }

    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
    // Specifications using <custom-ident> must specify clearly what other keywords
    // are excluded from <custom-ident>, if anyfor example by saying that any pre-defined keywords
    // in that propertys value definition are excluded. Excluded keywords are excluded
    // in all ASCII case permutations.

    return 1;
}

// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
// The <custom-property-name> production corresponds to this: its defined as any valid identifier
// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
function customPropertyName(token) {
    // ... defined as any valid identifier
    if (token === null || token.type !== TYPE.Ident) {
        return 0;
    }

    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-color-4/#hex-notation
// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
// letters a-f (the case of the letters doesnt matter - #00ff00 is identical to #00FF00).
function hexColor(token) {
    if (token === null || token.type !== TYPE.Hash) {
        return 0;
    }

    var length = token.value.length;

    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
    }

    for (var i = 1; i < length; i++) {
        if (!isHexDigit(token.value.charCodeAt(i))) {
            return 0;
        }
    }

    return 1;
}

function idSelector(token) {
    if (token === null || token.type !== TYPE.Hash) {
        return 0;
    }

    if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-syntax/#any-value
// It represents the entirety of what a valid declaration can have as its value.
function declarationValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    var length = 0;
    var level = 0;
    var startIdx = token.index;

    // The <declaration-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case TYPE.BadString:
            case TYPE.BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case TYPE.RightCurlyBracket:
            case TYPE.RightParenthesis:
            case TYPE.RightSquareBracket:
                if (token.balance > token.index || token.balance < startIdx) {
                    break scan;
                }

                level--;
                break;

            // ... or top-level <semicolon-token> tokens
            case TYPE.Semicolon:
                if (level === 0) {
                    break scan;
                }

                break;

            // ... or <delim-token> tokens with a value of "!"
            case TYPE.Delim:
                if (token.value === '!' && level === 0) {
                    break scan;
                }

                break;

            case TYPE.Function:
            case TYPE.LeftParenthesis:
            case TYPE.LeftSquareBracket:
            case TYPE.LeftCurlyBracket:
                level++;
                break;
        }

        length++;

        // until balance closing
        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// https://drafts.csswg.org/css-syntax/#any-value
// The <any-value> production is identical to <declaration-value>, but also
// allows top-level <semicolon-token> tokens and <delim-token> tokens
// with a value of "!". It represents the entirety of what valid CSS can be in any context.
function anyValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    var startIdx = token.index;
    var length = 0;

    // The <any-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case TYPE.BadString:
            case TYPE.BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case TYPE.RightCurlyBracket:
            case TYPE.RightParenthesis:
            case TYPE.RightSquareBracket:
                if (token.balance > token.index || token.balance < startIdx) {
                    break scan;
                }

                break;
        }

        length++;

        // until balance closing
        if (token.balance <= startIdx) {
            break;
        }
    } while (token = getNextToken(length));

    return length;
}

// =========================
// Dimensions
//

function dimension(type) {
    return function(token, getNextToken, opts) {
        if (token === null || token.type !== TYPE.Dimension) {
            return 0;
        }

        var numberEnd = consumeNumber(token.value, 0);

        // check unit
        if (type !== null) {
            // check for IE postfix hack, i.e. 123px\0 or 123px\9
            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
                ? token.value.substr(numberEnd)
                : token.value.substring(numberEnd, reverseSolidusOffset);

            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
                return 0;
            }
        }

        // check range if specified
        if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
        }

        return 1;
    };
}

// =========================
// Percentage
//

// 5.5. Percentages: the <percentage> type
// https://drafts.csswg.org/css-values-4/#percentages
function percentage(token, getNextToken, opts) {
    // ... corresponds to the <percentage-token> production
    if (token === null || token.type !== TYPE.Percentage) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
    }

    return 1;
}

// =========================
// Numeric
//

// https://drafts.csswg.org/css-values-4/#numbers
// The value <zero> represents a literal number with the value 0. Expressions that merely
// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
// only literal <number-token>s do.
function zero(next) {
    if (typeof next !== 'function') {
        next = function() {
            return 0;
        };
    }

    return function(token, getNextToken, opts) {
        if (token !== null && token.type === TYPE.Number) {
            if (Number(token.value) === 0) {
                return 1;
            }
        }

        return next(token, getNextToken, opts);
    };
}

//  5.3. Real Numbers: the <number> type
// https://drafts.csswg.org/css-values-4/#numbers
// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
// ... It corresponds to the <number-token> production
function number(token, getNextToken, opts) {
    if (token === null) {
        return 0;
    }

    var numberEnd = consumeNumber(token.value, 0);
    var isNumber = numberEnd === token.value.length;
    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
    }

    return 1;
}

// 5.2. Integers: the <integer> type
// https://drafts.csswg.org/css-values-4/#integers
function integer(token, getNextToken, opts) {
    // ... corresponds to a subset of the <number-token> production
    if (token === null || token.type !== TYPE.Number) {
        return 0;
    }

    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integers sign.
    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

    // When written literally, an integer is one or more decimal digits 0 through 9 ...
    for (; i < token.value.length; i++) {
        if (!isDigit(token.value.charCodeAt(i))) {
            return 0;
        }
    }

    // check range if specified
    if (outOfRange(opts, token.value, i)) {
        return 0;
    }

    return 1;
}

module.exports = {
    // token types
    'ident-token': tokenType(TYPE.Ident),
    'function-token': tokenType(TYPE.Function),
    'at-keyword-token': tokenType(TYPE.AtKeyword),
    'hash-token': tokenType(TYPE.Hash),
    'string-token': tokenType(TYPE.String),
    'bad-string-token': tokenType(TYPE.BadString),
    'url-token': tokenType(TYPE.Url),
    'bad-url-token': tokenType(TYPE.BadUrl),
    'delim-token': tokenType(TYPE.Delim),
    'number-token': tokenType(TYPE.Number),
    'percentage-token': tokenType(TYPE.Percentage),
    'dimension-token': tokenType(TYPE.Dimension),
    'whitespace-token': tokenType(TYPE.WhiteSpace),
    'CDO-token': tokenType(TYPE.CDO),
    'CDC-token': tokenType(TYPE.CDC),
    'colon-token': tokenType(TYPE.Colon),
    'semicolon-token': tokenType(TYPE.Semicolon),
    'comma-token': tokenType(TYPE.Comma),
    '[-token': tokenType(TYPE.LeftSquareBracket),
    ']-token': tokenType(TYPE.RightSquareBracket),
    '(-token': tokenType(TYPE.LeftParenthesis),
    ')-token': tokenType(TYPE.RightParenthesis),
    '{-token': tokenType(TYPE.LeftCurlyBracket),
    '}-token': tokenType(TYPE.RightCurlyBracket),

    // token type aliases
    'string': tokenType(TYPE.String),
    'ident': tokenType(TYPE.Ident),

    // complex types
    'custom-ident': customIdent,
    'custom-property-name': customPropertyName,
    'hex-color': hexColor,
    'id-selector': idSelector, // element( <id-selector> )
    'an-plus-b': anPlusB,
    'urange': urange,
    'declaration-value': declarationValue,
    'any-value': anyValue,

    // dimensions
    'dimension': calc(dimension(null)),
    'angle': calc(dimension(ANGLE)),
    'decibel': calc(dimension(DECIBEL)),
    'frequency': calc(dimension(FREQUENCY)),
    'flex': calc(dimension(FLEX)),
    'length': calc(zero(dimension(LENGTH))),
    'resolution': calc(dimension(RESOLUTION)),
    'semitones': calc(dimension(SEMITONES)),
    'time': calc(dimension(TIME)),

    // percentage
    'percentage': calc(percentage),

    // numeric
    'zero': zero(),
    'number': calc(number),
    'integer': calc(integer),

    // old IE stuff
    '-ms-legacy-expression': func('expression')
};


/***/ }),

/***/ 79987:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var parse = __nccwpck_require__(50362);

var MATCH = { type: 'Match' };
var MISMATCH = { type: 'Mismatch' };
var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
var LEFTPARENTHESIS = 40;  // (
var RIGHTPARENTHESIS = 41; // )

function createCondition(match, thenBranch, elseBranch) {
    // reduce node count
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
    }

    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
    }

    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
    }

    return {
        type: 'If',
        match: match,
        then: thenBranch,
        else: elseBranch
    };
}

function isFunctionType(name) {
    return (
        name.length > 2 &&
        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&
        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS
    );
}

function isEnumCapatible(term) {
    return (
        term.type === 'Keyword' ||
        term.type === 'AtKeyword' ||
        term.type === 'Function' ||
        term.type === 'Type' && isFunctionType(term.name)
    );
}

function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
        case ' ':
            // Juxtaposing components means that all of them must occur, in the given order.
            //
            // a b c
            // =
            // match a
            //   then match b
            //     then match c
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            //   else MISMATCH
            var result = MATCH;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];

                result = createCondition(
                    term,
                    result,
                    MISMATCH
                );
            };

            return result;

        case '|':
            // A bar (|) separates two or more alternatives: exactly one of them must occur.
            //
            // a | b | c
            // =
            // match a
            //   then MATCH
            //   else match b
            //     then MATCH
            //     else match c
            //       then MATCH
            //       else MISMATCH

            var result = MISMATCH;
            var map = null;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];

                // reduce sequence of keywords into a Enum
                if (isEnumCapatible(term)) {
                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                        map = Object.create(null);
                        result = createCondition(
                            {
                                type: 'Enum',
                                map: map
                            },
                            MATCH,
                            result
                        );
                    }

                    if (map !== null) {
                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                        if (key in map === false) {
                            map[key] = term;
                            continue;
                        }
                    }
                }

                map = null;

                // create a new conditonal node
                result = createCondition(
                    term,
                    MATCH,
                    result
                );
            };

            return result;

        case '&&':
            // A double ampersand (&&) separates two or more components,
            // all of which must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since &&-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms: terms,
                    all: true
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a && b && c
            // =
            // match a
            //   then [b && c]
            //   else match b
            //     then [a && c]
            //     else match c
            //       then [a && b]
            //       else MISMATCH
            //
            // a && b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MISMATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            var result = MISMATCH;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];
                var thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        false
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            };

            return result;

        case '||':
            // A double bar (||) separates two or more options:
            // one or more of them must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since ||-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms: terms,
                    all: false
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a || b || c
            // =
            // match a
            //   then [b || c]
            //   else match b
            //     then [a || c]
            //     else match c
            //       then [a || b]
            //       else MISMATCH
            //
            // a || b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MATCH
            //     else MISMATCH
            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];
                var thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        true
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            };

            return result;
    }
}

function buildMultiplierMatchGraph(node) {
    var result = MATCH;
    var matchTerm = buildMatchGraph(node.term);

    if (node.max === 0) {
        // disable repeating of empty match to prevent infinite loop
        matchTerm = createCondition(
            matchTerm,
            DISALLOW_EMPTY,
            MISMATCH
        );

        // an occurrence count is not limited, make a cycle;
        // to collect more terms on each following matching mismatch
        result = createCondition(
            matchTerm,
            null, // will be a loop
            MISMATCH
        );

        result.then = createCondition(
            MATCH,
            MATCH,
            result // make a loop
        );

        if (node.comma) {
            result.then.else = createCondition(
                { type: 'Comma', syntax: node },
                result,
                MISMATCH
            );
        }
    } else {
        // create a match node chain for [min .. max] interval with optional matches
        for (var i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                createCondition(
                    MATCH,
                    MATCH,
                    result
                ),
                MISMATCH
            );
        }
    }

    if (node.min === 0) {
        // allow zero match
        result = createCondition(
            MATCH,
            MATCH,
            result
        );
    } else {
        // create a match node chain to collect [0 ... min - 1] required matches
        for (var i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                result,
                MISMATCH
            );
        }
    }

    return result;
}

function buildMatchGraph(node) {
    if (typeof node === 'function') {
        return {
            type: 'Generic',
            fn: node
        };
    }

    switch (node.type) {
        case 'Group':
            var result = buildGroupMatchGraph(
                node.combinator,
                node.terms.map(buildMatchGraph),
                false
            );

            if (node.disallowEmpty) {
                result = createCondition(
                    result,
                    DISALLOW_EMPTY,
                    MISMATCH
                );
            }

            return result;

        case 'Multiplier':
            return buildMultiplierMatchGraph(node);

        case 'Type':
        case 'Property':
            return {
                type: node.type,
                name: node.name,
                syntax: node
            };

        case 'Keyword':
            return {
                type: node.type,
                name: node.name.toLowerCase(),
                syntax: node
            };

        case 'AtKeyword':
            return {
                type: node.type,
                name: '@' + node.name.toLowerCase(),
                syntax: node
            };

        case 'Function':
            return {
                type: node.type,
                name: node.name.toLowerCase() + '(',
                syntax: node
            };

        case 'String':
            // convert a one char length String to a Token
            if (node.value.length === 3) {
                return {
                    type: 'Token',
                    value: node.value.charAt(1),
                    syntax: node
                };
            }

            // otherwise use it as is
            return {
                type: node.type,
                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
                syntax: node
            };

        case 'Token':
            return {
                type: node.type,
                value: node.value,
                syntax: node
            };

        case 'Comma':
            return {
                type: node.type,
                syntax: node
            };

        default:
            throw new Error('Unknown node type:', node.type);
    }
}

module.exports = {
    MATCH: MATCH,
    MISMATCH: MISMATCH,
    DISALLOW_EMPTY: DISALLOW_EMPTY,
    buildMatchGraph: function(syntaxTree, ref) {
        if (typeof syntaxTree === 'string') {
            syntaxTree = parse(syntaxTree);
        }

        return {
            type: 'MatchGraph',
            match: buildMatchGraph(syntaxTree),
            syntax: ref || null,
            source: syntaxTree
        };
    }
};


/***/ }),

/***/ 22092:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var hasOwnProperty = Object.prototype.hasOwnProperty;
var matchGraph = __nccwpck_require__(79987);
var MATCH = matchGraph.MATCH;
var MISMATCH = matchGraph.MISMATCH;
var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
var TYPE = __nccwpck_require__(62478).TYPE;

var STUB = 0;
var TOKEN = 1;
var OPEN_SYNTAX = 2;
var CLOSE_SYNTAX = 3;

var EXIT_REASON_MATCH = 'Match';
var EXIT_REASON_MISMATCH = 'Mismatch';
var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

var ITERATION_LIMIT = 15000;
var totalIterationCount = 0;

function reverseList(list) {
    var prev = null;
    var next = null;
    var item = list;

    while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
    }

    return prev;
}

function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
        return false;
    }

    for (var i = 0; i < testStr.length; i++) {
        var testCode = testStr.charCodeAt(i);
        var referenceCode = referenceStr.charCodeAt(i);

        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
        if (testCode >= 0x0041 && testCode <= 0x005A) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function isContextEdgeDelim(token) {
    if (token.type !== TYPE.Delim) {
        return false;
    }

    // Fix matching for unicode-range: U+30??, U+FF00-FF9F
    // Probably we need to check out previous match instead
    return token.value !== '?';
}

function isCommaContextStart(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === TYPE.Comma ||
        token.type === TYPE.Function ||
        token.type === TYPE.LeftParenthesis ||
        token.type === TYPE.LeftSquareBracket ||
        token.type === TYPE.LeftCurlyBracket ||
        isContextEdgeDelim(token)
    );
}

function isCommaContextEnd(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === TYPE.RightParenthesis ||
        token.type === TYPE.RightSquareBracket ||
        token.type === TYPE.RightCurlyBracket ||
        token.type === TYPE.Delim
    );
}

function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
        do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));
    }

    function getNextToken(offset) {
        var nextIndex = tokenIndex + offset;

        return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }

    function stateSnapshotFromSyntax(nextState, prev) {
        return {
            nextState: nextState,
            matchStack: matchStack,
            syntaxStack: syntaxStack,
            thenStack: thenStack,
            tokenIndex: tokenIndex,
            prev: prev
        };
    }

    function pushThenStack(nextState) {
        thenStack = {
            nextState: nextState,
            matchStack: matchStack,
            syntaxStack: syntaxStack,
            prev: thenStack
        };
    }

    function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }

    function addTokenToMatch() {
        matchStack = {
            type: TOKEN,
            syntax: state.syntax,
            token: token,
            prev: matchStack
        };

        moveToNextToken();
        syntaxStash = null;

        if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
        }
    }

    function openSyntax() {
        syntaxStack = {
            syntax: state.syntax,
            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
            prev: syntaxStack
        };

        matchStack = {
            type: OPEN_SYNTAX,
            syntax: state.syntax,
            token: matchStack.token,
            prev: matchStack
        };
    }

    function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
        } else {
            matchStack = {
                type: CLOSE_SYNTAX,
                syntax: syntaxStack.syntax,
                token: matchStack.token,
                prev: matchStack
            };
        }

        syntaxStack = syntaxStack.prev;
    }

    var syntaxStack = null;
    var thenStack = null;
    var elseStack = null;

    // null  stashing allowed, nothing stashed
    // false  stashing disabled, nothing stashed
    // anithing else  fail stashable syntaxes, some syntax stashed
    var syntaxStash = null;

    var iterationCount = 0; // count iterations and prevent infinite loop
    var exitReason = null;

    var token = null;
    var tokenIndex = -1;
    var longestMatch = 0;
    var matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
    };

    moveToNextToken();

    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        // function mapList(list, fn) {
        //     var result = [];
        //     while (list) {
        //         result.unshift(fn(list));
        //         list = list.prev;
        //     }
        //     return result;
        // }
        // console.log('--\n',
        //     '#' + iterationCount,
        //     require('util').inspect({
        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
        //         token: token && token.value,
        //         tokenIndex,
        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
        //     }, { depth: null })
        // );
        switch (state.type) {
            case 'Match':
                if (thenStack === null) {
                    // turn to MISMATCH when some tokens left unmatched
                    if (token !== null) {
                        // doesn't mismatch if just one token left and it's an IE hack
                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
                            state = MISMATCH;
                            break;
                        }
                    }

                    // break the main loop, return a result - MATCH
                    exitReason = EXIT_REASON_MATCH;
                    break;
                }

                // go to next syntax (`then` branch)
                state = thenStack.nextState;

                // check match is not empty
                if (state === DISALLOW_EMPTY) {
                    if (thenStack.matchStack === matchStack) {
                        state = MISMATCH;
                        break;
                    } else {
                        state = MATCH;
                    }
                }

                // close syntax if needed
                while (thenStack.syntaxStack !== syntaxStack) {
                    closeSyntax();
                }

                // pop stack
                thenStack = thenStack.prev;
                break;

            case 'Mismatch':
                // when some syntax is stashed
                if (syntaxStash !== null && syntaxStash !== false) {
                    // there is no else branches or a branch reduce match stack
                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                        // restore state from the stash
                        elseStack = syntaxStash;
                        syntaxStash = false; // disable stashing
                    }
                } else if (elseStack === null) {
                    // no else branches -> break the main loop
                    // return a result - MISMATCH
                    exitReason = EXIT_REASON_MISMATCH;
                    break;
                }

                // go to next syntax (`else` branch)
                state = elseStack.nextState;

                // restore all the rest stack states
                thenStack = elseStack.thenStack;
                syntaxStack = elseStack.syntaxStack;
                matchStack = elseStack.matchStack;
                tokenIndex = elseStack.tokenIndex;
                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

                // pop stack
                elseStack = elseStack.prev;
                break;

            case 'MatchGraph':
                state = state.match;
                break;

            case 'If':
                // IMPORTANT: else stack push must go first,
                // since it stores the state of thenStack before changes
                if (state.else !== MISMATCH) {
                    pushElseStack(state.else);
                }

                if (state.then !== MATCH) {
                    pushThenStack(state.then);
                }

                state = state.match;
                break;

            case 'MatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state,
                    index: 0,
                    mask: 0
                };
                break;

            case 'MatchOnceBuffer':
                var terms = state.syntax.terms;

                if (state.index === terms.length) {
                    // no matches at all or it's required all terms to be matched
                    if (state.mask === 0 || state.syntax.all) {
                        state = MISMATCH;
                        break;
                    }

                    // a partial match is ok
                    state = MATCH;
                    break;
                }

                // all terms are matched
                if (state.mask === (1 << terms.length) - 1) {
                    state = MATCH;
                    break;
                }

                for (; state.index < terms.length; state.index++) {
                    var matchFlag = 1 << state.index;

                    if ((state.mask & matchFlag) === 0) {
                        // IMPORTANT: else stack push must go first,
                        // since it stores the state of thenStack before changes
                        pushElseStack(state);
                        pushThenStack({
                            type: 'AddMatchOnce',
                            syntax: state.syntax,
                            mask: state.mask | matchFlag
                        });

                        // match
                        state = terms[state.index++];
                        break;
                    }
                }
                break;

            case 'AddMatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state.syntax,
                    index: 0,
                    mask: state.mask
                };
                break;

            case 'Enum':
                if (token !== null) {
                    var name = token.value.toLowerCase();

                    // drop \0 and \9 hack from keyword name
                    if (name.indexOf('\\') !== -1) {
                        name = name.replace(/\\[09].*$/, '');
                    }

                    if (hasOwnProperty.call(state.map, name)) {
                        state = state.map[name];
                        break;
                    }
                }

                state = MISMATCH;
                break;

            case 'Generic':
                var opts = syntaxStack !== null ? syntaxStack.opts : null;
                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;

            case 'Type':
            case 'Property':
                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
                var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

                if (!dictSyntax || !dictSyntax.match) {
                    throw new Error(
                        'Bad syntax reference: ' +
                        (state.type === 'Type'
                            ? '<' + state.name + '>'
                            : '<\'' + state.name + '\'>')
                    );
                }

                // stash a syntax for types with low priority
                if (syntaxStash !== false && token !== null && state.type === 'Type') {
                    var lowPriorityMatching =
                        // https://drafts.csswg.org/css-values-4/#custom-idents
                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                        // can only claim the keyword if no other unfulfilled production can claim it.
                        (state.name === 'custom-ident' && token.type === TYPE.Ident) ||

                        // https://drafts.csswg.org/css-values-4/#lengths
                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                        // it must parse as a <number>
                        (state.name === 'length' && token.value === '0');

                    if (lowPriorityMatching) {
                        if (syntaxStash === null) {
                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                        }

                        state = MISMATCH;
                        break;
                    }
                }

                openSyntax();
                state = dictSyntax.match;
                break;

            case 'Keyword':
                var name = state.name;

                if (token !== null) {
                    var keywordName = token.value;

                    // drop \0 and \9 hack from keyword name
                    if (keywordName.indexOf('\\') !== -1) {
                        keywordName = keywordName.replace(/\\[09].*$/, '');
                    }

                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
                        addTokenToMatch();
                        state = MATCH;
                        break;
                    }
                }

                state = MISMATCH;
                break;

            case 'AtKeyword':
            case 'Function':
                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Token':
                if (token !== null && token.value === state.value) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Comma':
                if (token !== null && token.type === TYPE.Comma) {
                    if (isCommaContextStart(matchStack.token)) {
                        state = MISMATCH;
                    } else {
                        addTokenToMatch();
                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;
                    }
                } else {
                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
                }

                break;

            case 'String':
                var string = '';

                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
                    string += tokens[lastTokenIndex].value;
                }

                if (areStringsEqualCaseInsensitive(string, state.value)) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;

            default:
                throw new Error('Unknown node type: ' + state.type);
        }
    }

    totalIterationCount += iterationCount;

    switch (exitReason) {
        case null:
            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;

        case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
                closeSyntax();
            }
            break;

        default:
            matchStack = null;
    }

    return {
        tokens: tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch: longestMatch
    };
}

function matchAsList(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match !== null) {
        var item = reverseList(matchResult.match).prev;

        matchResult.match = [];

        while (item !== null) {
            switch (item.type) {
                case STUB:
                    break;

                case OPEN_SYNTAX:
                case CLOSE_SYNTAX:
                    matchResult.match.push({
                        type: item.type,
                        syntax: item.syntax
                    });
                    break;

                default:
                    matchResult.match.push({
                        token: item.token.value,
                        node: item.token.node
                    });
                    break;
            }

            item = item.prev;
        }
    }

    return matchResult;
}

function matchAsTree(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match === null) {
        return matchResult;
    }

    var item = matchResult.match;
    var host = matchResult.match = {
        syntax: matchGraph.syntax || null,
        match: []
    };
    var hostStack = [host];

    // revert a list and start with 2nd item since 1st is a stub item
    item = reverseList(item).prev;

    // build a tree
    while (item !== null) {
        switch (item.type) {
            case OPEN_SYNTAX:
                host.match.push(host = {
                    syntax: item.syntax,
                    match: []
                });
                hostStack.push(host);
                break;

            case CLOSE_SYNTAX:
                hostStack.pop();
                host = hostStack[hostStack.length - 1];
                break;

            default:
                host.match.push({
                    syntax: item.syntax || null,
                    token: item.token.value,
                    node: item.token.node
                });
        }

        item = item.prev;
    }

    return matchResult;
}

module.exports = {
    matchAsList: matchAsList,
    matchAsTree: matchAsTree,
    getTotalIterationCount: function() {
        return totalIterationCount;
    }
};


/***/ }),

/***/ 81595:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var tokenize = __nccwpck_require__(69549);
var TokenStream = __nccwpck_require__(89490);
var tokenStream = new TokenStream();
var astToTokens = {
    decorator: function(handlers) {
        var curNode = null;
        var prev = { len: 0, node: null };
        var nodes = [prev];
        var buffer = '';

        return {
            children: handlers.children,
            node: function(node) {
                var tmp = curNode;
                curNode = node;
                handlers.node.call(this, node);
                curNode = tmp;
            },
            chunk: function(chunk) {
                buffer += chunk;
                if (prev.node !== curNode) {
                    nodes.push({
                        len: chunk.length,
                        node: curNode
                    });
                } else {
                    prev.len += chunk.length;
                }
            },
            result: function() {
                return prepareTokens(buffer, nodes);
            }
        };
    }
};

function prepareTokens(str, nodes) {
    var tokens = [];
    var nodesOffset = 0;
    var nodesIndex = 0;
    var currentNode = nodes ? nodes[nodesIndex].node : null;

    tokenize(str, tokenStream);

    while (!tokenStream.eof) {
        if (nodes) {
            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
                nodesOffset += nodes[nodesIndex++].len;
                currentNode = nodes[nodesIndex].node;
            }
        }

        tokens.push({
            type: tokenStream.tokenType,
            value: tokenStream.getTokenValue(),
            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
            node: currentNode
        });
        tokenStream.next();
        // console.log({ ...tokens[tokens.length - 1], node: undefined });
    }

    return tokens;
}

module.exports = function(value, syntax) {
    if (typeof value === 'string') {
        return prepareTokens(value, null);
    }

    return syntax.generate(value, astToTokens);
};


/***/ }),

/***/ 33036:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var List = __nccwpck_require__(11282);

function getFirstMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
        if (matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name) {
            var start = getFirstMatchNode(matchNode);
            var end = getLastMatchNode(matchNode);

            lexer.syntax.walk(ast, function(node, item, list) {
                if (node === start) {
                    var nodes = new List();

                    do {
                        nodes.appendData(item.data);

                        if (item.data === end) {
                            break;
                        }

                        item = item.next;
                    } while (item !== null);

                    fragments.push({
                        parent: list,
                        nodes: nodes
                    });
                }
            });
        }

        if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
        }
    }

    var fragments = [];

    if (match.matched !== null) {
        findFragments(match.matched);
    }

    return fragments;
}

module.exports = {
    matchFragments: matchFragments
};


/***/ }),

/***/ 20846:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var List = __nccwpck_require__(11282);
var hasOwnProperty = Object.prototype.hasOwnProperty;

function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return (
        typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value &&
        value >= 0
    );
}

function isValidLocation(loc) {
    return (
        Boolean(loc) &&
        isValidNumber(loc.offset) &&
        isValidNumber(loc.line) &&
        isValidNumber(loc.column)
    );
}

function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
            return warn(node, 'Type of node should be an Object');
        }

        for (var key in node) {
            var valid = true;

            if (hasOwnProperty.call(node, key) === false) {
                continue;
            }

            if (key === 'type') {
                if (node.type !== type) {
                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
                }
            } else if (key === 'loc') {
                if (node.loc === null) {
                    continue;
                } else if (node.loc && node.loc.constructor === Object) {
                    if (typeof node.loc.source !== 'string') {
                        key += '.source';
                    } else if (!isValidLocation(node.loc.start)) {
                        key += '.start';
                    } else if (!isValidLocation(node.loc.end)) {
                        key += '.end';
                    } else {
                        continue;
                    }
                }

                valid = false;
            } else if (fields.hasOwnProperty(key)) {
                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
                    var fieldType = fields[key][i];

                    switch (fieldType) {
                        case String:
                            valid = typeof node[key] === 'string';
                            break;

                        case Boolean:
                            valid = typeof node[key] === 'boolean';
                            break;

                        case null:
                            valid = node[key] === null;
                            break;

                        default:
                            if (typeof fieldType === 'string') {
                                valid = node[key] && node[key].type === fieldType;
                            } else if (Array.isArray(fieldType)) {
                                valid = node[key] instanceof List;
                            }
                    }
                }
            } else {
                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
            }

            if (!valid) {
                warn(node, 'Bad value for `' + type + '.' + key + '`');
            }
        }

        for (var key in fields) {
            if (hasOwnProperty.call(fields, key) &&
                hasOwnProperty.call(node, key) === false) {
                warn(node, 'Field `' + type + '.' + key + '` is missed');
            }
        }
    };
}

function processStructure(name, nodeType) {
    var structure = nodeType.structure;
    var fields = {
        type: String,
        loc: true
    };
    var docs = {
        type: '"' + name + '"'
    };

    for (var key in structure) {
        if (hasOwnProperty.call(structure, key) === false) {
            continue;
        }

        var docsTypes = [];
        var fieldTypes = fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]];

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
                docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
                docsTypes.push('null');
            } else if (typeof fieldType === 'string') {
                docsTypes.push('<' + fieldType + '>');
            } else if (Array.isArray(fieldType)) {
                docsTypes.push('List'); // TODO: use type enum
            } else {
                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
            }
        }

        docs[key] = docsTypes.join(' | ');
    }

    return {
        docs: docs,
        check: createNodeStructureChecker(name, fields)
    };
}

module.exports = {
    getStructureFromConfig: function(config) {
        var structure = {};

        if (config.node) {
            for (var name in config.node) {
                if (hasOwnProperty.call(config.node, name)) {
                    var nodeType = config.node[name];

                    if (nodeType.structure) {
                        structure[name] = processStructure(name, nodeType);
                    } else {
                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
                    }
                }
            }
        }

        return structure;
    }
};


/***/ }),

/***/ 78078:
/***/ ((module) => {

function getTrace(node) {
    function shouldPutToTrace(syntax) {
        if (syntax === null) {
            return false;
        }

        return (
            syntax.type === 'Type' ||
            syntax.type === 'Property' ||
            syntax.type === 'Keyword'
        );
    }

    function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
            // use for-loop for better perfomance
            for (var i = 0; i < matchNode.match.length; i++) {
                if (hasMatch(matchNode.match[i])) {
                    if (shouldPutToTrace(matchNode.syntax)) {
                        result.unshift(matchNode.syntax);
                    }

                    return true;
                }
            }
        } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
                ? [matchNode.syntax]
                : [];

            return true;
        }

        return false;
    }

    var result = null;

    if (this.matched !== null) {
        hasMatch(this.matched);
    }

    return result;
}

function testNode(match, node, fn) {
    var trace = getTrace.call(match, node);

    if (trace === null) {
        return false;
    }

    return trace.some(fn);
}

function isType(node, type) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Type' && matchNode.name === type;
    });
}

function isProperty(node, property) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Property' && matchNode.name === property;
    });
}

function isKeyword(node) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Keyword';
    });
}

module.exports = {
    getTrace: getTrace,
    isType: isType,
    isProperty: isProperty,
    isKeyword: isKeyword
};


/***/ }),

/***/ 25569:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var OffsetToLocation = __nccwpck_require__(77634);
var SyntaxError = __nccwpck_require__(83981);
var TokenStream = __nccwpck_require__(89490);
var List = __nccwpck_require__(11282);
var tokenize = __nccwpck_require__(69549);
var constants = __nccwpck_require__(62478);
var { findWhiteSpaceStart, cmpStr } = __nccwpck_require__(29292);
var sequence = __nccwpck_require__(74263);
var noop = function() {};

var TYPE = constants.TYPE;
var NAME = constants.NAME;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var HASH = TYPE.Hash;
var PERCENTAGE = TYPE.Percentage;
var NUMBER = TYPE.Number;
var NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)
var NULL = 0;

function createParseContext(name) {
    return function() {
        return this[name]();
    };
}

function processConfig(config) {
    var parserConfig = {
        context: {},
        scope: {},
        atrule: {},
        pseudo: {}
    };

    if (config.parseContext) {
        for (var name in config.parseContext) {
            switch (typeof config.parseContext[name]) {
                case 'function':
                    parserConfig.context[name] = config.parseContext[name];
                    break;

                case 'string':
                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
                    break;
            }
        }
    }

    if (config.scope) {
        for (var name in config.scope) {
            parserConfig.scope[name] = config.scope[name];
        }
    }

    if (config.atrule) {
        for (var name in config.atrule) {
            var atrule = config.atrule[name];

            if (atrule.parse) {
                parserConfig.atrule[name] = atrule.parse;
            }
        }
    }

    if (config.pseudo) {
        for (var name in config.pseudo) {
            var pseudo = config.pseudo[name];

            if (pseudo.parse) {
                parserConfig.pseudo[name] = pseudo.parse;
            }
        }
    }

    if (config.node) {
        for (var name in config.node) {
            parserConfig[name] = config.node[name].parse;
        }
    }

    return parserConfig;
}

module.exports = function createParser(config) {
    var parser = {
        scanner: new TokenStream(),
        locationMap: new OffsetToLocation(),

        filename: '<unknown>',
        needPositions: false,
        onParseError: noop,
        onParseErrorThrow: false,
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,

        readSequence: sequence,

        createList: function() {
            return new List();
        },
        createSingleNodeList: function(node) {
            return new List().appendData(node);
        },
        getFirstListNode: function(list) {
            return list && list.first();
        },
        getLastListNode: function(list) {
            return list.last();
        },

        parseWithFallback: function(consumer, fallback) {
            var startToken = this.scanner.tokenIndex;

            try {
                return consumer.call(this);
            } catch (e) {
                if (this.onParseErrorThrow) {
                    throw e;
                }

                var fallbackNode = fallback.call(this, startToken);

                this.onParseErrorThrow = true;
                this.onParseError(e, fallbackNode);
                this.onParseErrorThrow = false;

                return fallbackNode;
            }
        },

        lookupNonWSType: function(offset) {
            do {
                var type = this.scanner.lookupType(offset++);
                if (type !== WHITESPACE) {
                    return type;
                }
            } while (type !== NULL);

            return NULL;
        },

        eat: function(tokenType) {
            if (this.scanner.tokenType !== tokenType) {
                var offset = this.scanner.tokenStart;
                var message = NAME[tokenType] + ' is expected';

                // tweak message and offset
                switch (tokenType) {
                    case IDENT:
                        // when identifier is expected but there is a function or url
                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {
                            offset = this.scanner.tokenEnd - 1;
                            message = 'Identifier is expected but function found';
                        } else {
                            message = 'Identifier is expected';
                        }
                        break;

                    case HASH:
                        if (this.scanner.isDelim(NUMBERSIGN)) {
                            this.scanner.next();
                            offset++;
                            message = 'Name is expected';
                        }
                        break;

                    case PERCENTAGE:
                        if (this.scanner.tokenType === NUMBER) {
                            offset = this.scanner.tokenEnd;
                            message = 'Percent sign is expected';
                        }
                        break;

                    default:
                        // when test type is part of another token show error for current position + 1
                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
                            offset = offset + 1;
                        }
                }

                this.error(message, offset);
            }

            this.scanner.next();
        },

        consume: function(tokenType) {
            var value = this.scanner.getTokenValue();

            this.eat(tokenType);

            return value;
        },
        consumeFunctionName: function() {
            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

            this.eat(FUNCTION);

            return name;
        },

        getLocation: function(start, end) {
            if (this.needPositions) {
                return this.locationMap.getLocationRange(
                    start,
                    end,
                    this.filename
                );
            }

            return null;
        },
        getLocationFromList: function(list) {
            if (this.needPositions) {
                var head = this.getFirstListNode(list);
                var tail = this.getLastListNode(list);
                return this.locationMap.getLocationRange(
                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
                    this.filename
                );
            }

            return null;
        },

        error: function(message, offset) {
            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
                ? this.locationMap.getLocation(offset)
                : this.scanner.eof
                    ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1))
                    : this.locationMap.getLocation(this.scanner.tokenStart);

            throw new SyntaxError(
                message || 'Unexpected input',
                this.scanner.source,
                location.offset,
                location.line,
                location.column
            );
        }
    };

    config = processConfig(config || {});
    for (var key in config) {
        parser[key] = config[key];
    }

    return function(source, options) {
        options = options || {};

        var context = options.context || 'default';
        var onComment = options.onComment;
        var ast;

        tokenize(source, parser.scanner);
        parser.locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column
        );

        parser.filename = options.filename || '<unknown>';
        parser.needPositions = Boolean(options.positions);
        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;
        parser.onParseErrorThrow = false;
        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        if (!parser.context.hasOwnProperty(context)) {
            throw new Error('Unknown context `' + context + '`');
        }

        if (typeof onComment === 'function') {
            parser.scanner.forEachToken((type, start, end) => {
                if (type === COMMENT) {
                    const loc = parser.getLocation(start, end);
                    const value = cmpStr(source, end - 2, end, '*/')
                        ? source.slice(start + 2, end - 2)
                        : source.slice(start + 2, end);

                    onComment(value, loc);
                }
            });
        }

        ast = parser.context[context].call(parser, options);

        if (!parser.scanner.eof) {
            parser.error();
        }

        return ast;
    };
};


/***/ }),

/***/ 74263:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;

module.exports = function readSequence(recognizer) {
    var children = this.createList();
    var child = null;
    var context = {
        recognizer: recognizer,
        space: null,
        ignoreWS: false,
        ignoreWSAfter: false
    };

    this.scanner.skipSC();

    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case COMMENT:
                this.scanner.next();
                continue;

            case WHITESPACE:
                if (context.ignoreWS) {
                    this.scanner.next();
                } else {
                    context.space = this.WhiteSpace();
                }
                continue;
        }

        child = recognizer.getNode.call(this, context);

        if (child === undefined) {
            break;
        }

        if (context.space !== null) {
            children.push(context.space);
            context.space = null;
        }

        children.push(child);

        if (context.ignoreWSAfter) {
            context.ignoreWSAfter = false;
            context.ignoreWS = true;
        } else {
            context.ignoreWS = false;
        }
    }

    return children;
};


/***/ }),

/***/ 36469:
/***/ ((module) => {

module.exports = {
    parse: {
        prelude: null,
        block: function() {
            return this.Block(true);
        }
    }
};


/***/ }),

/***/ 47672:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var STRING = TYPE.String;
var IDENT = TYPE.Ident;
var URL = TYPE.Url;
var FUNCTION = TYPE.Function;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

module.exports = {
    parse: {
        prelude: function() {
            var children = this.createList();

            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case STRING:
                    children.push(this.String());
                    break;

                case URL:
                case FUNCTION:
                    children.push(this.Url());
                    break;

                default:
                    this.error('String or url() is expected');
            }

            if (this.lookupNonWSType(0) === IDENT ||
                this.lookupNonWSType(0) === LEFTPARENTHESIS) {
                children.push(this.WhiteSpace());
                children.push(this.MediaQueryList());
            }

            return children;
        },
        block: null
    }
};


/***/ }),

/***/ 62373:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
    'font-face': __nccwpck_require__(36469),
    'import': __nccwpck_require__(47672),
    'media': __nccwpck_require__(75317),
    'page': __nccwpck_require__(43092),
    'supports': __nccwpck_require__(82841)
};


/***/ }),

/***/ 75317:
/***/ ((module) => {

module.exports = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.MediaQueryList()
            );
        },
        block: function() {
            return this.Block(false);
        }
    }
};


/***/ }),

/***/ 43092:
/***/ ((module) => {

module.exports = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block: function() {
            return this.Block(true);
        }
    }
};


/***/ }),

/***/ 82841:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

function consumeRaw() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
    );
}

function parentheses() {
    this.scanner.skipSC();

    if (this.scanner.tokenType === IDENT &&
        this.lookupNonWSType(1) === COLON) {
        return this.createSingleNodeList(
            this.Declaration()
        );
    }

    return readSequence.call(this);
}

function readSequence() {
    var children = this.createList();
    var space = null;
    var child;

    this.scanner.skipSC();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case WHITESPACE:
                space = this.WhiteSpace();
                continue;

            case COMMENT:
                this.scanner.next();
                continue;

            case FUNCTION:
                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
                break;

            case IDENT:
                child = this.Identifier();
                break;

            case LEFTPARENTHESIS:
                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;

            default:
                break scan;
        }

        if (space !== null) {
            children.push(space);
            space = null;
        }

        children.push(child);
    }

    return children;
}

module.exports = {
    parse: {
        prelude: function() {
            var children = readSequence.call(this);

            if (this.getFirstListNode(children) === null) {
                this.error('Condition is expected');
            }

            return children;
        },
        block: function() {
            return this.Block(false);
        }
    }
};


/***/ }),

/***/ 30447:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var data = __nccwpck_require__(67355);

module.exports = {
    generic: true,
    types: data.types,
    atrules: data.atrules,
    properties: data.properties,
    node: __nccwpck_require__(77057)
};


/***/ }),

/***/ 44185:
/***/ ((module) => {

const hasOwnProperty = Object.prototype.hasOwnProperty;
const shape = {
    generic: true,
    types: appendOrAssign,
    atrules: {
        prelude: appendOrAssignOrNull,
        descriptors: appendOrAssignOrNull
    },
    properties: appendOrAssign,
    parseContext: assign,
    scope: deepAssign,
    atrule: ['parse'],
    pseudo: ['parse'],
    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
};

function isObject(value) {
    return value && value.constructor === Object;
}

function copy(value) {
    return isObject(value)
        ? Object.assign({}, value)
        : value;
}

function assign(dest, src) {
    return Object.assign(dest, src);
}

function deepAssign(dest, src) {
    for (const key in src) {
        if (hasOwnProperty.call(src, key)) {
            if (isObject(dest[key])) {
                deepAssign(dest[key], copy(src[key]));
            } else {
                dest[key] = copy(src[key]);
            }
        }
    }

    return dest;
}

function append(a, b) {
    if (typeof b === 'string' && /^\s*\|/.test(b)) {
        return typeof a === 'string'
            ? a + b
            : b.replace(/^\s*\|\s*/, '');
    }

    return b || null;
}

function appendOrAssign(a, b) {
    if (typeof b === 'string') {
        return append(a, b);
    }

    const result = Object.assign({}, a);
    for (let key in b) {
        if (hasOwnProperty.call(b, key)) {
            result[key] = append(hasOwnProperty.call(a, key) ? a[key] : undefined, b[key]);
        }
    }

    return result;
}

function appendOrAssignOrNull(a, b) {
    const result = appendOrAssign(a, b);

    return !isObject(result) || Object.keys(result).length
        ? result
        : null;
}

function mix(dest, src, shape) {
    for (const key in shape) {
        if (hasOwnProperty.call(shape, key) === false) {
            continue;
        }

        if (shape[key] === true) {
            if (key in src) {
                if (hasOwnProperty.call(src, key)) {
                    dest[key] = copy(src[key]);
                }
            }
        } else if (shape[key]) {
            if (typeof shape[key] === 'function') {
                const fn = shape[key];
                dest[key] = fn({}, dest[key]);
                dest[key] = fn(dest[key] || {}, src[key]);
            } else if (isObject(shape[key])) {
                const result = {};

                for (let name in dest[key]) {
                    result[name] = mix({}, dest[key][name], shape[key]);
                }

                for (let name in src[key]) {
                    result[name] = mix(result[name] || {}, src[key][name], shape[key]);
                }

                dest[key] = result;
            } else if (Array.isArray(shape[key])) {
                const res = {};
                const innerShape = shape[key].reduce(function(s, k) {
                    s[k] = true;
                    return s;
                }, {});

                for (const [name, value] of Object.entries(dest[key] || {})) {
                    res[name] = {};
                    if (value) {
                        mix(res[name], value, innerShape);
                    }
                }

                for (const name in src[key]) {
                    if (hasOwnProperty.call(src[key], name)) {
                        if (!res[name]) {
                            res[name] = {};
                        }

                        if (src[key] && src[key][name]) {
                            mix(res[name], src[key][name], innerShape);
                        }
                    }
                }

                dest[key] = res;
            }
        }
    }
    return dest;
}

module.exports = (dest, src) => mix(dest, src, shape);


/***/ }),

/***/ 60918:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
    parseContext: {
        default: 'StyleSheet',
        stylesheet: 'StyleSheet',
        atrule: 'Atrule',
        atrulePrelude: function(options) {
            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: 'MediaQueryList',
        mediaQuery: 'MediaQuery',
        rule: 'Rule',
        selectorList: 'SelectorList',
        selector: 'Selector',
        block: function() {
            return this.Block(true);
        },
        declarationList: 'DeclarationList',
        declaration: 'Declaration',
        value: 'Value'
    },
    scope: __nccwpck_require__(90326),
    atrule: __nccwpck_require__(62373),
    pseudo: __nccwpck_require__(84575),
    node: __nccwpck_require__(77057)
};


/***/ }),

/***/ 24524:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
    node: __nccwpck_require__(77057)
};


/***/ }),

/***/ 73189:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var List = __nccwpck_require__(11282);
var SyntaxError = __nccwpck_require__(83981);
var TokenStream = __nccwpck_require__(89490);
var Lexer = __nccwpck_require__(77906);
var definitionSyntax = __nccwpck_require__(32267);
var tokenize = __nccwpck_require__(69549);
var createParser = __nccwpck_require__(25569);
var createGenerator = __nccwpck_require__(37703);
var createConvertor = __nccwpck_require__(19719);
var createWalker = __nccwpck_require__(61090);
var clone = __nccwpck_require__(52404);
var names = __nccwpck_require__(87602);
var mix = __nccwpck_require__(44185);

function createSyntax(config) {
    var parse = createParser(config);
    var walk = createWalker(config);
    var generate = createGenerator(config);
    var convert = createConvertor(walk);

    var syntax = {
        List: List,
        SyntaxError: SyntaxError,
        TokenStream: TokenStream,
        Lexer: Lexer,

        vendorPrefix: names.vendorPrefix,
        keyword: names.keyword,
        property: names.property,
        isCustomProperty: names.isCustomProperty,

        definitionSyntax: definitionSyntax,
        lexer: null,
        createLexer: function(config) {
            return new Lexer(config, syntax, syntax.lexer.structure);
        },

        tokenize: tokenize,
        parse: parse,
        walk: walk,
        generate: generate,

        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,

        clone: clone,
        fromPlainObject: convert.fromPlainObject,
        toPlainObject: convert.toPlainObject,

        createSyntax: function(config) {
            return createSyntax(mix({}, config));
        },
        fork: function(extension) {
            var base = mix({}, config); // copy of config
            return createSyntax(
                typeof extension === 'function'
                    ? extension(base, Object.assign)
                    : mix(base, extension)
            );
        }
    };

    syntax.lexer = new Lexer({
        generic: true,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
    }, syntax);

    return syntax;
};

exports.create = function(config) {
    return createSyntax(mix({}, config));
};


/***/ }),

/***/ 58575:
/***/ ((module) => {

// legacy IE function
// expression( <any-value> )
module.exports = function() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
    );
};


/***/ }),

/***/ 75724:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;
var rawMode = __nccwpck_require__(81287).mode;

var COMMA = TYPE.Comma;
var WHITESPACE = TYPE.WhiteSpace;

// var( <ident> , <value>? )
module.exports = function() {
    var children = this.createList();

    this.scanner.skipSC();

    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
    children.push(this.Identifier());

    this.scanner.skipSC();

    if (this.scanner.tokenType === COMMA) {
        children.push(this.Operator());

        const startIndex = this.scanner.tokenIndex;
        const value = this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false);

        if (value.type === 'Value' && value.children.isEmpty()) {
            for (let offset = startIndex - this.scanner.tokenIndex; offset <= 0; offset++) {
                if (this.scanner.lookupType(offset) === WHITESPACE) {
                    value.children.appendData({
                        type: 'WhiteSpace',
                        loc: null,
                        value: ' '
                    });
                    break;
                }
            }
        }

        children.push(value);
    }

    return children;
};


/***/ }),

/***/ 40469:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

function merge() {
    var dest = {};

    for (var i = 0; i < arguments.length; i++) {
        var src = arguments[i];
        for (var key in src) {
            dest[key] = src[key];
        }
    }

    return dest;
}

module.exports = __nccwpck_require__(73189).create(
    merge(
        __nccwpck_require__(30447),
        __nccwpck_require__(60918),
        __nccwpck_require__(24524)
    )
);
module.exports.version = __nccwpck_require__(74441).version;


/***/ }),

/***/ 28892:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var cmpChar = __nccwpck_require__(69549).cmpChar;
var isDigit = __nccwpck_require__(69549).isDigit;
var TYPE = __nccwpck_require__(69549).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function checkInteger(offset, disallowSign) {
    var pos = this.scanner.tokenStart + offset;
    var code = this.scanner.source.charCodeAt(pos);

    if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
            this.error('Number sign is not allowed');
        }
        pos++;
    }

    for (; pos < this.scanner.tokenEnd; pos++) {
        if (!isDigit(this.scanner.source.charCodeAt(pos))) {
            this.error('Integer is expected', pos);
        }
    }
}

function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
}

function expectCharCode(offset, code) {
    if (!cmpChar(this.scanner.source, this.scanner.tokenStart + offset, code)) {
        var msg = '';

        switch (code) {
            case N:
                msg = 'N is expected';
                break;
            case HYPHENMINUS:
                msg = 'HyphenMinus is expected';
                break;
        }

        this.error(msg, this.scanner.tokenStart + offset);
    }
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB() {
    var offset = 0;
    var sign = 0;
    var type = this.scanner.tokenType;

    while (type === WHITESPACE || type === COMMENT) {
        type = this.scanner.lookupType(++offset);
    }

    if (type !== NUMBER) {
        if (this.scanner.isDelim(PLUSSIGN, offset) ||
            this.scanner.isDelim(HYPHENMINUS, offset)) {
            sign = this.scanner.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;

            do {
                type = this.scanner.lookupType(++offset);
            } while (type === WHITESPACE || type === COMMENT);

            if (type !== NUMBER) {
                this.scanner.skip(offset);
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
        } else {
            return null;
        }
    }

    if (offset > 0) {
        this.scanner.skip(offset);
    }

    if (sign === 0) {
        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
        if (type !== PLUSSIGN && type !== HYPHENMINUS) {
            this.error('Number sign is expected');
        }
    }

    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS ? '-' + this.consume(NUMBER) : this.consume(NUMBER);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
module.exports = {
    name: 'AnPlusB',
    structure: {
        a: [String, null],
        b: [String, null]
    },
    parse: function() {
        /* eslint-disable brace-style*/
        var start = this.scanner.tokenStart;
        var a = null;
        var b = null;

        // <integer>
        if (this.scanner.tokenType === NUMBER) {
            checkTokenIsInteger.call(this, ALLOW_SIGN);
            b = this.consume(NUMBER);
        }

        // -n
        // -n <signed-integer>
        // -n ['+' | '-'] <signless-integer>
        // -n- <signless-integer>
        // <dashndashdigit-ident>
        else if (this.scanner.tokenType === IDENT && cmpChar(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS)) {
            a = '-1';

            expectCharCode.call(this, 1, N);

            switch (this.scanner.getTokenLength()) {
                // -n
                // -n <signed-integer>
                // -n ['+' | '-'] <signless-integer>
                case 2:
                    this.scanner.next();
                    b = consumeB.call(this);
                    break;

                // -n- <signless-integer>
                case 3:
                    expectCharCode.call(this, 2, HYPHENMINUS);

                    this.scanner.next();
                    this.scanner.skipSC();

                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

                    b = '-' + this.consume(NUMBER);
                    break;

                // <dashndashdigit-ident>
                default:
                    expectCharCode.call(this, 2, HYPHENMINUS);
                    checkInteger.call(this, 3, DISALLOW_SIGN);
                    this.scanner.next();

                    b = this.scanner.substrToCursor(start + 2);
            }
        }

        // '+'? n
        // '+'? n <signed-integer>
        // '+'? n ['+' | '-'] <signless-integer>
        // '+'? n- <signless-integer>
        // '+'? <ndashdigit-ident>
        else if (this.scanner.tokenType === IDENT || (this.scanner.isDelim(PLUSSIGN) && this.scanner.lookupType(1) === IDENT)) {
            var sign = 0;
            a = '1';

            // just ignore a plus
            if (this.scanner.isDelim(PLUSSIGN)) {
                sign = 1;
                this.scanner.next();
            }

            expectCharCode.call(this, 0, N);

            switch (this.scanner.getTokenLength()) {
                // '+'? n
                // '+'? n <signed-integer>
                // '+'? n ['+' | '-'] <signless-integer>
                case 1:
                    this.scanner.next();
                    b = consumeB.call(this);
                    break;

                // '+'? n- <signless-integer>
                case 2:
                    expectCharCode.call(this, 1, HYPHENMINUS);

                    this.scanner.next();
                    this.scanner.skipSC();

                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

                    b = '-' + this.consume(NUMBER);
                    break;

                // '+'? <ndashdigit-ident>
                default:
                    expectCharCode.call(this, 1, HYPHENMINUS);
                    checkInteger.call(this, 2, DISALLOW_SIGN);
                    this.scanner.next();

                    b = this.scanner.substrToCursor(start + sign + 1);
            }
        }

        // <ndashdigit-dimension>
        // <ndash-dimension> <signless-integer>
        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        else if (this.scanner.tokenType === DIMENSION) {
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            var sign = code === PLUSSIGN || code === HYPHENMINUS;

            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
                if (!isDigit(this.scanner.source.charCodeAt(i))) {
                    break;
                }
            }

            if (i === this.scanner.tokenStart + sign) {
                this.error('Integer is expected', this.scanner.tokenStart + sign);
            }

            expectCharCode.call(this, i - this.scanner.tokenStart, N);
            a = this.scanner.source.substring(start, i);

            // <n-dimension>
            // <n-dimension> <signed-integer>
            // <n-dimension> ['+' | '-'] <signless-integer>
            if (i + 1 === this.scanner.tokenEnd) {
                this.scanner.next();
                b = consumeB.call(this);
            } else {
                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS);

                // <ndash-dimension> <signless-integer>
                if (i + 2 === this.scanner.tokenEnd) {
                    this.scanner.next();
                    this.scanner.skipSC();
                    checkTokenIsInteger.call(this, DISALLOW_SIGN);
                    b = '-' + this.consume(NUMBER);
                }
                // <ndashdigit-dimension>
                else {
                    checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);
                    this.scanner.next();
                    b = this.scanner.substrToCursor(i + 1);
                }
            }
        } else {
            this.error();
        }

        if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
            a = a.substr(1);
        }

        if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
            b = b.substr(1);
        }

        return {
            type: 'AnPlusB',
            loc: this.getLocation(start, this.scanner.tokenStart),
            a: a,
            b: b
        };
    },
    generate: function(node) {
        var a = node.a !== null && node.a !== undefined;
        var b = node.b !== null && node.b !== undefined;

        if (a) {
            this.chunk(
                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
            );

            if (b) {
                b = String(node.b);
                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
                    this.chunk(b.charAt(0));
                    this.chunk(b.substr(1));
                } else {
                    this.chunk('+');
                    this.chunk(b);
                }
            }
        } else {
            this.chunk(String(node.b));
        }
    }
};


/***/ }),

/***/ 53778:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;
var rawMode = __nccwpck_require__(81287).mode;

var ATKEYWORD = TYPE.AtKeyword;
var SEMICOLON = TYPE.Semicolon;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
}

function isDeclarationBlockAtrule() {
    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
        if (type === RIGHTCURLYBRACKET) {
            return true;
        }

        if (type === LEFTCURLYBRACKET ||
            type === ATKEYWORD) {
            return false;
        }
    }

    return false;
}

module.exports = {
    name: 'Atrule',
    structure: {
        name: String,
        prelude: ['AtrulePrelude', 'Raw', null],
        block: ['Block', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var nameLowerCase;
        var prelude = null;
        var block = null;

        this.eat(ATKEYWORD);

        name = this.scanner.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.scanner.skipSC();

        // parse prelude
        if (this.scanner.eof === false &&
            this.scanner.tokenType !== LEFTCURLYBRACKET &&
            this.scanner.tokenType !== SEMICOLON) {
            if (this.parseAtrulePrelude) {
                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

                // turn empty AtrulePrelude into null
                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
                    prelude = null;
                }
            } else {
                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
            }

            this.scanner.skipSC();
        }

        switch (this.scanner.tokenType) {
            case SEMICOLON:
                this.scanner.next();
                break;

            case LEFTCURLYBRACKET:
                if (this.atrule.hasOwnProperty(nameLowerCase) &&
                    typeof this.atrule[nameLowerCase].block === 'function') {
                    block = this.atrule[nameLowerCase].block.call(this);
                } else {
                    // TODO: should consume block content as Raw?
                    block = this.Block(isDeclarationBlockAtrule.call(this));
                }

                break;
        }

        return {
            type: 'Atrule',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.chunk('@');
        this.chunk(node.name);

        if (node.prelude !== null) {
            this.chunk(' ');
            this.node(node.prelude);
        }

        if (node.block) {
            this.node(node.block);
        } else {
            this.chunk(';');
        }
    },
    walkContext: 'atrule'
};


/***/ }),

/***/ 34161:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var SEMICOLON = TYPE.Semicolon;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

module.exports = {
    name: 'AtrulePrelude',
    structure: {
        children: [[]]
    },
    parse: function(name) {
        var children = null;

        if (name !== null) {
            name = name.toLowerCase();
        }

        this.scanner.skipSC();

        if (this.atrule.hasOwnProperty(name) &&
            typeof this.atrule[name].prelude === 'function') {
            // custom consumer
            children = this.atrule[name].prelude.call(this);
        } else {
            // default consumer
            children = this.readSequence(this.scope.AtrulePrelude);
        }

        this.scanner.skipSC();

        if (this.scanner.eof !== true &&
            this.scanner.tokenType !== LEFTCURLYBRACKET &&
            this.scanner.tokenType !== SEMICOLON) {
            this.error('Semicolon or block is expected');
        }

        if (children === null) {
            children = this.createList();
        }

        return {
            type: 'AtrulePrelude',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'atrulePrelude'
};


/***/ }),

/***/ 53887:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var IDENT = TYPE.Ident;
var STRING = TYPE.String;
var COLON = TYPE.Colon;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
var ASTERISK = 0x002A;         // U+002A ASTERISK (*)
var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
var VERTICALLINE = 0x007C;     // U+007C VERTICAL LINE (|)
var TILDE = 0x007E;            // U+007E TILDE (~)

function getAttributeName() {
    if (this.scanner.eof) {
        this.error('Unexpected end of input');
    }

    var start = this.scanner.tokenStart;
    var expectIdent = false;
    var checkColon = true;

    if (this.scanner.isDelim(ASTERISK)) {
        expectIdent = true;
        checkColon = false;
        this.scanner.next();
    } else if (!this.scanner.isDelim(VERTICALLINE)) {
        this.eat(IDENT);
    }

    if (this.scanner.isDelim(VERTICALLINE)) {
        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
            this.scanner.next();
            this.eat(IDENT);
        } else if (expectIdent) {
            this.error('Identifier is expected', this.scanner.tokenEnd);
        }
    } else if (expectIdent) {
        this.error('Vertical line is expected');
    }

    if (checkColon && this.scanner.tokenType === COLON) {
        this.scanner.next();
        this.eat(IDENT);
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
    };
}

function getOperator() {
    var start = this.scanner.tokenStart;
    var code = this.scanner.source.charCodeAt(start);

    if (code !== EQUALSSIGN &&        // =
        code !== TILDE &&             // ~=
        code !== CIRCUMFLEXACCENT &&  // ^=
        code !== DOLLARSIGN &&        // $=
        code !== ASTERISK &&          // *=
        code !== VERTICALLINE         // |=
    ) {
        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    this.scanner.next();

    if (code !== EQUALSSIGN) {
        if (!this.scanner.isDelim(EQUALSSIGN)) {
            this.error('Equal sign is expected');
        }

        this.scanner.next();
    }

    return this.scanner.substrToCursor(start);
}

// '[' <wq-name> ']'
// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
module.exports = {
    name: 'AttributeSelector',
    structure: {
        name: 'Identifier',
        matcher: [String, null],
        value: ['String', 'Identifier', null],
        flags: [String, null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var matcher = null;
        var value = null;
        var flags = null;

        this.eat(LEFTSQUAREBRACKET);
        this.scanner.skipSC();

        name = getAttributeName.call(this);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
            // avoid case `[name i]`
            if (this.scanner.tokenType !== IDENT) {
                matcher = getOperator.call(this);

                this.scanner.skipSC();

                value = this.scanner.tokenType === STRING
                    ? this.String()
                    : this.Identifier();

                this.scanner.skipSC();
            }

            // attribute flags
            if (this.scanner.tokenType === IDENT) {
                flags = this.scanner.getTokenValue();
                this.scanner.next();

                this.scanner.skipSC();
            }
        }

        this.eat(RIGHTSQUAREBRACKET);

        return {
            type: 'AttributeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            matcher: matcher,
            value: value,
            flags: flags
        };
    },
    generate: function(node) {
        var flagsPrefix = ' ';

        this.chunk('[');
        this.node(node.name);

        if (node.matcher !== null) {
            this.chunk(node.matcher);

            if (node.value !== null) {
                this.node(node.value);

                // space between string and flags is not required
                if (node.value.type === 'String') {
                    flagsPrefix = '';
                }
            }
        }

        if (node.flags !== null) {
            this.chunk(flagsPrefix);
            this.chunk(node.flags);
        }

        this.chunk(']');
    }
};


/***/ }),

/***/ 97800:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;
var rawMode = __nccwpck_require__(81287).mode;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var SEMICOLON = TYPE.Semicolon;
var ATKEYWORD = TYPE.AtKeyword;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, null, true);
}
function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw);
}
function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, rawMode.semicolonIncluded, true);
}
function consumeDeclaration() {
    if (this.scanner.tokenType === SEMICOLON) {
        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
    }

    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.scanner.tokenType === SEMICOLON) {
        this.scanner.next();
    }

    return node;
}

module.exports = {
    name: 'Block',
    structure: {
        children: [[
            'Atrule',
            'Rule',
            'Declaration'
        ]]
    },
    parse: function(isDeclaration) {
        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

        var start = this.scanner.tokenStart;
        var children = this.createList();

        this.eat(LEFTCURLYBRACKET);

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case RIGHTCURLYBRACKET:
                    break scan;

                case WHITESPACE:
                case COMMENT:
                    this.scanner.next();
                    break;

                case ATKEYWORD:
                    children.push(this.parseWithFallback(this.Atrule, consumeRaw));
                    break;

                default:
                    children.push(consumer.call(this));
            }
        }

        if (!this.scanner.eof) {
            this.eat(RIGHTCURLYBRACKET);
        }

        return {
            type: 'Block',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('{');
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
        this.chunk('}');
    },
    walkContext: 'block'
};


/***/ }),

/***/ 85549:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;

module.exports = {
    name: 'Brackets',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.eat(LEFTSQUAREBRACKET);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTSQUAREBRACKET);
        }

        return {
            type: 'Brackets',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('[');
        this.children(node);
        this.chunk(']');
    }
};


/***/ }),

/***/ 6730:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var CDC = __nccwpck_require__(69549).TYPE.CDC;

module.exports = {
    name: 'CDC',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(CDC); // -->

        return {
            type: 'CDC',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('-->');
    }
};


/***/ }),

/***/ 41210:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var CDO = __nccwpck_require__(69549).TYPE.CDO;

module.exports = {
    name: 'CDO',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(CDO); // <!--

        return {
            type: 'CDO',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('<!--');
    }
};


/***/ }),

/***/ 19694:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var IDENT = TYPE.Ident;
var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

// '.' ident
module.exports = {
    name: 'ClassSelector',
    structure: {
        name: String
    },
    parse: function() {
        if (!this.scanner.isDelim(FULLSTOP)) {
            this.error('Full stop is expected');
        }

        this.scanner.next();

        return {
            type: 'ClassSelector',
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.consume(IDENT)
        };
    },
    generate: function(node) {
        this.chunk('.');
        this.chunk(node.name);
    }
};


/***/ }),

/***/ 29026:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var IDENT = TYPE.Ident;
var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
var TILDE = 0x007E;           // U+007E TILDE (~)

// + | > | ~ | /deep/
module.exports = {
    name: 'Combinator',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

        switch (code) {
            case GREATERTHANSIGN:
            case PLUSSIGN:
            case TILDE:
                this.scanner.next();
                break;

            case SOLIDUS:
                this.scanner.next();

                if (this.scanner.tokenType !== IDENT || this.scanner.lookupValue(0, 'deep') === false) {
                    this.error('Identifier `deep` is expected');
                }

                this.scanner.next();

                if (!this.scanner.isDelim(SOLIDUS)) {
                    this.error('Solidus is expected');
                }

                this.scanner.next();
                break;

            default:
                this.error('Combinator is expected');
        }

        return {
            type: 'Combinator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};


/***/ }),

/***/ 46018:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var COMMENT = TYPE.Comment;
var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)

// '/*' .* '*/'
module.exports = {
    name: 'Comment',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var end = this.scanner.tokenEnd;

        this.eat(COMMENT);

        if ((end - start + 2) >= 2 &&
            this.scanner.source.charCodeAt(end - 2) === ASTERISK &&
            this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
            end -= 2;
        }

        return {
            type: 'Comment',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start + 2, end)
        };
    },
    generate: function(node) {
        this.chunk('/*');
        this.chunk(node.value);
        this.chunk('*/');
    }
};


/***/ }),

/***/ 78951:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isCustomProperty = __nccwpck_require__(87602).isCustomProperty;
var TYPE = __nccwpck_require__(69549).TYPE;
var rawMode = __nccwpck_require__(81287).mode;

var IDENT = TYPE.Ident;
var HASH = TYPE.Hash;
var COLON = TYPE.Colon;
var SEMICOLON = TYPE.Semicolon;
var DELIM = TYPE.Delim;
var WHITESPACE = TYPE.WhiteSpace;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)
var NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
var DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)
var AMPERSAND = 0x0026;       // U+0026 ANPERSAND (&)
var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)

function consumeValueRaw(startToken) {
    return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, true);
}

function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, false);
}

function consumeValue() {
    var startValueToken = this.scanner.tokenIndex;
    var value = this.Value();

    if (value.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== SEMICOLON &&
        this.scanner.isDelim(EXCLAMATIONMARK) === false &&
        this.scanner.isBalanceEdge(startValueToken) === false) {
        this.error();
    }

    return value;
}

module.exports = {
    name: 'Declaration',
    structure: {
        important: [Boolean, String],
        property: String,
        value: ['Value', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var startToken = this.scanner.tokenIndex;
        var property = readProperty.call(this);
        var customProperty = isCustomProperty(property);
        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
        var important = false;
        var value;

        this.scanner.skipSC();
        this.eat(COLON);

        const valueStart = this.scanner.tokenIndex;

        if (!customProperty) {
            this.scanner.skipSC();
        }

        if (parseValue) {
            value = this.parseWithFallback(consumeValue, consumeRaw);
        } else {
            value = consumeRaw.call(this, this.scanner.tokenIndex);
        }

        if (customProperty && value.type === 'Value' && value.children.isEmpty()) {
            for (let offset = valueStart - this.scanner.tokenIndex; offset <= 0; offset++) {
                if (this.scanner.lookupType(offset) === WHITESPACE) {
                    value.children.appendData({
                        type: 'WhiteSpace',
                        loc: null,
                        value: ' '
                    });
                    break;
                }
            }
        }

        if (this.scanner.isDelim(EXCLAMATIONMARK)) {
            important = getImportant.call(this);
            this.scanner.skipSC();
        }

        // Do not include semicolon to range per spec
        // https://drafts.csswg.org/css-syntax/#declaration-diagram

        if (this.scanner.eof === false &&
            this.scanner.tokenType !== SEMICOLON &&
            this.scanner.isBalanceEdge(startToken) === false) {
            this.error();
        }

        return {
            type: 'Declaration',
            loc: this.getLocation(start, this.scanner.tokenStart),
            important: important,
            property: property,
            value: value
        };
    },
    generate: function(node) {
        this.chunk(node.property);
        this.chunk(':');
        this.node(node.value);

        if (node.important) {
            this.chunk(node.important === true ? '!important' : '!' + node.important);
        }
    },
    walkContext: 'declaration'
};

function readProperty() {
    var start = this.scanner.tokenStart;
    var prefix = 0;

    // hacks
    if (this.scanner.tokenType === DELIM) {
        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
            case ASTERISK:
            case DOLLARSIGN:
            case PLUSSIGN:
            case NUMBERSIGN:
            case AMPERSAND:
                this.scanner.next();
                break;

            // TODO: not sure we should support this hack
            case SOLIDUS:
                this.scanner.next();
                if (this.scanner.isDelim(SOLIDUS)) {
                    this.scanner.next();
                }
                break;
        }
    }

    if (prefix) {
        this.scanner.skip(prefix);
    }

    if (this.scanner.tokenType === HASH) {
        this.eat(HASH);
    } else {
        this.eat(IDENT);
    }

    return this.scanner.substrToCursor(start);
}

// ! ws* important
function getImportant() {
    this.eat(DELIM);
    this.scanner.skipSC();

    var important = this.consume(IDENT);

    // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support
    return important === 'important' ? true : important;
}


/***/ }),

/***/ 12503:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;
var rawMode = __nccwpck_require__(81287).mode;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var SEMICOLON = TYPE.Semicolon;

function consumeRaw(startToken) {
    return this.Raw(startToken, rawMode.semicolonIncluded, true);
}

module.exports = {
    name: 'DeclarationList',
    structure: {
        children: [[
            'Declaration'
        ]]
    },
    parse: function() {
        var children = this.createList();

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE:
                case COMMENT:
                case SEMICOLON:
                    this.scanner.next();
                    break;

                default:
                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));
            }
        }

        return {
            type: 'DeclarationList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
    }
};


/***/ }),

/***/ 22802:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var consumeNumber = __nccwpck_require__(29292).consumeNumber;
var TYPE = __nccwpck_require__(69549).TYPE;

var DIMENSION = TYPE.Dimension;

module.exports = {
    name: 'Dimension',
    structure: {
        value: String,
        unit: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber(this.scanner.source, start);

        this.eat(DIMENSION);

        return {
            type: 'Dimension',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd),
            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk(node.unit);
    }
};


/***/ }),

/***/ 16798:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// <function-token> <sequence> )
module.exports = {
    name: 'Function',
    structure: {
        name: String,
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var name = this.consumeFunctionName();
        var nameLowerCase = name.toLowerCase();
        var children;

        children = recognizer.hasOwnProperty(nameLowerCase)
            ? recognizer[nameLowerCase].call(this, recognizer)
            : readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS);
        }

        return {
            type: 'Function',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(node.name);
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    },
    walkContext: 'function'
};


/***/ }),

/***/ 19580:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var HASH = TYPE.Hash;

// '#' ident
module.exports = {
    name: 'Hash',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.eat(HASH);

        return {
            type: 'Hash',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start + 1)
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.value);
    }
};


/***/ }),

/***/ 91895:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var HASH = TYPE.Hash;

// <hash-token>
module.exports = {
    name: 'IdSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        // TODO: check value is an ident
        this.eat(HASH);

        return {
            type: 'IdSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start + 1)
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.name);
    }
};


/***/ }),

/***/ 27783:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var IDENT = TYPE.Ident;

module.exports = {
    name: 'Identifier',
    structure: {
        name: String
    },
    parse: function() {
        return {
            type: 'Identifier',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            name: this.consume(IDENT)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};


/***/ }),

/***/ 17602:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var COLON = TYPE.Colon;
var DELIM = TYPE.Delim;

module.exports = {
    name: 'MediaFeature',
    structure: {
        name: String,
        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var value = null;

        this.eat(LEFTPARENTHESIS);
        this.scanner.skipSC();

        name = this.consume(IDENT);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
            this.eat(COLON);
            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case NUMBER:
                    if (this.lookupNonWSType(1) === DELIM) {
                        value = this.Ratio();
                    } else {
                        value = this.Number();
                    }

                    break;

                case DIMENSION:
                    value = this.Dimension();
                    break;

                case IDENT:
                    value = this.Identifier();

                    break;

                default:
                    this.error('Number, dimension, ratio or identifier is expected');
            }

            this.scanner.skipSC();
        }

        this.eat(RIGHTPARENTHESIS);

        return {
            type: 'MediaFeature',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            value: value
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.chunk(node.name);
        if (node.value !== null) {
            this.chunk(':');
            this.node(node.value);
        }
        this.chunk(')');
    }
};


/***/ }),

/***/ 12399:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

module.exports = {
    name: 'MediaQuery',
    structure: {
        children: [[
            'Identifier',
            'MediaFeature',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        this.scanner.skipSC();

        var children = this.createList();
        var child = null;
        var space = null;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case COMMENT:
                    this.scanner.next();
                    continue;

                case WHITESPACE:
                    space = this.WhiteSpace();
                    continue;

                case IDENT:
                    child = this.Identifier();
                    break;

                case LEFTPARENTHESIS:
                    child = this.MediaFeature();
                    break;

                default:
                    break scan;
            }

            if (space !== null) {
                children.push(space);
                space = null;
            }

            children.push(child);
        }

        if (child === null) {
            this.error('Identifier or parenthesis is expected');
        }

        return {
            type: 'MediaQuery',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};


/***/ }),

/***/ 98206:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var COMMA = __nccwpck_require__(69549).TYPE.Comma;

module.exports = {
    name: 'MediaQueryList',
    structure: {
        children: [[
            'MediaQuery'
        ]]
    },
    parse: function(relative) {
        var children = this.createList();

        this.scanner.skipSC();

        while (!this.scanner.eof) {
            children.push(this.MediaQuery(relative));

            if (this.scanner.tokenType !== COMMA) {
                break;
            }

            this.scanner.next();
        }

        return {
            type: 'MediaQueryList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    }
};


/***/ }),

/***/ 36949:
/***/ ((module) => {

module.exports = {
    name: 'Nth',
    structure: {
        nth: ['AnPlusB', 'Identifier'],
        selector: ['SelectorList', null]
    },
    parse: function(allowOfClause) {
        this.scanner.skipSC();

        var start = this.scanner.tokenStart;
        var end = start;
        var selector = null;
        var query;

        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
            query = this.Identifier();
        } else {
            query = this.AnPlusB();
        }

        this.scanner.skipSC();

        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
            this.scanner.next();

            selector = this.SelectorList();

            if (this.needPositions) {
                end = this.getLastListNode(selector.children).loc.end.offset;
            }
        } else {
            if (this.needPositions) {
                end = query.loc.end.offset;
            }
        }

        return {
            type: 'Nth',
            loc: this.getLocation(start, end),
            nth: query,
            selector: selector
        };
    },
    generate: function(node) {
        this.node(node.nth);
        if (node.selector !== null) {
            this.chunk(' of ');
            this.node(node.selector);
        }
    }
};


/***/ }),

/***/ 32510:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var NUMBER = __nccwpck_require__(69549).TYPE.Number;

module.exports = {
    name: 'Number',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'Number',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(NUMBER)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),

/***/ 37098:
/***/ ((module) => {

// '/' | '*' | ',' | ':' | '+' | '-'
module.exports = {
    name: 'Operator',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next();

        return {
            type: 'Operator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),

/***/ 17147:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

module.exports = {
    name: 'Parentheses',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.eat(LEFTPARENTHESIS);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS);
        }

        return {
            type: 'Parentheses',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    }
};


/***/ }),

/***/ 10862:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var consumeNumber = __nccwpck_require__(29292).consumeNumber;
var TYPE = __nccwpck_require__(69549).TYPE;

var PERCENTAGE = TYPE.Percentage;

module.exports = {
    name: 'Percentage',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber(this.scanner.source, start);

        this.eat(PERCENTAGE);

        return {
            type: 'Percentage',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk('%');
    }
};


/***/ }),

/***/ 31440:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// : [ <ident> | <function-token> <any-value>? ) ]
module.exports = {
    name: 'PseudoClassSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.eat(COLON);

        if (this.scanner.tokenType === FUNCTION) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.tokenIndex, null, false)
                );
            }

            this.eat(RIGHTPARENTHESIS);
        } else {
            name = this.consume(IDENT);
        }

        return {
            type: 'PseudoClassSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(':');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};


/***/ }),

/***/ 91150:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// :: [ <ident> | <function-token> <any-value>? ) ]
module.exports = {
    name: 'PseudoElementSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.eat(COLON);
        this.eat(COLON);

        if (this.scanner.tokenType === FUNCTION) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.tokenIndex, null, false)
                );
            }

            this.eat(RIGHTPARENTHESIS);
        } else {
            name = this.consume(IDENT);
        }

        return {
            type: 'PseudoElementSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk('::');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};


/***/ }),

/***/ 56997:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isDigit = __nccwpck_require__(69549).isDigit;
var TYPE = __nccwpck_require__(69549).TYPE;

var NUMBER = TYPE.Number;
var DELIM = TYPE.Delim;
var SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)
var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

// Terms of <ratio> should be a positive numbers (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without an exponent part.
// Additional checking may be applied on lexer validation.
function consumeNumber() {
    this.scanner.skipWS();

    var value = this.consume(NUMBER);

    for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i);
        if (!isDigit(code) && code !== FULLSTOP) {
            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
        }
    }

    if (Number(value) === 0) {
        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
    }

    return value;
}

// <positive-integer> S* '/' S* <positive-integer>
module.exports = {
    name: 'Ratio',
    structure: {
        left: String,
        right: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var left = consumeNumber.call(this);
        var right;

        this.scanner.skipWS();

        if (!this.scanner.isDelim(SOLIDUS)) {
            this.error('Solidus is expected');
        }
        this.eat(DELIM);
        right = consumeNumber.call(this);

        return {
            type: 'Ratio',
            loc: this.getLocation(start, this.scanner.tokenStart),
            left: left,
            right: right
        };
    },
    generate: function(node) {
        this.chunk(node.left);
        this.chunk('/');
        this.chunk(node.right);
    }
};


/***/ }),

/***/ 81287:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var tokenizer = __nccwpck_require__(69549);
var TYPE = tokenizer.TYPE;

var WhiteSpace = TYPE.WhiteSpace;
var Semicolon = TYPE.Semicolon;
var LeftCurlyBracket = TYPE.LeftCurlyBracket;
var Delim = TYPE.Delim;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function getOffsetExcludeWS() {
    if (this.scanner.tokenIndex > 0) {
        if (this.scanner.lookupType(-1) === WhiteSpace) {
            return this.scanner.tokenIndex > 1
                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
                : this.scanner.firstCharOffset;
        }
    }

    return this.scanner.tokenStart;
}

// 0, 0, false
function balanceEnd() {
    return 0;
}

// LEFTCURLYBRACKET, 0, false
function leftCurlyBracket(tokenType) {
    return tokenType === LeftCurlyBracket ? 1 : 0;
}

// LEFTCURLYBRACKET, SEMICOLON, false
function leftCurlyBracketOrSemicolon(tokenType) {
    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
}

// EXCLAMATIONMARK, SEMICOLON, false
function exclamationMarkOrSemicolon(tokenType, source, offset) {
    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {
        return 1;
    }

    return tokenType === Semicolon ? 1 : 0;
}

// 0, SEMICOLON, true
function semicolonIncluded(tokenType) {
    return tokenType === Semicolon ? 2 : 0;
}

module.exports = {
    name: 'Raw',
    structure: {
        value: String
    },
    parse: function(startToken, mode, excludeWhiteSpace) {
        var startOffset = this.scanner.getTokenStart(startToken);
        var endOffset;

        this.scanner.skip(
            this.scanner.getRawLength(startToken, mode || balanceEnd)
        );

        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
            endOffset = getOffsetExcludeWS.call(this);
        } else {
            endOffset = this.scanner.tokenStart;
        }

        return {
            type: 'Raw',
            loc: this.getLocation(startOffset, endOffset),
            value: this.scanner.source.substring(startOffset, endOffset)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    },

    mode: {
        default: balanceEnd,
        leftCurlyBracket: leftCurlyBracket,
        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
        semicolonIncluded: semicolonIncluded
    }
};


/***/ }),

/***/ 46902:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;
var rawMode = __nccwpck_require__(81287).mode;

var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, rawMode.leftCurlyBracket, true);
}

function consumePrelude() {
    var prelude = this.SelectorList();

    if (prelude.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== LEFTCURLYBRACKET) {
        this.error();
    }

    return prelude;
}

module.exports = {
    name: 'Rule',
    structure: {
        prelude: ['SelectorList', 'Raw'],
        block: ['Block']
    },
    parse: function() {
        var startToken = this.scanner.tokenIndex;
        var startOffset = this.scanner.tokenStart;
        var prelude;
        var block;

        if (this.parseRulePrelude) {
            prelude = this.parseWithFallback(consumePrelude, consumeRaw);
        } else {
            prelude = consumeRaw.call(this, startToken);
        }

        block = this.Block(true);

        return {
            type: 'Rule',
            loc: this.getLocation(startOffset, this.scanner.tokenStart),
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.node(node.prelude);
        this.node(node.block);
    },
    walkContext: 'rule'
};


/***/ }),

/***/ 27356:
/***/ ((module) => {

module.exports = {
    name: 'Selector',
    structure: {
        children: [[
            'TypeSelector',
            'IdSelector',
            'ClassSelector',
            'AttributeSelector',
            'PseudoClassSelector',
            'PseudoElementSelector',
            'Combinator',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        var children = this.readSequence(this.scope.Selector);

        // nothing were consumed
        if (this.getFirstListNode(children) === null) {
            this.error('Selector is expected');
        }

        return {
            type: 'Selector',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};


/***/ }),

/***/ 53563:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var COMMA = TYPE.Comma;

module.exports = {
    name: 'SelectorList',
    structure: {
        children: [[
            'Selector',
            'Raw'
        ]]
    },
    parse: function() {
        var children = this.createList();

        while (!this.scanner.eof) {
            children.push(this.Selector());

            if (this.scanner.tokenType === COMMA) {
                this.scanner.next();
                continue;
            }

            break;
        }

        return {
            type: 'SelectorList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    },
    walkContext: 'selector'
};


/***/ }),

/***/ 72605:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var STRING = __nccwpck_require__(69549).TYPE.String;

module.exports = {
    name: 'String',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'String',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(STRING)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),

/***/ 9383:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var ATKEYWORD = TYPE.AtKeyword;
var CDO = TYPE.CDO;
var CDC = TYPE.CDC;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function consumeRaw(startToken) {
    return this.Raw(startToken, null, false);
}

module.exports = {
    name: 'StyleSheet',
    structure: {
        children: [[
            'Comment',
            'CDO',
            'CDC',
            'Atrule',
            'Rule',
            'Raw'
        ]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.createList();
        var child;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE:
                    this.scanner.next();
                    continue;

                case COMMENT:
                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
                        this.scanner.next();
                        continue;
                    }

                    child = this.Comment();
                    break;

                case CDO: // <!--
                    child = this.CDO();
                    break;

                case CDC: // -->
                    child = this.CDC();
                    break;

                // CSS Syntax Module Level 3
                // 2.2 Error handling
                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
                case ATKEYWORD:
                    child = this.parseWithFallback(this.Atrule, consumeRaw);
                    break;

                // Anything else starts a qualified rule ...
                default:
                    child = this.parseWithFallback(this.Rule, consumeRaw);
            }

            children.push(child);
        }

        return {
            type: 'StyleSheet',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'stylesheet'
};


/***/ }),

/***/ 88050:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var IDENT = TYPE.Ident;
var ASTERISK = 0x002A;     // U+002A ASTERISK (*)
var VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)

function eatIdentifierOrAsterisk() {
    if (this.scanner.tokenType !== IDENT &&
        this.scanner.isDelim(ASTERISK) === false) {
        this.error('Identifier or asterisk is expected');
    }

    this.scanner.next();
}

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
module.exports = {
    name: 'TypeSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        if (this.scanner.isDelim(VERTICALLINE)) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
        } else {
            eatIdentifierOrAsterisk.call(this);

            if (this.scanner.isDelim(VERTICALLINE)) {
                this.scanner.next();
                eatIdentifierOrAsterisk.call(this);
            }
        }

        return {
            type: 'TypeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};


/***/ }),

/***/ 23086:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isHexDigit = __nccwpck_require__(69549).isHexDigit;
var cmpChar = __nccwpck_require__(69549).cmpChar;
var TYPE = __nccwpck_require__(69549).TYPE;
var NAME = __nccwpck_require__(69549).NAME;

var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)
var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function eatHexSequence(offset, allowDash) {
    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
        var code = this.scanner.source.charCodeAt(pos);

        if (code === HYPHENMINUS && allowDash && len !== 0) {
            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
                this.error();
            }

            return -1;
        }

        if (!isHexDigit(code)) {
            this.error(
                allowDash && len !== 0
                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
                pos
            );
        }

        if (++len > 6) {
            this.error('Too many hex digits', pos);
        };
    }

    this.scanner.next();
    return len;
}

function eatQuestionMarkSequence(max) {
    var count = 0;

    while (this.scanner.isDelim(QUESTIONMARK)) {
        if (++count > max) {
            this.error('Too many question marks');
        }

        this.scanner.next();
    }
}

function startsWith(code) {
    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
        this.error(NAME[code] + ' is expected');
    }
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function scanUnicodeRange() {
    var hexLength = 0;

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (this.scanner.isDelim(PLUSSIGN)) {
        this.scanner.next();

        if (this.scanner.tokenType === IDENT) {
            hexLength = eatHexSequence.call(this, 0, true);
            if (hexLength > 0) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            return;
        }

        if (this.scanner.isDelim(QUESTIONMARK)) {
            this.scanner.next();
            eatQuestionMarkSequence.call(this, 5);
            return;
        }

        this.error('Hex digit or question mark is expected');
        return;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (this.scanner.tokenType === NUMBER) {
        startsWith.call(this, PLUSSIGN);
        hexLength = eatHexSequence.call(this, 1, true);

        if (this.scanner.isDelim(QUESTIONMARK)) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
            return;
        }

        if (this.scanner.tokenType === DIMENSION ||
            this.scanner.tokenType === NUMBER) {
            startsWith.call(this, HYPHENMINUS);
            eatHexSequence.call(this, 1, false);
            return;
        }

        return;
    }

    // u <dimension-token> '?'*
    if (this.scanner.tokenType === DIMENSION) {
        startsWith.call(this, PLUSSIGN);
        hexLength = eatHexSequence.call(this, 1, true);

        if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
        }

        return;
    }

    this.error();
}

module.exports = {
    name: 'UnicodeRange',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        // U or u
        if (!cmpChar(this.scanner.source, start, U)) {
            this.error('U is expected');
        }

        if (!cmpChar(this.scanner.source, start + 1, PLUSSIGN)) {
            this.error('Plus sign is expected');
        }

        this.scanner.next();
        scanUnicodeRange.call(this);

        return {
            type: 'UnicodeRange',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),

/***/ 37233:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isWhiteSpace = __nccwpck_require__(69549).isWhiteSpace;
var cmpStr = __nccwpck_require__(69549).cmpStr;
var TYPE = __nccwpck_require__(69549).TYPE;

var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// <url-token> | <function-token> <string> )
module.exports = {
    name: 'Url',
    structure: {
        value: ['String', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var value;

        switch (this.scanner.tokenType) {
            case URL:
                var rawStart = start + 4;
                var rawEnd = this.scanner.tokenEnd - 1;

                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {
                    rawStart++;
                }

                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {
                    rawEnd--;
                }

                value = {
                    type: 'Raw',
                    loc: this.getLocation(rawStart, rawEnd),
                    value: this.scanner.source.substring(rawStart, rawEnd)
                };

                this.eat(URL);
                break;

            case FUNCTION:
                if (!cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
                    this.error('Function name must be `url`');
                }

                this.eat(FUNCTION);
                this.scanner.skipSC();
                value = this.String();
                this.scanner.skipSC();
                this.eat(RIGHTPARENTHESIS);
                break;

            default:
                this.error('Url or Function is expected');
        }

        return {
            type: 'Url',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value
        };
    },
    generate: function(node) {
        this.chunk('url');
        this.chunk('(');
        this.node(node.value);
        this.chunk(')');
    }
};


/***/ }),

/***/ 27575:
/***/ ((module) => {

module.exports = {
    name: 'Value',
    structure: {
        children: [[]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.readSequence(this.scope.Value);

        return {
            type: 'Value',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};


/***/ }),

/***/ 96411:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var WHITESPACE = __nccwpck_require__(69549).TYPE.WhiteSpace;
var SPACE = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

module.exports = {
    name: 'WhiteSpace',
    structure: {
        value: String
    },
    parse: function() {
        this.eat(WHITESPACE);
        return SPACE;

        // return {
        //     type: 'WhiteSpace',
        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        //     value: this.consume(WHITESPACE)
        // };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),

/***/ 77057:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
    AnPlusB: __nccwpck_require__(28892),
    Atrule: __nccwpck_require__(53778),
    AtrulePrelude: __nccwpck_require__(34161),
    AttributeSelector: __nccwpck_require__(53887),
    Block: __nccwpck_require__(97800),
    Brackets: __nccwpck_require__(85549),
    CDC: __nccwpck_require__(6730),
    CDO: __nccwpck_require__(41210),
    ClassSelector: __nccwpck_require__(19694),
    Combinator: __nccwpck_require__(29026),
    Comment: __nccwpck_require__(46018),
    Declaration: __nccwpck_require__(78951),
    DeclarationList: __nccwpck_require__(12503),
    Dimension: __nccwpck_require__(22802),
    Function: __nccwpck_require__(16798),
    Hash: __nccwpck_require__(19580),
    Identifier: __nccwpck_require__(27783),
    IdSelector: __nccwpck_require__(91895),
    MediaFeature: __nccwpck_require__(17602),
    MediaQuery: __nccwpck_require__(12399),
    MediaQueryList: __nccwpck_require__(98206),
    Nth: __nccwpck_require__(36949),
    Number: __nccwpck_require__(32510),
    Operator: __nccwpck_require__(37098),
    Parentheses: __nccwpck_require__(17147),
    Percentage: __nccwpck_require__(10862),
    PseudoClassSelector: __nccwpck_require__(31440),
    PseudoElementSelector: __nccwpck_require__(91150),
    Ratio: __nccwpck_require__(56997),
    Raw: __nccwpck_require__(81287),
    Rule: __nccwpck_require__(46902),
    Selector: __nccwpck_require__(27356),
    SelectorList: __nccwpck_require__(53563),
    String: __nccwpck_require__(72605),
    StyleSheet: __nccwpck_require__(9383),
    TypeSelector: __nccwpck_require__(88050),
    UnicodeRange: __nccwpck_require__(23086),
    Url: __nccwpck_require__(37233),
    Value: __nccwpck_require__(27575),
    WhiteSpace: __nccwpck_require__(96411)
};


/***/ }),

/***/ 51881:
/***/ ((module) => {

var DISALLOW_OF_CLAUSE = false;

module.exports = {
    parse: function nth() {
        return this.createSingleNodeList(
            this.Nth(DISALLOW_OF_CLAUSE)
        );
    }
};


/***/ }),

/***/ 76779:
/***/ ((module) => {

var ALLOW_OF_CLAUSE = true;

module.exports = {
    parse: function nthWithOfClause() {
        return this.createSingleNodeList(
            this.Nth(ALLOW_OF_CLAUSE)
        );
    }
};


/***/ }),

/***/ 53379:
/***/ ((module) => {

module.exports = {
    parse: function selectorList() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};


/***/ }),

/***/ 92402:
/***/ ((module) => {

module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};


/***/ }),

/***/ 78313:
/***/ ((module) => {

module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};


/***/ }),

/***/ 84575:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
    'dir': __nccwpck_require__(92402),
    'has': __nccwpck_require__(78313),
    'lang': __nccwpck_require__(41671),
    'matches': __nccwpck_require__(98869),
    'not': __nccwpck_require__(42171),
    'nth-child': __nccwpck_require__(58075),
    'nth-last-child': __nccwpck_require__(95616),
    'nth-last-of-type': __nccwpck_require__(43157),
    'nth-of-type': __nccwpck_require__(22764),
    'slotted': __nccwpck_require__(97891)
};


/***/ }),

/***/ 41671:
/***/ ((module) => {

module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};


/***/ }),

/***/ 98869:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(53379);


/***/ }),

/***/ 42171:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(53379);


/***/ }),

/***/ 58075:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(76779);


/***/ }),

/***/ 95616:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(76779);


/***/ }),

/***/ 43157:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(51881);


/***/ }),

/***/ 22764:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(51881);


/***/ }),

/***/ 97891:
/***/ ((module) => {

module.exports = {
    parse: function compoundSelector() {
        return this.createSingleNodeList(
            this.Selector()
        );
    }
};


/***/ }),

/***/ 35244:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
    getNode: __nccwpck_require__(47406)
};


/***/ }),

/***/ 47406:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var cmpChar = __nccwpck_require__(69549).cmpChar;
var cmpStr = __nccwpck_require__(69549).cmpStr;
var TYPE = __nccwpck_require__(69549).TYPE;

var IDENT = TYPE.Ident;
var STRING = TYPE.String;
var NUMBER = TYPE.Number;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var HASH = TYPE.Hash;
var DIMENSION = TYPE.Dimension;
var PERCENTAGE = TYPE.Percentage;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var COMMA = TYPE.Comma;
var DELIM = TYPE.Delim;
var NUMBERSIGN = 0x0023;  // U+0023 NUMBER SIGN (#)
var ASTERISK = 0x002A;    // U+002A ASTERISK (*)
var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
var SOLIDUS = 0x002F;     // U+002F SOLIDUS (/)
var U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

module.exports = function defaultRecognizer(context) {
    switch (this.scanner.tokenType) {
        case HASH:
            return this.Hash();

        case COMMA:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Operator();

        case LEFTPARENTHESIS:
            return this.Parentheses(this.readSequence, context.recognizer);

        case LEFTSQUAREBRACKET:
            return this.Brackets(this.readSequence, context.recognizer);

        case STRING:
            return this.String();

        case DIMENSION:
            return this.Dimension();

        case PERCENTAGE:
            return this.Percentage();

        case NUMBER:
            return this.Number();

        case FUNCTION:
            return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
                ? this.Url()
                : this.Function(this.readSequence, context.recognizer);

        case URL:
            return this.Url();

        case IDENT:
            // check for unicode range, it should start with u+ or U+
            if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) &&
                cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
                return this.UnicodeRange();
            } else {
                return this.Identifier();
            }

        case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

            if (code === SOLIDUS ||
                code === ASTERISK ||
                code === PLUSSIGN ||
                code === HYPHENMINUS) {
                return this.Operator(); // TODO: replace with Delim
            }

            // TODO: produce a node with Delim node type

            if (code === NUMBERSIGN) {
                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
            }

            break;
    }
};


/***/ }),

/***/ 90326:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
    AtrulePrelude: __nccwpck_require__(35244),
    Selector: __nccwpck_require__(37752),
    Value: __nccwpck_require__(68463)
};


/***/ }),

/***/ 37752:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TYPE = __nccwpck_require__(69549).TYPE;

var DELIM = TYPE.Delim;
var IDENT = TYPE.Ident;
var DIMENSION = TYPE.Dimension;
var PERCENTAGE = TYPE.Percentage;
var NUMBER = TYPE.Number;
var HASH = TYPE.Hash;
var COLON = TYPE.Colon;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
var FULLSTOP = 0x002E;        // U+002E FULL STOP (.)
var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
var VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)
var TILDE = 0x007E;           // U+007E TILDE (~)

function getNode(context) {
    switch (this.scanner.tokenType) {
        case LEFTSQUAREBRACKET:
            return this.AttributeSelector();

        case HASH:
            return this.IdSelector();

        case COLON:
            if (this.scanner.lookupType(1) === COLON) {
                return this.PseudoElementSelector();
            } else {
                return this.PseudoClassSelector();
            }

        case IDENT:
            return this.TypeSelector();

        case NUMBER:
        case PERCENTAGE:
            return this.Percentage();

        case DIMENSION:
            // throws when .123ident
            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
                this.error('Identifier is expected', this.scanner.tokenStart + 1);
            }
            break;

        case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

            switch (code) {
                case PLUSSIGN:
                case GREATERTHANSIGN:
                case TILDE:
                    context.space = null;
                    context.ignoreWSAfter = true;
                    return this.Combinator();

                case SOLIDUS:  // /deep/
                    return this.Combinator();

                case FULLSTOP:
                    return this.ClassSelector();

                case ASTERISK:
                case VERTICALLINE:
                    return this.TypeSelector();

                case NUMBERSIGN:
                    return this.IdSelector();
            }

            break;
    }
};

module.exports = {
    getNode: getNode
};


/***/ }),

/***/ 68463:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = {
    getNode: __nccwpck_require__(47406),
    'expression': __nccwpck_require__(58575),
    'var': __nccwpck_require__(75724)
};


/***/ }),

/***/ 36157:
/***/ ((module) => {

var EOF = 0;

// https://drafts.csswg.org/css-syntax-3/
//  4.2. Definitions

// digit
// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
function isDigit(code) {
    return code >= 0x0030 && code <= 0x0039;
}

// hex digit
// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
function isHexDigit(code) {
    return (
        isDigit(code) || // 0 .. 9
        (code >= 0x0041 && code <= 0x0046) || // A .. F
        (code >= 0x0061 && code <= 0x0066)    // a .. f
    );
}

// uppercase letter
// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
function isUppercaseLetter(code) {
    return code >= 0x0041 && code <= 0x005A;
}

// lowercase letter
// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
function isLowercaseLetter(code) {
    return code >= 0x0061 && code <= 0x007A;
}

// letter
// An uppercase letter or a lowercase letter.
function isLetter(code) {
    return isUppercaseLetter(code) || isLowercaseLetter(code);
}

// non-ASCII code point
// A code point with a value equal to or greater than U+0080 <control>.
function isNonAscii(code) {
    return code >= 0x0080;
}

// name-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
function isNameStart(code) {
    return isLetter(code) || isNonAscii(code) || code === 0x005F;
}

// name code point
// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
function isName(code) {
    return isNameStart(code) || isDigit(code) || code === 0x002D;
}

// non-printable code point
// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
function isNonPrintable(code) {
    return (
        (code >= 0x0000 && code <= 0x0008) ||
        (code === 0x000B) ||
        (code >= 0x000E && code <= 0x001F) ||
        (code === 0x007F)
    );
}

// newline
// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
// as they are converted to U+000A LINE FEED during preprocessing.
// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
function isNewline(code) {
    return code === 0x000A || code === 0x000D || code === 0x000C;
}

// whitespace
// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
function isWhiteSpace(code) {
    return isNewline(code) || code === 0x0020 || code === 0x0009;
}

//  4.3.8. Check if two code points are a valid escape
function isValidEscape(first, second) {
    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
    if (first !== 0x005C) {
        return false;
    }

    // Otherwise, if the second code point is a newline or EOF, return false.
    if (isNewline(second) || second === EOF) {
        return false;
    }

    // Otherwise, return true.
    return true;
}

//  4.3.9. Check if three code points would start an identifier
function isIdentifierStart(first, second, third) {
    // Look at the first code point:

    // U+002D HYPHEN-MINUS
    if (first === 0x002D) {
        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
        // or the second and third code points are a valid escape, return true. Otherwise, return false.
        return (
            isNameStart(second) ||
            second === 0x002D ||
            isValidEscape(second, third)
        );
    }

    // name-start code point
    if (isNameStart(first)) {
        // Return true.
        return true;
    }

    // U+005C REVERSE SOLIDUS (\)
    if (first === 0x005C) {
        // If the first and second code points are a valid escape, return true. Otherwise, return false.
        return isValidEscape(first, second);
    }

    // anything else
    // Return false.
    return false;
}

//  4.3.10. Check if three code points would start a number
function isNumberStart(first, second, third) {
    // Look at the first code point:

    // U+002B PLUS SIGN (+)
    // U+002D HYPHEN-MINUS (-)
    if (first === 0x002B || first === 0x002D) {
        // If the second code point is a digit, return true.
        if (isDigit(second)) {
            return 2;
        }

        // Otherwise, if the second code point is a U+002E FULL STOP (.)
        // and the third code point is a digit, return true.
        // Otherwise, return false.
        return second === 0x002E && isDigit(third) ? 3 : 0;
    }

    // U+002E FULL STOP (.)
    if (first === 0x002E) {
        // If the second code point is a digit, return true. Otherwise, return false.
        return isDigit(second) ? 2 : 0;
    }

    // digit
    if (isDigit(first)) {
        // Return true.
        return 1;
    }

    // anything else
    // Return false.
    return 0;
}

//
// Misc
//

// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
function isBOM(code) {
    // UTF-16BE
    if (code === 0xFEFF) {
        return 1;
    }

    // UTF-16LE
    if (code === 0xFFFE) {
        return 1;
    }

    return 0;
}

// Fast code category
//
// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
// > non-ASCII code point
// >   A code point with a value equal to or greater than U+0080 <control>
// > name-start code point
// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
// > name code point
// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
var CATEGORY = new Array(0x80);
charCodeCategory.Eof = 0x80;
charCodeCategory.WhiteSpace = 0x82;
charCodeCategory.Digit = 0x83;
charCodeCategory.NameStart = 0x84;
charCodeCategory.NonPrintable = 0x85;

for (var i = 0; i < CATEGORY.length; i++) {
    switch (true) {
        case isWhiteSpace(i):
            CATEGORY[i] = charCodeCategory.WhiteSpace;
            break;

        case isDigit(i):
            CATEGORY[i] = charCodeCategory.Digit;
            break;

        case isNameStart(i):
            CATEGORY[i] = charCodeCategory.NameStart;
            break;

        case isNonPrintable(i):
            CATEGORY[i] = charCodeCategory.NonPrintable;
            break;

        default:
            CATEGORY[i] = i || charCodeCategory.Eof;
    }
}

function charCodeCategory(code) {
    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
};

module.exports = {
    isDigit: isDigit,
    isHexDigit: isHexDigit,
    isUppercaseLetter: isUppercaseLetter,
    isLowercaseLetter: isLowercaseLetter,
    isLetter: isLetter,
    isNonAscii: isNonAscii,
    isNameStart: isNameStart,
    isName: isName,
    isNonPrintable: isNonPrintable,
    isNewline: isNewline,
    isWhiteSpace: isWhiteSpace,
    isValidEscape: isValidEscape,
    isIdentifierStart: isIdentifierStart,
    isNumberStart: isNumberStart,

    isBOM: isBOM,
    charCodeCategory: charCodeCategory
};


/***/ }),

/***/ 62478:
/***/ ((module) => {

// CSS Syntax Module Level 3
// https://www.w3.org/TR/css-syntax-3/
var TYPE = {
    EOF: 0,                 // <EOF-token>
    Ident: 1,               // <ident-token>
    Function: 2,            // <function-token>
    AtKeyword: 3,           // <at-keyword-token>
    Hash: 4,                // <hash-token>
    String: 5,              // <string-token>
    BadString: 6,           // <bad-string-token>
    Url: 7,                 // <url-token>
    BadUrl: 8,              // <bad-url-token>
    Delim: 9,               // <delim-token>
    Number: 10,             // <number-token>
    Percentage: 11,         // <percentage-token>
    Dimension: 12,          // <dimension-token>
    WhiteSpace: 13,         // <whitespace-token>
    CDO: 14,                // <CDO-token>
    CDC: 15,                // <CDC-token>
    Colon: 16,              // <colon-token>     :
    Semicolon: 17,          // <semicolon-token> ;
    Comma: 18,              // <comma-token>     ,
    LeftSquareBracket: 19,  // <[-token>
    RightSquareBracket: 20, // <]-token>
    LeftParenthesis: 21,    // <(-token>
    RightParenthesis: 22,   // <)-token>
    LeftCurlyBracket: 23,   // <{-token>
    RightCurlyBracket: 24,  // <}-token>
    Comment: 25
};

var NAME = Object.keys(TYPE).reduce(function(result, key) {
    result[TYPE[key]] = key;
    return result;
}, {});

module.exports = {
    TYPE: TYPE,
    NAME: NAME
};


/***/ }),

/***/ 69549:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var TokenStream = __nccwpck_require__(89490);
var adoptBuffer = __nccwpck_require__(63156);

var constants = __nccwpck_require__(62478);
var TYPE = constants.TYPE;

var charCodeDefinitions = __nccwpck_require__(36157);
var isNewline = charCodeDefinitions.isNewline;
var isName = charCodeDefinitions.isName;
var isValidEscape = charCodeDefinitions.isValidEscape;
var isNumberStart = charCodeDefinitions.isNumberStart;
var isIdentifierStart = charCodeDefinitions.isIdentifierStart;
var charCodeCategory = charCodeDefinitions.charCodeCategory;
var isBOM = charCodeDefinitions.isBOM;

var utils = __nccwpck_require__(29292);
var cmpStr = utils.cmpStr;
var getNewlineLength = utils.getNewlineLength;
var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
var consumeEscaped = utils.consumeEscaped;
var consumeName = utils.consumeName;
var consumeNumber = utils.consumeNumber;
var consumeBadUrlRemnants = utils.consumeBadUrlRemnants;

var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;

function tokenize(source, stream) {
    function getCharCode(offset) {
        return offset < sourceLength ? source.charCodeAt(offset) : 0;
    }

    //  4.3.3. Consume a numeric token
    function consumeNumericToken() {
        // Consume a number and let number be the result.
        offset = consumeNumber(source, offset);

        // If the next 3 input code points would start an identifier, then:
        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
            // Consume a name. Set the <dimension-token>s unit to the returned value.
            // Return the <dimension-token>.
            type = TYPE.Dimension;
            offset = consumeName(source, offset);
            return;
        }

        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
        if (getCharCode(offset) === 0x0025) {
            // Create a <percentage-token> with the same value as number, and return it.
            type = TYPE.Percentage;
            offset++;
            return;
        }

        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
        type = TYPE.Number;
    }

    //  4.3.4. Consume an ident-like token
    function consumeIdentLikeToken() {
        const nameStartOffset = offset;

        // Consume a name, and let string be the result.
        offset = consumeName(source, offset);

        // If strings value is an ASCII case-insensitive match for "url",
        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
            // While the next two input code points are whitespace, consume the next input code point.
            offset = findWhiteSpaceEnd(source, offset + 1);

            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
            // then create a <function-token> with its value set to string and return it.
            if (getCharCode(offset) === 0x0022 ||
                getCharCode(offset) === 0x0027) {
                type = TYPE.Function;
                offset = nameStartOffset + 4;
                return;
            }

            // Otherwise, consume a url token, and return it.
            consumeUrlToken();
            return;
        }

        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        // Create a <function-token> with its value set to string and return it.
        if (getCharCode(offset) === 0x0028) {
            type = TYPE.Function;
            offset++;
            return;
        }

        // Otherwise, create an <ident-token> with its value set to string and return it.
        type = TYPE.Ident;
    }

    //  4.3.5. Consume a string token
    function consumeStringToken(endingCodePoint) {
        // This algorithm may be called with an ending code point, which denotes the code point
        // that ends the string. If an ending code point is not specified,
        // the current input code point is used.
        if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
        }

        // Initially create a <string-token> with its value set to the empty string.
        type = TYPE.String;

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // ending code point
                case endingCodePoint:
                    // Return the <string-token>.
                    offset++;
                    return;

                // EOF
                case charCodeCategory.Eof:
                    // This is a parse error. Return the <string-token>.
                    return;

                // newline
                case charCodeCategory.WhiteSpace:
                    if (isNewline(code)) {
                        // This is a parse error. Reconsume the current input code point,
                        // create a <bad-string-token>, and return it.
                        offset += getNewlineLength(source, offset, code);
                        type = TYPE.BadString;
                        return;
                    }
                    break;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the next input code point is EOF, do nothing.
                    if (offset === source.length - 1) {
                        break;
                    }

                    var nextCode = getCharCode(offset + 1);

                    // Otherwise, if the next input code point is a newline, consume it.
                    if (isNewline(nextCode)) {
                        offset += getNewlineLength(source, offset + 1, nextCode);
                    } else if (isValidEscape(code, nextCode)) {
                        // Otherwise, (the stream starts with a valid escape) consume
                        // an escaped code point and append the returned code point to
                        // the <string-token>s value.
                        offset = consumeEscaped(source, offset) - 1;
                    }
                    break;

                // anything else
                // Append the current input code point to the <string-token>s value.
            }
        }
    }

    //  4.3.6. Consume a url token
    // Note: This algorithm assumes that the initial "url(" has already been consumed.
    // This algorithm also assumes that its being called to consume an "unquoted" value, like url(foo).
    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
    // automatically handles this distinction; this algorithm shouldnt be called directly otherwise.
    function consumeUrlToken() {
        // Initially create a <url-token> with its value set to the empty string.
        type = TYPE.Url;

        // Consume as much whitespace as possible.
        offset = findWhiteSpaceEnd(source, offset);

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // U+0029 RIGHT PARENTHESIS ())
                case 0x0029:
                    // Return the <url-token>.
                    offset++;
                    return;

                // EOF
                case charCodeCategory.Eof:
                    // This is a parse error. Return the <url-token>.
                    return;

                // whitespace
                case charCodeCategory.WhiteSpace:
                    // Consume as much whitespace as possible.
                    offset = findWhiteSpaceEnd(source, offset);

                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
                    // consume it and return the <url-token>
                    // (if EOF was encountered, this is a parse error);
                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
                        if (offset < source.length) {
                            offset++;
                        }
                        return;
                    }

                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
                    // and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE.BadUrl;
                    return;

                // U+0022 QUOTATION MARK (")
                // U+0027 APOSTROPHE (')
                // U+0028 LEFT PARENTHESIS (()
                // non-printable code point
                case 0x0022:
                case 0x0027:
                case 0x0028:
                case charCodeCategory.NonPrintable:
                    // This is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE.BadUrl;
                    return;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the stream starts with a valid escape, consume an escaped code point and
                    // append the returned code point to the <url-token>s value.
                    if (isValidEscape(code, getCharCode(offset + 1))) {
                        offset = consumeEscaped(source, offset) - 1;
                        break;
                    }

                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = TYPE.BadUrl;
                    return;

                // anything else
                // Append the current input code point to the <url-token>s value.
            }
        }
    }

    if (!stream) {
        stream = new TokenStream();
    }

    // ensure source is a string
    source = String(source || '');

    var sourceLength = source.length;
    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
    var balance = adoptBuffer(stream.balance, sourceLength + 1);
    var tokenCount = 0;
    var start = isBOM(getCharCode(0));
    var offset = start;
    var balanceCloseType = 0;
    var balanceStart = 0;
    var balancePrev = 0;

    // https://drafts.csswg.org/css-syntax-3/#consume-token
    //  4.3.1. Consume a token
    while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = 0;

        balance[tokenCount] = sourceLength;

        switch (charCodeCategory(code)) {
            // whitespace
            case charCodeCategory.WhiteSpace:
                // Consume as much whitespace as possible. Return a <whitespace-token>.
                type = TYPE.WhiteSpace;
                offset = findWhiteSpaceEnd(source, offset + 1);
                break;

            // U+0022 QUOTATION MARK (")
            case 0x0022:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0023 NUMBER SIGN (#)
            case 0x0023:
                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // Create a <hash-token>.
                    type = TYPE.Hash;

                    // If the next 3 input code points would start an identifier, set the <hash-token>s type flag to "id".
                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    //     // TODO: set id flag
                    // }

                    // Consume a name, and set the <hash-token>s value to the returned string.
                    offset = consumeName(source, offset + 1);

                    // Return the <hash-token>.
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            // U+0027 APOSTROPHE (')
            case 0x0027:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0028 LEFT PARENTHESIS (()
            case 0x0028:
                // Return a <(-token>.
                type = TYPE.LeftParenthesis;
                offset++;
                break;

            // U+0029 RIGHT PARENTHESIS ())
            case 0x0029:
                // Return a <)-token>.
                type = TYPE.RightParenthesis;
                offset++;
                break;

            // U+002B PLUS SIGN (+)
            case 0x002B:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }
                break;

            // U+002C COMMA (,)
            case 0x002C:
                // Return a <comma-token>.
                type = TYPE.Comma;
                offset++;
                break;

            // U+002D HYPHEN-MINUS (-)
            case 0x002D:
                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeNumericToken();
                } else {
                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
                    if (getCharCode(offset + 1) === 0x002D &&
                        getCharCode(offset + 2) === 0x003E) {
                        type = TYPE.CDC;
                        offset = offset + 3;
                    } else {
                        // Otherwise, if the input stream starts with an identifier, ...
                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                            // ... reconsume the current input code point, consume an ident-like token, and return it.
                            consumeIdentLikeToken();
                        } else {
                            // Otherwise, return a <delim-token> with its value set to the current input code point.
                            type = TYPE.Delim;
                            offset++;
                        }
                    }
                }
                break;

            // U+002E FULL STOP (.)
            case 0x002E:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            // U+002F SOLIDUS (/)
            case 0x002F:
                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
                if (getCharCode(offset + 1) === 0x002A) {
                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
                    type = TYPE.Comment;
                    offset = source.indexOf('*/', offset + 2) + 2;
                    if (offset === 1) {
                        offset = source.length;
                    }
                } else {
                    type = TYPE.Delim;
                    offset++;
                }
                break;

            // U+003A COLON (:)
            case 0x003A:
                // Return a <colon-token>.
                type = TYPE.Colon;
                offset++;
                break;

            // U+003B SEMICOLON (;)
            case 0x003B:
                // Return a <semicolon-token>.
                type = TYPE.Semicolon;
                offset++;
                break;

            // U+003C LESS-THAN SIGN (<)
            case 0x003C:
                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
                if (getCharCode(offset + 1) === 0x0021 &&
                    getCharCode(offset + 2) === 0x002D &&
                    getCharCode(offset + 3) === 0x002D) {
                    // ... consume them and return a <CDO-token>.
                    type = TYPE.CDO;
                    offset = offset + 4;
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            // U+0040 COMMERCIAL AT (@)
            case 0x0040:
                // If the next 3 input code points would start an identifier, ...
                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
                    type = TYPE.AtKeyword;
                    offset = consumeName(source, offset + 1);
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }

                break;

            // U+005B LEFT SQUARE BRACKET ([)
            case 0x005B:
                // Return a <[-token>.
                type = TYPE.LeftSquareBracket;
                offset++;
                break;

            // U+005C REVERSE SOLIDUS (\)
            case 0x005C:
                // If the input stream starts with a valid escape, ...
                if (isValidEscape(code, getCharCode(offset + 1))) {
                    // ... reconsume the current input code point, consume an ident-like token, and return it.
                    consumeIdentLikeToken();
                } else {
                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
                    type = TYPE.Delim;
                    offset++;
                }
                break;

            // U+005D RIGHT SQUARE BRACKET (])
            case 0x005D:
                // Return a <]-token>.
                type = TYPE.RightSquareBracket;
                offset++;
                break;

            // U+007B LEFT CURLY BRACKET ({)
            case 0x007B:
                // Return a <{-token>.
                type = TYPE.LeftCurlyBracket;
                offset++;
                break;

            // U+007D RIGHT CURLY BRACKET (})
            case 0x007D:
                // Return a <}-token>.
                type = TYPE.RightCurlyBracket;
                offset++;
                break;

            // digit
            case charCodeCategory.Digit:
                // Reconsume the current input code point, consume a numeric token, and return it.
                consumeNumericToken();
                break;

            // name-start code point
            case charCodeCategory.NameStart:
                // Reconsume the current input code point, consume an ident-like token, and return it.
                consumeIdentLikeToken();
                break;

            // EOF
            case charCodeCategory.Eof:
                // Return an <EOF-token>.
                break;

            // anything else
            default:
                // Return a <delim-token> with its value set to the current input code point.
                type = TYPE.Delim;
                offset++;
        }

        switch (type) {
            case balanceCloseType:
                balancePrev = balanceStart & OFFSET_MASK;
                balanceStart = balance[balancePrev];
                balanceCloseType = balanceStart >> TYPE_SHIFT;
                balance[tokenCount] = balancePrev;
                balance[balancePrev++] = tokenCount;
                for (; balancePrev < tokenCount; balancePrev++) {
                    if (balance[balancePrev] === sourceLength) {
                        balance[balancePrev] = tokenCount;
                    }
                }
                break;

            case TYPE.LeftParenthesis:
            case TYPE.Function:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE.RightParenthesis;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;

            case TYPE.LeftSquareBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE.RightSquareBracket;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;

            case TYPE.LeftCurlyBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = TYPE.RightCurlyBracket;
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;
        }

        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
    }

    // finalize buffers
    offsetAndType[tokenCount] = (TYPE.EOF << TYPE_SHIFT) | offset; // <EOF-token>
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
    while (balanceStart !== 0) {
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
    }

    // update stream
    stream.source = source;
    stream.firstCharOffset = start;
    stream.offsetAndType = offsetAndType;
    stream.tokenCount = tokenCount;
    stream.balance = balance;
    stream.reset();
    stream.next();

    return stream;
}

// extend tokenizer with constants
Object.keys(constants).forEach(function(key) {
    tokenize[key] = constants[key];
});

// extend tokenizer with static methods from utils
Object.keys(charCodeDefinitions).forEach(function(key) {
    tokenize[key] = charCodeDefinitions[key];
});
Object.keys(utils).forEach(function(key) {
    tokenize[key] = utils[key];
});

module.exports = tokenize;


/***/ }),

/***/ 29292:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var charCodeDef = __nccwpck_require__(36157);
var isDigit = charCodeDef.isDigit;
var isHexDigit = charCodeDef.isHexDigit;
var isUppercaseLetter = charCodeDef.isUppercaseLetter;
var isName = charCodeDef.isName;
var isWhiteSpace = charCodeDef.isWhiteSpace;
var isValidEscape = charCodeDef.isValidEscape;

function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
}

function getNewlineLength(source, offset, code) {
    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
        return 2;
    }

    return 1;
}

function cmpChar(testStr, offset, referenceCode) {
    var code = testStr.charCodeAt(offset);

    // code.toLowerCase() for A..Z
    if (isUppercaseLetter(code)) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (var i = start; i < end; i++) {
        var testCode = testStr.charCodeAt(i);
        var referenceCode = referenceStr.charCodeAt(i - start);

        // testCode.toLowerCase() for A..Z
        if (isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function findWhiteSpaceStart(source, offset) {
    for (; offset >= 0; offset--) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset + 1;
}

function findWhiteSpaceEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isDigit(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

//  4.3.7. Consume an escaped code point
function consumeEscaped(source, offset) {
    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
    // that the next input code point has already been verified to be part of a valid escape.
    offset += 2;

    // hex digit
    if (isHexDigit(getCharCode(source, offset - 1))) {
        // Consume as many hex digits as possible, but no more than 5.
        // Note that this means 1-6 hex digits have been consumed in total.
        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
            if (!isHexDigit(getCharCode(source, offset))) {
                break;
            }
        }

        // If the next input code point is whitespace, consume it as well.
        var code = getCharCode(source, offset);
        if (isWhiteSpace(code)) {
            offset += getNewlineLength(source, offset, code);
        }
    }

    return offset;
}

// 4.3.11. Consume a name
// Note: This algorithm does not do the verification of the first few code points that are necessary
// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
// ensure that the stream starts with an identifier before calling this algorithm.
function consumeName(source, offset) {
    // Let result initially be an empty string.
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // name code point
        if (isName(code)) {
            // Append the code point to result.
            continue;
        }

        // the stream starts with a valid escape
        if (isValidEscape(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point. Append the returned code point to result.
            offset = consumeEscaped(source, offset) - 1;
            continue;
        }

        // anything else
        // Reconsume the current input code point. Return result.
        break;
    }

    return offset;
}

// 4.3.12. Consume a number
function consumeNumber(source, offset) {
    var code = source.charCodeAt(offset);

    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
    // consume it and append it to repr.
    if (code === 0x002B || code === 0x002D) {
        code = source.charCodeAt(offset += 1);
    }

    // 3. While the next input code point is a digit, consume it and append it to repr.
    if (isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
    }

    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {
        // 4.1 Consume them.
        // 4.2 Append them to repr.
        code = source.charCodeAt(offset += 2);

        // 4.3 Set type to "number".
        // TODO

        // 4.4 While the next input code point is a digit, consume it and append it to repr.

        offset = findDecimalNumberEnd(source, offset);
    }

    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
    if (cmpChar(source, offset, 101 /* e */)) {
        var sign = 0;
        code = source.charCodeAt(offset + 1);

        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
        if (code === 0x002D || code === 0x002B) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
        }

        // ... followed by a digit
        if (isDigit(code)) {
            // 5.1 Consume them.
            // 5.2 Append them to repr.

            // 5.3 Set type to "number".
            // TODO

            // 5.4 While the next input code point is a digit, consume it and append it to repr.
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
    }

    return offset;
}

//  4.3.14. Consume the remnants of a bad url
// ... its sole use is to consume enough of the input stream to reach a recovery point
// where normal tokenizing can resume.
function consumeBadUrlRemnants(source, offset) {
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // U+0029 RIGHT PARENTHESIS ())
        // EOF
        if (code === 0x0029) {
            // Return.
            offset++;
            break;
        }

        if (isValidEscape(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point.
            // Note: This allows an escaped right parenthesis ("\)") to be encountered
            // without ending the <bad-url-token>. This is otherwise identical to
            // the "anything else" clause.
            offset = consumeEscaped(source, offset);
        }
    }

    return offset;
}

module.exports = {
    consumeEscaped: consumeEscaped,
    consumeName: consumeName,
    consumeNumber: consumeNumber,
    consumeBadUrlRemnants: consumeBadUrlRemnants,

    cmpChar: cmpChar,
    cmpStr: cmpStr,

    getNewlineLength: getNewlineLength,
    findWhiteSpaceStart: findWhiteSpaceStart,
    findWhiteSpaceEnd: findWhiteSpaceEnd
};


/***/ }),

/***/ 52404:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var List = __nccwpck_require__(11282);

module.exports = function clone(node) {
    var result = {};

    for (var key in node) {
        var value = node[key];

        if (value) {
            if (Array.isArray(value) || value instanceof List) {
                value = value.map(clone);
            } else if (value.constructor === Object) {
                value = clone(value);
            }
        }

        result[key] = value;
    }

    return result;
};


/***/ }),

/***/ 20195:
/***/ ((module) => {

module.exports = function createCustomError(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    var error = Object.create(SyntaxError.prototype);
    var errorStack = new Error();

    error.name = name;
    error.message = message;

    Object.defineProperty(error, 'stack', {
        get: function() {
            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
        }
    });

    return error;
};


/***/ }),

/***/ 87602:
/***/ ((module) => {

var hasOwnProperty = Object.prototype.hasOwnProperty;
var keywords = Object.create(null);
var properties = Object.create(null);
var HYPHENMINUS = 45; // '-'.charCodeAt()

function isCustomProperty(str, offset) {
    offset = offset || 0;

    return str.length - offset >= 2 &&
           str.charCodeAt(offset) === HYPHENMINUS &&
           str.charCodeAt(offset + 1) === HYPHENMINUS;
}

function getVendorPrefix(str, offset) {
    offset = offset || 0;

    // verdor prefix should be at least 3 chars length
    if (str.length - offset >= 3) {
        // vendor prefix starts with hyper minus following non-hyper minus
        if (str.charCodeAt(offset) === HYPHENMINUS &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
            // vendor prefix should contain a hyper minus at the ending
            var secondDashIndex = str.indexOf('-', offset + 2);

            if (secondDashIndex !== -1) {
                return str.substring(offset, secondDashIndex + 1);
            }
        }
    }

    return '';
}

function getKeywordDescriptor(keyword) {
    if (hasOwnProperty.call(keywords, keyword)) {
        return keywords[keyword];
    }

    var name = keyword.toLowerCase();

    if (hasOwnProperty.call(keywords, name)) {
        return keywords[keyword] = keywords[name];
    }

    var custom = isCustomProperty(name, 0);
    var vendor = !custom ? getVendorPrefix(name, 0) : '';

    return keywords[keyword] = Object.freeze({
        basename: name.substr(vendor.length),
        name: name,
        vendor: vendor,
        prefix: vendor,
        custom: custom
    });
}

function getPropertyDescriptor(property) {
    if (hasOwnProperty.call(properties, property)) {
        return properties[property];
    }

    var name = property;
    var hack = property[0];

    if (hack === '/') {
        hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' &&
               hack !== '*' &&
               hack !== '$' &&
               hack !== '#' &&
               hack !== '+' &&
               hack !== '&') {
        hack = '';
    }

    var custom = isCustomProperty(name, hack.length);

    // re-use result when possible (the same as for lower case)
    if (!custom) {
        name = name.toLowerCase();
        if (hasOwnProperty.call(properties, name)) {
            return properties[property] = properties[name];
        }
    }

    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    var prefix = name.substr(0, hack.length + vendor.length);

    return properties[property] = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack: hack,
        vendor: vendor,
        prefix: prefix,
        custom: custom
    });
}

module.exports = {
    keyword: getKeywordDescriptor,
    property: getPropertyDescriptor,
    isCustomProperty: isCustomProperty,
    vendorPrefix: getVendorPrefix
};


/***/ }),

/***/ 61090:
/***/ ((module) => {

var hasOwnProperty = Object.prototype.hasOwnProperty;
var noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

function invokeForType(fn, type) {
    return function(node, item, list) {
        if (node.type === type) {
            fn.call(this, node, item, list);
        }
    };
}

function getWalkersFromStructure(name, nodeType) {
    var structure = nodeType.structure;
    var walkers = [];

    for (var key in structure) {
        if (hasOwnProperty.call(structure, key) === false) {
            continue;
        }

        var fieldTypes = structure[key];
        var walker = {
            name: key,
            type: false,
            nullable: false
        };

        if (!Array.isArray(structure[key])) {
            fieldTypes = [structure[key]];
        }

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === null) {
                walker.nullable = true;
            } else if (typeof fieldType === 'string') {
                walker.type = 'node';
            } else if (Array.isArray(fieldType)) {
                walker.type = 'list';
            }
        }

        if (walker.type) {
            walkers.push(walker);
        }
    }

    if (walkers.length) {
        return {
            context: nodeType.walkContext,
            fields: walkers
        };
    }

    return null;
}

function getTypesFromConfig(config) {
    var types = {};

    for (var name in config.node) {
        if (hasOwnProperty.call(config.node, name)) {
            var nodeType = config.node[name];

            if (!nodeType.structure) {
                throw new Error('Missed `structure` field in `' + name + '` node type definition');
            }

            types[name] = getWalkersFromStructure(name, nodeType);
        }
    }

    return types;
}

function createTypeIterator(config, reverse) {
    var fields = config.fields.slice();
    var contextName = config.context;
    var useContext = typeof contextName === 'string';

    if (reverse) {
        fields.reverse();
    }

    return function(node, context, walk, walkReducer) {
        var prevContextValue;

        if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
        }

        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var ref = node[field.name];

            if (!field.nullable || ref) {
                if (field.type === 'list') {
                    var breakWalk = reverse
                        ? ref.reduceRight(walkReducer, false)
                        : ref.reduce(walkReducer, false);

                    if (breakWalk) {
                        return true;
                    }
                } else if (walk(ref)) {
                    return true;
                }
            }
        }

        if (useContext) {
            context[contextName] = prevContextValue;
        }
    };
}

function createFastTraveralMap(iterators) {
    return {
        Atrule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Rule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Declaration: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block,
            DeclarationList: iterators.DeclarationList
        }
    };
}

module.exports = function createWalker(config) {
    var types = getTypesFromConfig(config);
    var iteratorsNatural = {};
    var iteratorsReverse = {};
    var breakWalk = Symbol('break-walk');
    var skipNode = Symbol('skip-node');

    for (var name in types) {
        if (hasOwnProperty.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
    }

    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    var walk = function(root, options) {
        function walkNode(node, item, list) {
            var enterRet = enter.call(context, node, item, list);

            if (enterRet === breakWalk) {
                debugger;
                return true;
            }

            if (enterRet === skipNode) {
                return false;
            }

            if (iterators.hasOwnProperty(node.type)) {
                if (iterators[node.type](node, context, walkNode, walkReducer)) {
                    return true;
                }
            }

            if (leave.call(context, node, item, list) === breakWalk) {
                return true;
            }

            return false;
        }

        var walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        var enter = noop;
        var leave = noop;
        var iterators = iteratorsNatural;
        var context = {
            break: breakWalk,
            skip: skipNode,

            root: root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
        };

        if (typeof options === 'function') {
            enter = options;
        } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);

            if (options.reverse) {
                iterators = iteratorsReverse;
            }

            if (options.visit) {
                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                    iterators = options.reverse
                        ? fastTraversalIteratorsReverse[options.visit]
                        : fastTraversalIteratorsNatural[options.visit];
                } else if (!types.hasOwnProperty(options.visit)) {
                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
                }

                enter = invokeForType(enter, options.visit);
                leave = invokeForType(leave, options.visit);
            }
        }

        if (enter === noop && leave === noop) {
            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
        }

        walkNode(root);
    };

    walk.break = breakWalk;
    walk.skip = skipNode;

    walk.find = function(ast, fn) {
        var found = null;

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
            }
        });

        return found;
    };

    walk.findLast = function(ast, fn) {
        var found = null;

        walk(ast, {
            reverse: true,
            enter: function(node, item, list) {
                if (fn.call(this, node, item, list)) {
                    found = node;
                    return breakWalk;
                }
            }
        });

        return found;
    };

    walk.findAll = function(ast, fn) {
        var found = [];

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found.push(node);
            }
        });

        return found;
    };

    return walk;
};


/***/ }),

/***/ 23336:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __nccwpck_require__(84589);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.I = ArraySet;


/***/ }),

/***/ 67586:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __nccwpck_require__(61102);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ 61102:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ 77336:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __nccwpck_require__(84589);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.H = MappingList;


/***/ }),

/***/ 66558:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __nccwpck_require__(67586);
var util = __nccwpck_require__(84589);
var ArraySet = __nccwpck_require__(23336)/* .ArraySet */ .I;
var MappingList = __nccwpck_require__(77336)/* .MappingList */ .H;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.h = SourceMapGenerator;


/***/ }),

/***/ 84589:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ }),

/***/ 19218:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringify = exports.parse = void 0;
__exportStar(__nccwpck_require__(97751), exports);
var parse_1 = __nccwpck_require__(97751);
Object.defineProperty(exports, "parse", ({ enumerable: true, get: function () { return __importDefault(parse_1).default; } }));
var stringify_1 = __nccwpck_require__(70586);
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return __importDefault(stringify_1).default; } }));


/***/ }),

/***/ 97751:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTraversal = void 0;
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var actionTypes = new Map([
    ["~", "element"],
    ["^", "start"],
    ["$", "end"],
    ["*", "any"],
    ["!", "not"],
    ["|", "hyphen"],
]);
var Traversals = {
    ">": "child",
    "<": "parent",
    "~": "sibling",
    "+": "adjacent",
};
var attribSelectors = {
    "#": ["id", "equals"],
    ".": ["class", "element"],
};
// Pseudos, whose data property is parsed as well.
var unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "host",
    "host-context",
]);
var traversalNames = new Set(__spreadArray([
    "descendant"
], Object.keys(Traversals).map(function (k) { return Traversals[k]; })));
/**
 * Attributes that are case-insensitive in HTML.
 *
 * @private
 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
 */
var caseInsensitiveAttributes = new Set([
    "accept",
    "accept-charset",
    "align",
    "alink",
    "axis",
    "bgcolor",
    "charset",
    "checked",
    "clear",
    "codetype",
    "color",
    "compact",
    "declare",
    "defer",
    "dir",
    "direction",
    "disabled",
    "enctype",
    "face",
    "frame",
    "hreflang",
    "http-equiv",
    "lang",
    "language",
    "link",
    "media",
    "method",
    "multiple",
    "nohref",
    "noresize",
    "noshade",
    "nowrap",
    "readonly",
    "rel",
    "rev",
    "rules",
    "scope",
    "scrolling",
    "selected",
    "shape",
    "target",
    "text",
    "type",
    "valign",
    "valuetype",
    "vlink",
]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal(selector) {
    return traversalNames.has(selector.type);
}
exports.isTraversal = isTraversal;
var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
var quotes = new Set(['"', "'"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
    var high = parseInt(escaped, 16) - 0x10000;
    // NaN means non-codepoint
    return high !== high || escapedWhitespace
        ? escaped
        : high < 0
            ? // BMP codepoint
                String.fromCharCode(high + 0x10000)
            : // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
}
function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
}
function isWhitespace(c) {
    return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse(selector, options) {
    var subselects = [];
    var endIndex = parseSelector(subselects, "" + selector, options, 0);
    if (endIndex < selector.length) {
        throw new Error("Unmatched selector: " + selector.slice(endIndex));
    }
    return subselects;
}
exports.default = parse;
function parseSelector(subselects, selector, options, selectorIndex) {
    var _a, _b;
    if (options === void 0) { options = {}; }
    var tokens = [];
    var sawWS = false;
    function getName(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
            throw new Error("Expected name, found " + selector.slice(selectorIndex));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
        while (isWhitespace(selector.charAt(selectorIndex + offset)))
            offset++;
        selectorIndex += offset;
    }
    function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charAt(--pos) === "\\")
            slashCount++;
        return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
        }
    }
    stripWhitespace(0);
    while (selector !== "") {
        var firstChar = selector.charAt(selectorIndex);
        if (isWhitespace(firstChar)) {
            sawWS = true;
            stripWhitespace(1);
        }
        else if (firstChar in Traversals) {
            ensureNotTraversal();
            tokens.push({ type: Traversals[firstChar] });
            sawWS = false;
            stripWhitespace(1);
        }
        else if (firstChar === ",") {
            if (tokens.length === 0) {
                throw new Error("Empty sub-selector");
            }
            subselects.push(tokens);
            tokens = [];
            sawWS = false;
            stripWhitespace(1);
        }
        else if (selector.startsWith("/*", selectorIndex)) {
            var endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
                throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
        }
        else {
            if (sawWS) {
                ensureNotTraversal();
                tokens.push({ type: "descendant" });
                sawWS = false;
            }
            if (firstChar in attribSelectors) {
                var _c = attribSelectors[firstChar], name_1 = _c[0], action = _c[1];
                tokens.push({
                    type: "attribute",
                    name: name_1,
                    action: action,
                    value: getName(1),
                    namespace: null,
                    // TODO: Add quirksMode option, which makes `ignoreCase` `true` for HTML.
                    ignoreCase: options.xmlMode ? null : false,
                });
            }
            else if (firstChar === "[") {
                stripWhitespace(1);
                // Determine attribute name and namespace
                var name_2 = void 0;
                var namespace = null;
                if (selector.charAt(selectorIndex) === "|") {
                    namespace = "";
                    selectorIndex += 1;
                }
                if (selector.startsWith("*|", selectorIndex)) {
                    namespace = "*";
                    selectorIndex += 2;
                }
                name_2 = getName(0);
                if (namespace === null &&
                    selector.charAt(selectorIndex) === "|" &&
                    selector.charAt(selectorIndex + 1) !== "=") {
                    namespace = name_2;
                    name_2 = getName(1);
                }
                if ((_a = options.lowerCaseAttributeNames) !== null && _a !== void 0 ? _a : !options.xmlMode) {
                    name_2 = name_2.toLowerCase();
                }
                stripWhitespace(0);
                // Determine comparison operation
                var action = "exists";
                var possibleAction = actionTypes.get(selector.charAt(selectorIndex));
                if (possibleAction) {
                    action = possibleAction;
                    if (selector.charAt(selectorIndex + 1) !== "=") {
                        throw new Error("Expected `=`");
                    }
                    stripWhitespace(2);
                }
                else if (selector.charAt(selectorIndex) === "=") {
                    action = "equals";
                    stripWhitespace(1);
                }
                // Determine value
                var value = "";
                var ignoreCase = null;
                if (action !== "exists") {
                    if (quotes.has(selector.charAt(selectorIndex))) {
                        var quote = selector.charAt(selectorIndex);
                        var sectionEnd = selectorIndex + 1;
                        while (sectionEnd < selector.length &&
                            (selector.charAt(sectionEnd) !== quote ||
                                isEscaped(sectionEnd))) {
                            sectionEnd += 1;
                        }
                        if (selector.charAt(sectionEnd) !== quote) {
                            throw new Error("Attribute value didn't end");
                        }
                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                        selectorIndex = sectionEnd + 1;
                    }
                    else {
                        var valueStart = selectorIndex;
                        while (selectorIndex < selector.length &&
                            ((!isWhitespace(selector.charAt(selectorIndex)) &&
                                selector.charAt(selectorIndex) !== "]") ||
                                isEscaped(selectorIndex))) {
                            selectorIndex += 1;
                        }
                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                    }
                    stripWhitespace(0);
                    // See if we have a force ignore flag
                    var forceIgnore = selector.charAt(selectorIndex);
                    // If the forceIgnore flag is set (either `i` or `s`), use that value
                    if (forceIgnore === "s" || forceIgnore === "S") {
                        ignoreCase = false;
                        stripWhitespace(1);
                    }
                    else if (forceIgnore === "i" || forceIgnore === "I") {
                        ignoreCase = true;
                        stripWhitespace(1);
                    }
                }
                // If `xmlMode` is set, there are no rules; otherwise, use the `caseInsensitiveAttributes` list.
                if (!options.xmlMode) {
                    // TODO: Skip this for `exists`, as there is no value to compare to.
                    ignoreCase !== null && ignoreCase !== void 0 ? ignoreCase : (ignoreCase = caseInsensitiveAttributes.has(name_2));
                }
                if (selector.charAt(selectorIndex) !== "]") {
                    throw new Error("Attribute selector didn't terminate");
                }
                selectorIndex += 1;
                var attributeSelector = {
                    type: "attribute",
                    name: name_2,
                    action: action,
                    value: value,
                    namespace: namespace,
                    ignoreCase: ignoreCase,
                };
                tokens.push(attributeSelector);
            }
            else if (firstChar === ":") {
                if (selector.charAt(selectorIndex + 1) === ":") {
                    tokens.push({
                        type: "pseudo-element",
                        name: getName(2).toLowerCase(),
                    });
                    continue;
                }
                var name_3 = getName(1).toLowerCase();
                var data = null;
                if (selector.charAt(selectorIndex) === "(") {
                    if (unpackPseudos.has(name_3)) {
                        if (quotes.has(selector.charAt(selectorIndex + 1))) {
                            throw new Error("Pseudo-selector " + name_3 + " cannot be quoted");
                        }
                        data = [];
                        selectorIndex = parseSelector(data, selector, options, selectorIndex + 1);
                        if (selector.charAt(selectorIndex) !== ")") {
                            throw new Error("Missing closing parenthesis in :" + name_3 + " (" + selector + ")");
                        }
                        selectorIndex += 1;
                    }
                    else {
                        selectorIndex += 1;
                        var start = selectorIndex;
                        var counter = 1;
                        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
                            if (selector.charAt(selectorIndex) === "(" &&
                                !isEscaped(selectorIndex)) {
                                counter++;
                            }
                            else if (selector.charAt(selectorIndex) === ")" &&
                                !isEscaped(selectorIndex)) {
                                counter--;
                            }
                        }
                        if (counter) {
                            throw new Error("Parenthesis not matched");
                        }
                        data = selector.slice(start, selectorIndex - 1);
                        if (stripQuotesFromPseudos.has(name_3)) {
                            var quot = data.charAt(0);
                            if (quot === data.slice(-1) && quotes.has(quot)) {
                                data = data.slice(1, -1);
                            }
                            data = unescapeCSS(data);
                        }
                    }
                }
                tokens.push({ type: "pseudo", name: name_3, data: data });
            }
            else {
                var namespace = null;
                var name_4 = void 0;
                if (firstChar === "*") {
                    selectorIndex += 1;
                    name_4 = "*";
                }
                else if (reName.test(selector.slice(selectorIndex))) {
                    if (selector.charAt(selectorIndex) === "|") {
                        namespace = "";
                        selectorIndex += 1;
                    }
                    name_4 = getName(0);
                }
                else {
                    /*
                     * We have finished parsing the selector.
                     * Remove descendant tokens at the end if they exist,
                     * and return the last index, so that parsing can be
                     * picked up from here.
                     */
                    if (tokens.length &&
                        tokens[tokens.length - 1].type === "descendant") {
                        tokens.pop();
                    }
                    addToken(subselects, tokens);
                    return selectorIndex;
                }
                if (selector.charAt(selectorIndex) === "|") {
                    namespace = name_4;
                    if (selector.charAt(selectorIndex + 1) === "*") {
                        name_4 = "*";
                        selectorIndex += 2;
                    }
                    else {
                        name_4 = getName(1);
                    }
                }
                if (name_4 === "*") {
                    tokens.push({ type: "universal", namespace: namespace });
                }
                else {
                    if ((_b = options.lowerCaseTags) !== null && _b !== void 0 ? _b : !options.xmlMode) {
                        name_4 = name_4.toLowerCase();
                    }
                    tokens.push({ type: "tag", name: name_4, namespace: namespace });
                }
            }
        }
    }
    addToken(subselects, tokens);
    return selectorIndex;
}
function addToken(subselects, tokens) {
    if (subselects.length > 0 && tokens.length === 0) {
        throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
}


/***/ }),

/***/ 70586:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var actionTypes = {
    equals: "",
    element: "~",
    start: "^",
    end: "$",
    any: "*",
    not: "!",
    hyphen: "|",
};
var charsToEscape = new Set(__spreadArray(__spreadArray([], Object.keys(actionTypes)
    .map(function (typeKey) { return actionTypes[typeKey]; })
    .filter(Boolean)), [
    ":",
    "[",
    "]",
    " ",
    "\\",
    "(",
    ")",
    "'",
]));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify(selector) {
    return selector.map(stringifySubselector).join(", ");
}
exports.default = stringify;
function stringifySubselector(token) {
    return token.map(stringifyToken).join("");
}
function stringifyToken(token) {
    switch (token.type) {
        // Simple types
        case "child":
            return " > ";
        case "parent":
            return " < ";
        case "sibling":
            return " ~ ";
        case "adjacent":
            return " + ";
        case "descendant":
            return " ";
        case "universal":
            return getNamespace(token.namespace) + "*";
        case "tag":
            return getNamespacedName(token);
        case "pseudo-element":
            return "::" + escapeName(token.name);
        case "pseudo":
            if (token.data === null)
                return ":" + escapeName(token.name);
            if (typeof token.data === "string") {
                return ":" + escapeName(token.name) + "(" + escapeName(token.data) + ")";
            }
            return ":" + escapeName(token.name) + "(" + stringify(token.data) + ")";
        case "attribute": {
            if (token.name === "id" &&
                token.action === "equals" &&
                !token.ignoreCase &&
                !token.namespace) {
                return "#" + escapeName(token.value);
            }
            if (token.name === "class" &&
                token.action === "element" &&
                !token.ignoreCase &&
                !token.namespace) {
                return "." + escapeName(token.value);
            }
            var name_1 = getNamespacedName(token);
            if (token.action === "exists") {
                return "[" + name_1 + "]";
            }
            return "[" + name_1 + actionTypes[token.action] + "='" + escapeName(token.value) + "'" + (token.ignoreCase ? "i" : token.ignoreCase === false ? "s" : "") + "]";
        }
    }
}
function getNamespacedName(token) {
    return "" + getNamespace(token.namespace) + escapeName(token.name);
}
function getNamespace(namespace) {
    return namespace !== null
        ? (namespace === "*" ? "*" : escapeName(namespace)) + "|"
        : "";
}
function escapeName(str) {
    return str
        .split("")
        .map(function (c) { return (charsToEscape.has(c) ? "\\" + c : c); })
        .join("");
}


/***/ }),

/***/ 63120:
/***/ ((module) => {

"use strict";
/*! https://mths.be/cssesc v3.0.0 by @mathias */


var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge = function merge(options, defaults) {
	if (!options) {
		return defaults;
	}
	var result = {};
	for (var key in defaults) {
		// `if (defaults.hasOwnProperty(key) {  }` is not needed here, since
		// only recognized option names are used.
		result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
	}
	return result;
};

var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexAlwaysEscape = /['"\\]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

// https://mathiasbynens.be/notes/css-escapes#css
var cssesc = function cssesc(string, options) {
	options = merge(options, cssesc.options);
	if (options.quotes != 'single' && options.quotes != 'double') {
		options.quotes = 'single';
	}
	var quote = options.quotes == 'double' ? '"' : '\'';
	var isIdentifier = options.isIdentifier;

	var firstChar = string.charAt(0);
	var output = '';
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var character = string.charAt(counter++);
		var codePoint = character.charCodeAt();
		var value = void 0;
		// If its not a printable ASCII character
		if (codePoint < 0x20 || codePoint > 0x7E) {
			if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
				// Its a high surrogate, and there is a next character.
				var extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// next character is low surrogate
					codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
				} else {
					// Its an unmatched surrogate; only append this code unit, in case
					// the next code unit is the high surrogate of a surrogate pair.
					counter--;
				}
			}
			value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
		} else {
			if (options.escapeEverything) {
				if (regexAnySingleEscape.test(character)) {
					value = '\\' + character;
				} else {
					value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
				}
			} else if (/[\t\n\f\r\x0B]/.test(character)) {
				value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
			} else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
				value = '\\' + character;
			} else {
				value = character;
			}
		}
		output += value;
	}

	if (isIdentifier) {
		if (/^-[-\d]/.test(output)) {
			output = '\\-' + output.slice(1);
		} else if (/\d/.test(firstChar)) {
			output = '\\3' + firstChar + ' ' + output.slice(1);
		}
	}

	// Remove spaces after `\HEX` escapes that are not followed by a hex digit,
	// since theyre redundant. Note that this is only possible if the escape
	// sequence isnt preceded by an odd number of backslashes.
	output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
		if ($1 && $1.length % 2) {
			// Its not safe to remove the space, so dont.
			return $0;
		}
		// Strip the space.
		return ($1 || '') + $2;
	});

	if (!isIdentifier && options.wrap) {
		return quote + output + quote;
	}
	return output;
};

// Expose default options (so they can be overridden globally).
cssesc.options = {
	'escapeEverything': false,
	'isIdentifier': false,
	'quotes': 'single',
	'wrap': false
};

cssesc.version = '3.0.0';

module.exports = cssesc;


/***/ }),

/***/ 64524:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = defaultPreset;

var _cssDeclarationSorter = _interopRequireDefault(__nccwpck_require__(44102));

var _postcssDiscardComments = _interopRequireDefault(__nccwpck_require__(79475));

var _postcssReduceInitial = _interopRequireDefault(__nccwpck_require__(85512));

var _postcssMinifyGradients = _interopRequireDefault(__nccwpck_require__(33683));

var _postcssSvgo = _interopRequireDefault(__nccwpck_require__(8762));

var _postcssReduceTransforms = _interopRequireDefault(__nccwpck_require__(76245));

var _postcssConvertValues = _interopRequireDefault(__nccwpck_require__(8853));

var _postcssCalc = _interopRequireDefault(__nccwpck_require__(31624));

var _postcssColormin = _interopRequireDefault(__nccwpck_require__(13697));

var _postcssOrderedValues = _interopRequireDefault(__nccwpck_require__(40933));

var _postcssMinifySelectors = _interopRequireDefault(__nccwpck_require__(86506));

var _postcssMinifyParams = _interopRequireDefault(__nccwpck_require__(87496));

var _postcssNormalizeCharset = _interopRequireDefault(__nccwpck_require__(36738));

var _postcssMinifyFontValues = _interopRequireDefault(__nccwpck_require__(20586));

var _postcssNormalizeUrl = _interopRequireDefault(__nccwpck_require__(5791));

var _postcssMergeLonghand = _interopRequireDefault(__nccwpck_require__(51028));

var _postcssDiscardDuplicates = _interopRequireDefault(__nccwpck_require__(28648));

var _postcssDiscardOverridden = _interopRequireDefault(__nccwpck_require__(27467));

var _postcssNormalizeRepeatStyle = _interopRequireDefault(__nccwpck_require__(18073));

var _postcssMergeRules = _interopRequireDefault(__nccwpck_require__(74210));

var _postcssDiscardEmpty = _interopRequireDefault(__nccwpck_require__(94888));

var _postcssUniqueSelectors = _interopRequireDefault(__nccwpck_require__(17998));

var _postcssNormalizeString = _interopRequireDefault(__nccwpck_require__(56031));

var _postcssNormalizePositions = _interopRequireDefault(__nccwpck_require__(40260));

var _postcssNormalizeWhitespace = _interopRequireDefault(__nccwpck_require__(82053));

var _postcssNormalizeUnicode = _interopRequireDefault(__nccwpck_require__(88249));

var _postcssNormalizeDisplayValues = _interopRequireDefault(__nccwpck_require__(65125));

var _postcssNormalizeTimingFunctions = _interopRequireDefault(__nccwpck_require__(72513));

var _cssnanoUtils = __nccwpck_require__(96947);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @author Ben Briggs
 * @license MIT
 * @module cssnano:preset:default
 * @overview
 *
 * This default preset for cssnano only includes transforms that make no
 * assumptions about your CSS other than what is passed in. In previous
 * iterations of cssnano, assumptions were made about your CSS which caused
 * output to look different in certain use cases, but not others. These
 * transforms have been moved from the defaults to other presets, to make
 * this preset require only minimal configuration.
 */
const defaultOpts = {
  convertValues: {
    length: false
  },
  normalizeCharset: {
    add: false
  },
  cssDeclarationSorter: {
    keepOverrides: true
  }
};

function defaultPreset(opts = {}) {
  const options = Object.assign({}, defaultOpts, opts);
  const plugins = [[_postcssDiscardComments.default, options.discardComments], [_postcssMinifyGradients.default, options.minifyGradients], [_postcssReduceInitial.default, options.reduceInitial], [_postcssSvgo.default, options.svgo], [_postcssNormalizeDisplayValues.default, options.normalizeDisplayValues], [_postcssReduceTransforms.default, options.reduceTransforms], [_postcssColormin.default, options.colormin], [_postcssNormalizeTimingFunctions.default, options.normalizeTimingFunctions], [_postcssCalc.default, options.calc], [_postcssConvertValues.default, options.convertValues], [_postcssOrderedValues.default, options.orderedValues], [_postcssMinifySelectors.default, options.minifySelectors], [_postcssMinifyParams.default, options.minifyParams], [_postcssNormalizeCharset.default, options.normalizeCharset], [_postcssDiscardOverridden.default, options.discardOverridden], [_postcssNormalizeString.default, options.normalizeString], [_postcssNormalizeUnicode.default, options.normalizeUnicode], [_postcssMinifyFontValues.default, options.minifyFontValues], [_postcssNormalizeUrl.default, options.normalizeUrl], [_postcssNormalizeRepeatStyle.default, options.normalizeRepeatStyle], [_postcssNormalizePositions.default, options.normalizePositions], [_postcssNormalizeWhitespace.default, options.normalizeWhitespace], [_postcssMergeLonghand.default, options.mergeLonghand], [_postcssDiscardDuplicates.default, options.discardDuplicates], [_postcssMergeRules.default, options.mergeRules], [_postcssDiscardEmpty.default, options.discardEmpty], [_postcssUniqueSelectors.default, options.uniqueSelectors], [_cssDeclarationSorter.default, options.cssDeclarationSorter], [_cssnanoUtils.rawCache, options.rawCache]];
  return {
    plugins
  };
}

module.exports = exports.default;

/***/ }),

/***/ 11035:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = getArguments;

function getArguments(node) {
  return node.nodes.reduce((list, child) => {
    if (child.type !== 'div') {
      list[list.length - 1].push(child);
    } else {
      list.push([]);
    }

    return list;
  }, [[]]);
}

module.exports = exports.default;

/***/ }),

/***/ 24692:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = getMatchFactory;

function getMatchFactory(map) {
  return function getMatch(args) {
    const match = args.reduce((list, arg, i) => {
      return list.filter(keyword => keyword[1][i] === arg);
    }, map);

    if (match.length) {
      return match[0][0];
    }

    return false;
  };
}

module.exports = exports.default;

/***/ }),

/***/ 96947:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "rawCache", ({
  enumerable: true,
  get: function () {
    return _rawCache.default;
  }
}));
Object.defineProperty(exports, "getMatch", ({
  enumerable: true,
  get: function () {
    return _getMatch.default;
  }
}));
Object.defineProperty(exports, "getArguments", ({
  enumerable: true,
  get: function () {
    return _getArguments.default;
  }
}));
Object.defineProperty(exports, "sameParent", ({
  enumerable: true,
  get: function () {
    return _sameParent.default;
  }
}));

var _rawCache = _interopRequireDefault(__nccwpck_require__(98824));

var _getMatch = _interopRequireDefault(__nccwpck_require__(24692));

var _getArguments = _interopRequireDefault(__nccwpck_require__(11035));

var _sameParent = _interopRequireDefault(__nccwpck_require__(7640));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 98824:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

const pluginCreator = () => {
  return {
    postcssPlugin: 'cssnano-util-raw-cache',

    OnceExit(css, {
      result
    }) {
      result.root.rawCache = {
        colon: ':',
        indent: '',
        beforeDecl: '',
        beforeRule: '',
        beforeOpen: '',
        beforeClose: '',
        beforeComment: '',
        after: '',
        emptyBody: '',
        commentLeft: '',
        commentRight: ''
      };
    }

  };
};

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 7640:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = sameParent;

/**
 * @param {postcss.ChildNode} nodeA
 * @param {postcss.ChildNode} nodeB
 * @return {boolean}
 */
function checkMatch(nodeA, nodeB) {
  if (nodeA.type === 'atrule' && nodeB.type === 'atrule') {
    return nodeA.params === nodeB.params && nodeA.name.toLowerCase() === nodeB.name.toLowerCase();
  }

  return nodeA.type === nodeB.type;
}
/**
 * @param {postcss.ChildNode} nodeA
 * @param {postcss.ChildNode} nodeB
 * @return {boolean}
 */


function sameParent(nodeA, nodeB) {
  if (!nodeA.parent) {
    // A is orphaned, return if B is orphaned as well
    return !nodeB.parent;
  }

  if (!nodeB.parent) {
    // B is orphaned and A is not
    return false;
  } // Check if parents match


  if (!checkMatch(nodeA.parent, nodeB.parent)) {
    return false;
  } // Check parents' parents


  return sameParent(nodeA.parent, nodeB.parent);
}

module.exports = exports.default;

/***/ }),

/***/ 8313:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _path = _interopRequireDefault(__nccwpck_require__(85622));

var _postcss = _interopRequireDefault(__nccwpck_require__(77001));

var _yaml = _interopRequireDefault(__nccwpck_require__(13552));

var _lilconfig = __nccwpck_require__(73727);

var _isResolvable = _interopRequireDefault(__nccwpck_require__(80922));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const cssnano = 'cssnano';
/*
 * preset can be one of four possibilities:
 * preset = 'default'
 * preset = ['default', {}]
 * preset = function <- to be invoked
 * preset = {plugins: []} <- already invoked function
 */

function resolvePreset(preset) {
  let fn, options;

  if (Array.isArray(preset)) {
    fn = preset[0];
    options = preset[1];
  } else {
    fn = preset;
    options = {};
  } // For JS setups where we invoked the preset already


  if (preset.plugins) {
    return preset.plugins;
  } // Provide an alias for the default preset, as it is built-in.


  if (fn === 'default') {
    return __nccwpck_require__(64524)(options).plugins;
  } // For non-JS setups; we'll need to invoke the preset ourselves.


  if (typeof fn === 'function') {
    return fn(options).plugins;
  } // Try loading a preset from node_modules


  if ((0, _isResolvable.default)(fn)) {
    return require(fn)(options).plugins;
  }

  const sugar = `cssnano-preset-${fn}`; // Try loading a preset from node_modules (sugar)

  if ((0, _isResolvable.default)(sugar)) {
    return require(sugar)(options).plugins;
  } // If all else fails, we probably have a typo in the config somewhere


  throw new Error(`Cannot load preset "${fn}". Please check your configuration for errors and try again.`);
}
/*
 * cssnano will look for configuration firstly as options passed
 * directly to it, and failing this it will use lilconfig to
 * load an external file.
 */


function resolveConfig(options) {
  if (options.preset) {
    return resolvePreset(options.preset);
  }

  let searchPath = process.cwd();
  let configPath = null;

  if (options.configFile) {
    searchPath = null;
    configPath = _path.default.resolve(process.cwd(), options.configFile);
  }

  const configExplorer = (0, _lilconfig.lilconfigSync)(cssnano, {
    searchPlaces: ['package.json', '.cssnanorc', '.cssnanorc.json', '.cssnanorc.yaml', '.cssnanorc.yml', '.cssnanorc.js', 'cssnano.config.js'],
    loaders: {
      '.yaml': (filepath, content) => _yaml.default.parse(content),
      '.yml': (filepath, content) => _yaml.default.parse(content)
    }
  });
  const config = configPath ? configExplorer.load(configPath) : configExplorer.search(searchPath);

  if (config === null) {
    return resolvePreset('default');
  }

  return resolvePreset(config.config.preset || config.config);
}

const cssnanoPlugin = (options = {}) => {
  if (Array.isArray(options.plugins)) {
    if (!options.preset || !options.preset.plugins) {
      options.preset = {
        plugins: []
      };
    }

    options.plugins.forEach(plugin => {
      if (Array.isArray(plugin)) {
        const [pluginDef, opts = {}] = plugin;

        if (typeof pluginDef === 'string' && (0, _isResolvable.default)(pluginDef)) {
          options.preset.plugins.push([require(pluginDef), opts]);
        } else {
          options.preset.plugins.push([pluginDef, opts]);
        }
      } else if (typeof plugin === 'string' && (0, _isResolvable.default)(plugin)) {
        options.preset.plugins.push([require(plugin), {}]);
      } else {
        options.preset.plugins.push([plugin, {}]);
      }
    });
  }

  const plugins = [];
  const nanoPlugins = resolveConfig(options);

  for (const nanoPlugin of nanoPlugins) {
    if (Array.isArray(nanoPlugin)) {
      const [processor, opts] = nanoPlugin;

      if (typeof opts === 'undefined' || typeof opts === 'object' && !opts.exclude || typeof opts === 'boolean' && opts === true) {
        plugins.push(processor(opts));
      }
    } else {
      plugins.push(nanoPlugin);
    }
  }

  return (0, _postcss.default)(plugins);
};

cssnanoPlugin.postcss = true;
var _default = cssnanoPlugin;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 51518:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var resolveKeyword = __nccwpck_require__(65035).keyword;
var { hasNoChildren } = __nccwpck_require__(65721);

module.exports = function cleanAtrule(node, item, list) {
    if (node.block) {
        // otherwise removed at-rule don't prevent @import for removal
        if (this.stylesheet !== null) {
            this.stylesheet.firstAtrulesAllowed = false;
        }

        if (hasNoChildren(node.block)) {
            list.remove(item);
            return;
        }
    }

    switch (node.name) {
        case 'charset':
            if (hasNoChildren(node.prelude)) {
                list.remove(item);
                return;
            }

            // if there is any rule before @charset -> remove it
            if (item.prev) {
                list.remove(item);
                return;
            }

            break;

        case 'import':
            if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
                list.remove(item);
                return;
            }

            // if there are some rules that not an @import or @charset before @import
            // remove it
            list.prevUntil(item.prev, function(rule) {
                if (rule.type === 'Atrule') {
                    if (rule.name === 'import' || rule.name === 'charset') {
                        return;
                    }
                }

                this.root.firstAtrulesAllowed = false;
                list.remove(item);
                return true;
            }, this);

            break;

        default:
            var name = resolveKeyword(node.name).basename;
            if (name === 'keyframes' ||
                name === 'media' ||
                name === 'supports') {

                // drop at-rule with no prelude
                if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
                    list.remove(item);
                }
            }
    }
};


/***/ }),

/***/ 78344:
/***/ ((module) => {

module.exports = function cleanComment(data, item, list) {
    list.remove(item);
};


/***/ }),

/***/ 51572:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var property = __nccwpck_require__(65035).property;

module.exports = function cleanDeclartion(node, item, list) {
    if (node.value.children && node.value.children.isEmpty()) {
        list.remove(item);
        return;
    }

    if (property(node.property).custom) {
        if (/\S/.test(node.value.value)) {
            node.value.value = node.value.value.trim();
        }
    }
};


/***/ }),

/***/ 29358:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var { isNodeChildrenList } = __nccwpck_require__(65721);

module.exports = function cleanRaw(node, item, list) {
    // raw in stylesheet or block children
    if (isNodeChildrenList(this.stylesheet, list) ||
        isNodeChildrenList(this.block, list)) {
        list.remove(item);
    }
};


/***/ }),

/***/ 65915:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var hasOwnProperty = Object.prototype.hasOwnProperty;
var walk = __nccwpck_require__(65035).walk;
var { hasNoChildren } = __nccwpck_require__(65721);

function cleanUnused(selectorList, usageData) {
    selectorList.children.each(function(selector, item, list) {
        var shouldRemove = false;

        walk(selector, function(node) {
            // ignore nodes in nested selectors
            if (this.selector === null || this.selector === selectorList) {
                switch (node.type) {
                    case 'SelectorList':
                        // TODO: remove toLowerCase when pseudo selectors will be normalized
                        // ignore selectors inside :not()
                        if (this.function === null || this.function.name.toLowerCase() !== 'not') {
                            if (cleanUnused(node, usageData)) {
                                shouldRemove = true;
                            }
                        }
                        break;

                    case 'ClassSelector':
                        if (usageData.whitelist !== null &&
                            usageData.whitelist.classes !== null &&
                            !hasOwnProperty.call(usageData.whitelist.classes, node.name)) {
                            shouldRemove = true;
                        }
                        if (usageData.blacklist !== null &&
                            usageData.blacklist.classes !== null &&
                            hasOwnProperty.call(usageData.blacklist.classes, node.name)) {
                            shouldRemove = true;
                        }
                        break;

                    case 'IdSelector':
                        if (usageData.whitelist !== null &&
                            usageData.whitelist.ids !== null &&
                            !hasOwnProperty.call(usageData.whitelist.ids, node.name)) {
                            shouldRemove = true;
                        }
                        if (usageData.blacklist !== null &&
                            usageData.blacklist.ids !== null &&
                            hasOwnProperty.call(usageData.blacklist.ids, node.name)) {
                            shouldRemove = true;
                        }
                        break;

                    case 'TypeSelector':
                        // TODO: remove toLowerCase when type selectors will be normalized
                        // ignore universal selectors
                        if (node.name.charAt(node.name.length - 1) !== '*') {
                            if (usageData.whitelist !== null &&
                                usageData.whitelist.tags !== null &&
                                !hasOwnProperty.call(usageData.whitelist.tags, node.name.toLowerCase())) {
                                shouldRemove = true;
                            }
                            if (usageData.blacklist !== null &&
                                usageData.blacklist.tags !== null &&
                                hasOwnProperty.call(usageData.blacklist.tags, node.name.toLowerCase())) {
                                shouldRemove = true;
                            }
                        }
                        break;
                }
            }
        });

        if (shouldRemove) {
            list.remove(item);
        }
    });

    return selectorList.children.isEmpty();
}

module.exports = function cleanRule(node, item, list, options) {
    if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
        list.remove(item);
        return;
    }

    var usageData = options.usage;

    if (usageData && (usageData.whitelist !== null || usageData.blacklist !== null)) {
        cleanUnused(node.prelude, usageData);

        if (hasNoChildren(node.prelude)) {
            list.remove(item);
            return;
        }
    }
};


/***/ }),

/***/ 54212:
/***/ ((module) => {

// remove useless universal selector
module.exports = function cleanTypeSelector(node, item, list) {
    var name = item.data.name;

    // check it's a non-namespaced universal selector
    if (name !== '*') {
        return;
    }

    // remove when universal selector before other selectors
    var nextType = item.next && item.next.data.type;
    if (nextType === 'IdSelector' ||
        nextType === 'ClassSelector' ||
        nextType === 'AttributeSelector' ||
        nextType === 'PseudoClassSelector' ||
        nextType === 'PseudoElementSelector') {
        list.remove(item);
    }
};


/***/ }),

/***/ 74382:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var { isNodeChildrenList } = __nccwpck_require__(65721);

function isSafeOperator(node) {
    return node.type === 'Operator' && node.value !== '+' && node.value !== '-';
}

module.exports = function cleanWhitespace(node, item, list) {
    // remove when first or last item in sequence
    if (item.next === null || item.prev === null) {
        list.remove(item);
        return;
    }

    // white space in stylesheet or block children
    if (isNodeChildrenList(this.stylesheet, list) ||
        isNodeChildrenList(this.block, list)) {
        list.remove(item);
        return;
    }

    if (item.next.data.type === 'WhiteSpace') {
        list.remove(item);
        return;
    }

    if (isSafeOperator(item.prev.data) || isSafeOperator(item.next.data)) {
        list.remove(item);
        return;
    }
};


/***/ }),

/***/ 29553:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var walk = __nccwpck_require__(65035).walk;
var handlers = {
    Atrule: __nccwpck_require__(51518),
    Comment: __nccwpck_require__(78344),
    Declaration: __nccwpck_require__(51572),
    Raw: __nccwpck_require__(29358),
    Rule: __nccwpck_require__(65915),
    TypeSelector: __nccwpck_require__(54212),
    WhiteSpace: __nccwpck_require__(74382)
};

module.exports = function(ast, options) {
    walk(ast, {
        leave: function(node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
                handlers[node.type].call(this, node, item, list, options);
            }
        }
    });
};


/***/ }),

/***/ 65721:
/***/ ((module) => {

module.exports = {
    hasNoChildren: function(node) {
        return !node || !node.children || node.children.isEmpty();
    },
    isNodeChildrenList: function(node, list) {
        return node !== null && node.children === list;
    }
};


/***/ }),

/***/ 88637:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var List = __nccwpck_require__(65035).List;
var clone = __nccwpck_require__(65035).clone;
var usageUtils = __nccwpck_require__(29863);
var clean = __nccwpck_require__(29553);
var replace = __nccwpck_require__(57602);
var restructure = __nccwpck_require__(59029);
var walk = __nccwpck_require__(65035).walk;

function readChunk(children, specialComments) {
    var buffer = new List();
    var nonSpaceTokenInBuffer = false;
    var protectedComment;

    children.nextUntil(children.head, function(node, item, list) {
        if (node.type === 'Comment') {
            if (!specialComments || node.value.charAt(0) !== '!') {
                list.remove(item);
                return;
            }

            if (nonSpaceTokenInBuffer || protectedComment) {
                return true;
            }

            list.remove(item);
            protectedComment = node;
            return;
        }

        if (node.type !== 'WhiteSpace') {
            nonSpaceTokenInBuffer = true;
        }

        buffer.insert(list.remove(item));
    });

    return {
        comment: protectedComment,
        stylesheet: {
            type: 'StyleSheet',
            loc: null,
            children: buffer
        }
    };
}

function compressChunk(ast, firstAtrulesAllowed, num, options) {
    options.logger('Compress block #' + num, null, true);

    var seed = 1;

    if (ast.type === 'StyleSheet') {
        ast.firstAtrulesAllowed = firstAtrulesAllowed;
        ast.id = seed++;
    }

    walk(ast, {
        visit: 'Atrule',
        enter: function markScopes(node) {
            if (node.block !== null) {
                node.block.id = seed++;
            }
        }
    });
    options.logger('init', ast);

    // remove redundant
    clean(ast, options);
    options.logger('clean', ast);

    // replace nodes for shortened forms
    replace(ast, options);
    options.logger('replace', ast);

    // structure optimisations
    if (options.restructuring) {
        restructure(ast, options);
    }

    return ast;
}

function getCommentsOption(options) {
    var comments = 'comments' in options ? options.comments : 'exclamation';

    if (typeof comments === 'boolean') {
        comments = comments ? 'exclamation' : false;
    } else if (comments !== 'exclamation' && comments !== 'first-exclamation') {
        comments = false;
    }

    return comments;
}

function getRestructureOption(options) {
    if ('restructure' in options) {
        return options.restructure;
    }

    return 'restructuring' in options ? options.restructuring : true;
}

function wrapBlock(block) {
    return new List().appendData({
        type: 'Rule',
        loc: null,
        prelude: {
            type: 'SelectorList',
            loc: null,
            children: new List().appendData({
                type: 'Selector',
                loc: null,
                children: new List().appendData({
                    type: 'TypeSelector',
                    loc: null,
                    name: 'x'
                })
            })
        },
        block: block
    });
}

module.exports = function compress(ast, options) {
    ast = ast || { type: 'StyleSheet', loc: null, children: new List() };
    options = options || {};

    var compressOptions = {
        logger: typeof options.logger === 'function' ? options.logger : function() {},
        restructuring: getRestructureOption(options),
        forceMediaMerge: Boolean(options.forceMediaMerge),
        usage: options.usage ? usageUtils.buildIndex(options.usage) : false
    };
    var specialComments = getCommentsOption(options);
    var firstAtrulesAllowed = true;
    var input;
    var output = new List();
    var chunk;
    var chunkNum = 1;
    var chunkChildren;

    if (options.clone) {
        ast = clone(ast);
    }

    if (ast.type === 'StyleSheet') {
        input = ast.children;
        ast.children = output;
    } else {
        input = wrapBlock(ast);
    }

    do {
        chunk = readChunk(input, Boolean(specialComments));
        compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
        chunkChildren = chunk.stylesheet.children;

        if (chunk.comment) {
            // add \n before comment if there is another content in output
            if (!output.isEmpty()) {
                output.insert(List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }

            output.insert(List.createItem(chunk.comment));

            // add \n after comment if chunk is not empty
            if (!chunkChildren.isEmpty()) {
                output.insert(List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }
        }

        if (firstAtrulesAllowed && !chunkChildren.isEmpty()) {
            var lastRule = chunkChildren.last();

            if (lastRule.type !== 'Atrule' ||
               (lastRule.name !== 'import' && lastRule.name !== 'charset')) {
                firstAtrulesAllowed = false;
            }
        }

        if (specialComments !== 'exclamation') {
            specialComments = false;
        }

        output.appendList(chunkChildren);
    } while (!input.isEmpty());

    return {
        ast: ast
    };
};


/***/ }),

/***/ 21811:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var csstree = __nccwpck_require__(65035);
var parse = csstree.parse;
var compress = __nccwpck_require__(88637);
var generate = csstree.generate;

function debugOutput(name, options, startTime, data) {
    if (options.debug) {
        console.error('## ' + name + ' done in %d ms\n', Date.now() - startTime);
    }

    return data;
}

function createDefaultLogger(level) {
    var lastDebug;

    return function logger(title, ast) {
        var line = title;

        if (ast) {
            line = '[' + ((Date.now() - lastDebug) / 1000).toFixed(3) + 's] ' + line;
        }

        if (level > 1 && ast) {
            var css = generate(ast);

            // when level 2, limit css to 256 symbols
            if (level === 2 && css.length > 256) {
                css = css.substr(0, 256) + '...';
            }

            line += '\n  ' + css + '\n';
        }

        console.error(line);
        lastDebug = Date.now();
    };
}

function copy(obj) {
    var result = {};

    for (var key in obj) {
        result[key] = obj[key];
    }

    return result;
}

function buildCompressOptions(options) {
    options = copy(options);

    if (typeof options.logger !== 'function' && options.debug) {
        options.logger = createDefaultLogger(options.debug);
    }

    return options;
}

function runHandler(ast, options, handlers) {
    if (!Array.isArray(handlers)) {
        handlers = [handlers];
    }

    handlers.forEach(function(fn) {
        fn(ast, options);
    });
}

function minify(context, source, options) {
    options = options || {};

    var filename = options.filename || '<unknown>';
    var result;

    // parse
    var ast = debugOutput('parsing', options, Date.now(),
        parse(source, {
            context: context,
            filename: filename,
            positions: Boolean(options.sourceMap)
        })
    );

    // before compress handlers
    if (options.beforeCompress) {
        debugOutput('beforeCompress', options, Date.now(),
            runHandler(ast, options, options.beforeCompress)
        );
    }

    // compress
    var compressResult = debugOutput('compress', options, Date.now(),
        compress(ast, buildCompressOptions(options))
    );

    // after compress handlers
    if (options.afterCompress) {
        debugOutput('afterCompress', options, Date.now(),
            runHandler(compressResult, options, options.afterCompress)
        );
    }

    // generate
    if (options.sourceMap) {
        result = debugOutput('generate(sourceMap: true)', options, Date.now(), (function() {
            var tmp = generate(compressResult.ast, { sourceMap: true });
            tmp.map._file = filename; // since other tools can relay on file in source map transform chain
            tmp.map.setSourceContent(filename, source);
            return tmp;
        }()));
    } else {
        result = debugOutput('generate', options, Date.now(), {
            css: generate(compressResult.ast),
            map: null
        });
    }

    return result;
}

function minifyStylesheet(source, options) {
    return minify('stylesheet', source, options);
}

function minifyBlock(source, options) {
    return minify('declarationList', source, options);
}

module.exports = {
    version: __nccwpck_require__(96127)/* .version */ .i8,

    // main methods
    minify: minifyStylesheet,
    minifyBlock: minifyBlock,

    // css syntax parser/walkers/generator/etc
    syntax: Object.assign({
        compress: compress
    }, csstree)
};


/***/ }),

/***/ 17460:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var resolveKeyword = __nccwpck_require__(65035).keyword;
var compressKeyframes = __nccwpck_require__(15539);

module.exports = function(node) {
    // compress @keyframe selectors
    if (resolveKeyword(node.name).basename === 'keyframes') {
        compressKeyframes(node);
    }
};


/***/ }),

/***/ 95389:
/***/ ((module) => {

// Can unquote attribute detection
// Adopted implementation of Mathias Bynens
// https://github.com/mathiasbynens/mothereff.in/blob/master/unquoted-attributes/eff.js
var escapesRx = /\\([0-9A-Fa-f]{1,6})(\r\n|[ \t\n\f\r])?|\\./g;
var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

function canUnquote(value) {
    if (value === '' || value === '-') {
        return;
    }

    // Escapes are valid, so replace them with a valid non-empty string
    value = value.replace(escapesRx, 'a');

    return !blockUnquoteRx.test(value);
}

module.exports = function(node) {
    var attrValue = node.value;

    if (!attrValue || attrValue.type !== 'String') {
        return;
    }

    var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, '$2');
    if (canUnquote(unquotedValue)) {
        node.value = {
            type: 'Identifier',
            loc: attrValue.loc,
            name: unquotedValue
        };
    }
};


/***/ }),

/***/ 4770:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var packNumber = __nccwpck_require__(42334).pack;
var MATH_FUNCTIONS = {
    'calc': true,
    'min': true,
    'max': true,
    'clamp': true
};
var LENGTH_UNIT = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

module.exports = function compressDimension(node, item) {
    var value = packNumber(node.value, item);

    node.value = value;

    if (value === '0' && this.declaration !== null && this.atrulePrelude === null) {
        var unit = node.unit.toLowerCase();

        // only length values can be compressed
        if (!LENGTH_UNIT.hasOwnProperty(unit)) {
            return;
        }

        // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
        // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
        if (this.declaration.property === '-ms-flex' ||
            this.declaration.property === 'flex') {
            return;
        }

        // issue #222: don't remove units inside calc
        if (this.function && MATH_FUNCTIONS.hasOwnProperty(this.function.name)) {
            return;
        }

        item.data = {
            type: 'Number',
            loc: node.loc,
            value: value
        };
    }
};


/***/ }),

/***/ 42334:
/***/ ((module) => {

var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
var unsafeToRemovePlusSignAfter = {
    Dimension: true,
    Hash: true,
    Identifier: true,
    Number: true,
    Raw: true,
    UnicodeRange: true
};

function packNumber(value, item) {
    // omit plus sign only if no prev or prev is safe type
    var regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.hasOwnProperty(item.prev.data.type)
        ? KEEP_PLUSSIGN
        : OMIT_PLUSSIGN;

    // 100 -> '100'
    // 00100 -> '100'
    // +100 -> '100' (only when safe, e.g. omitting plus sign for 1px+1px leads to single dimension instead of two)
    // -100 -> '-100'
    // 0.123 -> '.123'
    // 0.12300 -> '.123'
    // 0.0 -> ''
    // 0 -> ''
    // -0 -> '-'
    value = String(value).replace(regexp, '$1$2$3');

    if (value === '' || value === '-') {
        value = '0';
    }

    return value;
}

module.exports = function(node, item) {
    node.value = packNumber(node.value, item);
};
module.exports.pack = packNumber;


/***/ }),

/***/ 96215:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var lexer = __nccwpck_require__(65035).lexer;
var packNumber = __nccwpck_require__(42334).pack;
var blacklist = new Set([
    // see https://github.com/jakubpawlowicz/clean-css/issues/957
    'width',
    'min-width',
    'max-width',
    'height',
    'min-height',
    'max-height',

    // issue #410: Dont remove units in flex-basis value for (-ms-)flex shorthand
    // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
    // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
    'flex',
    '-ms-flex'
]);

module.exports = function compressPercentage(node, item) {
    node.value = packNumber(node.value, item);

    if (node.value === '0' && this.declaration && !blacklist.has(this.declaration.property)) {
        // try to convert a number
        item.data = {
            type: 'Number',
            loc: node.loc,
            value: node.value
        };

        // that's ok only when new value matches on length
        if (!lexer.matchDeclaration(this.declaration).isType(item.data, 'length')) {
            // otherwise rollback changes
            item.data = node;
        }
    }
};


/***/ }),

/***/ 96407:
/***/ ((module) => {

module.exports = function(node) {
    var value = node.value;

    // remove escaped newlines, i.e.
    // .a { content: "foo\
    // bar"}
    // ->
    // .a { content: "foobar" }
    value = value.replace(/\\(\r\n|\r|\n|\f)/g, '');

    node.value = value;
};


/***/ }),

/***/ 59176:
/***/ ((module) => {

var UNICODE = '\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?';
var ESCAPE = '(' + UNICODE + '|\\\\[^\\n\\r\\f0-9a-fA-F])';
var NONPRINTABLE = '\u0000\u0008\u000b\u000e-\u001f\u007f';
var SAFE_URL = new RegExp('^(' + ESCAPE + '|[^\"\'\\(\\)\\\\\\s' + NONPRINTABLE + '])*$', 'i');

module.exports = function(node) {
    var value = node.value;

    if (value.type !== 'String') {
        return;
    }

    var quote = value.value[0];
    var url = value.value.substr(1, value.value.length - 2);

    // convert `\\` to `/`
    url = url.replace(/\\\\/g, '/');

    // remove quotes when safe
    // https://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram
    if (SAFE_URL.test(url)) {
        node.value = {
            type: 'Raw',
            loc: node.value.loc,
            value: url
        };
    } else {
        // use double quotes if string has no double quotes
        // otherwise use original quotes
        // TODO: make better quote type selection
        node.value.value = url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
    }
};


/***/ }),

/***/ 66786:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var resolveName = __nccwpck_require__(65035).property;
var handlers = {
    'font': __nccwpck_require__(99479),
    'font-weight': __nccwpck_require__(79997),
    'background': __nccwpck_require__(92239),
    'border': __nccwpck_require__(96346),
    'outline': __nccwpck_require__(96346)
};

module.exports = function compressValue(node) {
    if (!this.declaration) {
        return;
    }

    var property = resolveName(this.declaration.property);

    if (handlers.hasOwnProperty(property.basename)) {
        handlers[property.basename](node);
    }
};


/***/ }),

/***/ 15539:
/***/ ((module) => {

module.exports = function(node) {
    node.block.children.each(function(rule) {
        rule.prelude.children.each(function(simpleselector) {
            simpleselector.children.each(function(data, item) {
                if (data.type === 'Percentage' && data.value === '100') {
                    item.data = {
                        type: 'TypeSelector',
                        loc: data.loc,
                        name: 'to'
                    };
                } else if (data.type === 'TypeSelector' && data.name === 'from') {
                    item.data = {
                        type: 'Percentage',
                        loc: data.loc,
                        value: '0'
                    };
                }
            });
        });
    });
};


/***/ }),

/***/ 16625:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var lexer = __nccwpck_require__(65035).lexer;
var packNumber = __nccwpck_require__(42334).pack;

// http://www.w3.org/TR/css3-color/#svg-color
var NAME_TO_HEX = {
    'aliceblue': 'f0f8ff',
    'antiquewhite': 'faebd7',
    'aqua': '0ff',
    'aquamarine': '7fffd4',
    'azure': 'f0ffff',
    'beige': 'f5f5dc',
    'bisque': 'ffe4c4',
    'black': '000',
    'blanchedalmond': 'ffebcd',
    'blue': '00f',
    'blueviolet': '8a2be2',
    'brown': 'a52a2a',
    'burlywood': 'deb887',
    'cadetblue': '5f9ea0',
    'chartreuse': '7fff00',
    'chocolate': 'd2691e',
    'coral': 'ff7f50',
    'cornflowerblue': '6495ed',
    'cornsilk': 'fff8dc',
    'crimson': 'dc143c',
    'cyan': '0ff',
    'darkblue': '00008b',
    'darkcyan': '008b8b',
    'darkgoldenrod': 'b8860b',
    'darkgray': 'a9a9a9',
    'darkgrey': 'a9a9a9',
    'darkgreen': '006400',
    'darkkhaki': 'bdb76b',
    'darkmagenta': '8b008b',
    'darkolivegreen': '556b2f',
    'darkorange': 'ff8c00',
    'darkorchid': '9932cc',
    'darkred': '8b0000',
    'darksalmon': 'e9967a',
    'darkseagreen': '8fbc8f',
    'darkslateblue': '483d8b',
    'darkslategray': '2f4f4f',
    'darkslategrey': '2f4f4f',
    'darkturquoise': '00ced1',
    'darkviolet': '9400d3',
    'deeppink': 'ff1493',
    'deepskyblue': '00bfff',
    'dimgray': '696969',
    'dimgrey': '696969',
    'dodgerblue': '1e90ff',
    'firebrick': 'b22222',
    'floralwhite': 'fffaf0',
    'forestgreen': '228b22',
    'fuchsia': 'f0f',
    'gainsboro': 'dcdcdc',
    'ghostwhite': 'f8f8ff',
    'gold': 'ffd700',
    'goldenrod': 'daa520',
    'gray': '808080',
    'grey': '808080',
    'green': '008000',
    'greenyellow': 'adff2f',
    'honeydew': 'f0fff0',
    'hotpink': 'ff69b4',
    'indianred': 'cd5c5c',
    'indigo': '4b0082',
    'ivory': 'fffff0',
    'khaki': 'f0e68c',
    'lavender': 'e6e6fa',
    'lavenderblush': 'fff0f5',
    'lawngreen': '7cfc00',
    'lemonchiffon': 'fffacd',
    'lightblue': 'add8e6',
    'lightcoral': 'f08080',
    'lightcyan': 'e0ffff',
    'lightgoldenrodyellow': 'fafad2',
    'lightgray': 'd3d3d3',
    'lightgrey': 'd3d3d3',
    'lightgreen': '90ee90',
    'lightpink': 'ffb6c1',
    'lightsalmon': 'ffa07a',
    'lightseagreen': '20b2aa',
    'lightskyblue': '87cefa',
    'lightslategray': '789',
    'lightslategrey': '789',
    'lightsteelblue': 'b0c4de',
    'lightyellow': 'ffffe0',
    'lime': '0f0',
    'limegreen': '32cd32',
    'linen': 'faf0e6',
    'magenta': 'f0f',
    'maroon': '800000',
    'mediumaquamarine': '66cdaa',
    'mediumblue': '0000cd',
    'mediumorchid': 'ba55d3',
    'mediumpurple': '9370db',
    'mediumseagreen': '3cb371',
    'mediumslateblue': '7b68ee',
    'mediumspringgreen': '00fa9a',
    'mediumturquoise': '48d1cc',
    'mediumvioletred': 'c71585',
    'midnightblue': '191970',
    'mintcream': 'f5fffa',
    'mistyrose': 'ffe4e1',
    'moccasin': 'ffe4b5',
    'navajowhite': 'ffdead',
    'navy': '000080',
    'oldlace': 'fdf5e6',
    'olive': '808000',
    'olivedrab': '6b8e23',
    'orange': 'ffa500',
    'orangered': 'ff4500',
    'orchid': 'da70d6',
    'palegoldenrod': 'eee8aa',
    'palegreen': '98fb98',
    'paleturquoise': 'afeeee',
    'palevioletred': 'db7093',
    'papayawhip': 'ffefd5',
    'peachpuff': 'ffdab9',
    'peru': 'cd853f',
    'pink': 'ffc0cb',
    'plum': 'dda0dd',
    'powderblue': 'b0e0e6',
    'purple': '800080',
    'rebeccapurple': '639',
    'red': 'f00',
    'rosybrown': 'bc8f8f',
    'royalblue': '4169e1',
    'saddlebrown': '8b4513',
    'salmon': 'fa8072',
    'sandybrown': 'f4a460',
    'seagreen': '2e8b57',
    'seashell': 'fff5ee',
    'sienna': 'a0522d',
    'silver': 'c0c0c0',
    'skyblue': '87ceeb',
    'slateblue': '6a5acd',
    'slategray': '708090',
    'slategrey': '708090',
    'snow': 'fffafa',
    'springgreen': '00ff7f',
    'steelblue': '4682b4',
    'tan': 'd2b48c',
    'teal': '008080',
    'thistle': 'd8bfd8',
    'tomato': 'ff6347',
    'turquoise': '40e0d0',
    'violet': 'ee82ee',
    'wheat': 'f5deb3',
    'white': 'fff',
    'whitesmoke': 'f5f5f5',
    'yellow': 'ff0',
    'yellowgreen': '9acd32'
};

var HEX_TO_NAME = {
    '800000': 'maroon',
    '800080': 'purple',
    '808000': 'olive',
    '808080': 'gray',
    '00ffff': 'cyan',
    'f0ffff': 'azure',
    'f5f5dc': 'beige',
    'ffe4c4': 'bisque',
    '000000': 'black',
    '0000ff': 'blue',
    'a52a2a': 'brown',
    'ff7f50': 'coral',
    'ffd700': 'gold',
    '008000': 'green',
    '4b0082': 'indigo',
    'fffff0': 'ivory',
    'f0e68c': 'khaki',
    '00ff00': 'lime',
    'faf0e6': 'linen',
    '000080': 'navy',
    'ffa500': 'orange',
    'da70d6': 'orchid',
    'cd853f': 'peru',
    'ffc0cb': 'pink',
    'dda0dd': 'plum',
    'f00': 'red',
    'ff0000': 'red',
    'fa8072': 'salmon',
    'a0522d': 'sienna',
    'c0c0c0': 'silver',
    'fffafa': 'snow',
    'd2b48c': 'tan',
    '008080': 'teal',
    'ff6347': 'tomato',
    'ee82ee': 'violet',
    'f5deb3': 'wheat',
    'ffffff': 'white',
    'ffff00': 'yellow'
};

function hueToRgb(p, q, t) {
    if (t < 0) {
        t += 1;
    }
    if (t > 1) {
        t -= 1;
    }
    if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
        return q;
    }
    if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
}

function hslToRgb(h, s, l, a) {
    var r;
    var g;
    var b;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
    }

    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        a
    ];
}

function toHex(value) {
    value = value.toString(16);
    return value.length === 1 ? '0' + value : value;
}

function parseFunctionArgs(functionArgs, count, rgb) {
    var cursor = functionArgs.head;
    var args = [];
    var wasValue = false;

    while (cursor !== null) {
        var node = cursor.data;
        var type = node.type;

        switch (type) {
            case 'Number':
            case 'Percentage':
                if (wasValue) {
                    return;
                }

                wasValue = true;
                args.push({
                    type: type,
                    value: Number(node.value)
                });
                break;

            case 'Operator':
                if (node.value === ',') {
                    if (!wasValue) {
                        return;
                    }
                    wasValue = false;
                } else if (wasValue || node.value !== '+') {
                    return;
                }
                break;

            default:
                // something we couldn't understand
                return;
        }

        cursor = cursor.next;
    }

    if (args.length !== count) {
        // invalid arguments count
        // TODO: remove those tokens
        return;
    }

    if (args.length === 4) {
        if (args[3].type !== 'Number') {
            // 4th argument should be a number
            // TODO: remove those tokens
            return;
        }

        args[3].type = 'Alpha';
    }

    if (rgb) {
        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
            // invalid color, numbers and percentage shouldn't be mixed
            // TODO: remove those tokens
            return;
        }
    } else {
        if (args[0].type !== 'Number' ||
            args[1].type !== 'Percentage' ||
            args[2].type !== 'Percentage') {
            // invalid color, for hsl values should be: number, percentage, percentage
            // TODO: remove those tokens
            return;
        }

        args[0].type = 'Angle';
    }

    return args.map(function(arg) {
        var value = Math.max(0, arg.value);

        switch (arg.type) {
            case 'Number':
                // fit value to [0..255] range
                value = Math.min(value, 255);
                break;

            case 'Percentage':
                // convert 0..100% to value in [0..255] range
                value = Math.min(value, 100) / 100;

                if (!rgb) {
                    return value;
                }

                value = 255 * value;
                break;

            case 'Angle':
                // fit value to (-360..360) range
                return (((value % 360) + 360) % 360) / 360;

            case 'Alpha':
                // fit value to [0..1] range
                return Math.min(value, 1);
        }

        return Math.round(value);
    });
}

function compressFunction(node, item, list) {
    var functionName = node.name;
    var args;

    if (functionName === 'rgba' || functionName === 'hsla') {
        args = parseFunctionArgs(node.children, 4, functionName === 'rgba');

        if (!args) {
            // something went wrong
            return;
        }

        if (functionName === 'hsla') {
            args = hslToRgb.apply(null, args);
            node.name = 'rgba';
        }

        if (args[3] === 0) {
            // try to replace `rgba(x, x, x, 0)` to `transparent`
            // always replace `rgba(0, 0, 0, 0)` to `transparent`
            // otherwise avoid replacement in gradients since it may break color transition
            // http://stackoverflow.com/questions/11829410/css3-gradient-rendering-issues-from-transparent-to-white
            var scopeFunctionName = this.function && this.function.name;
            if ((args[0] === 0 && args[1] === 0 && args[2] === 0) ||
                !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {

                item.data = {
                    type: 'Identifier',
                    loc: node.loc,
                    name: 'transparent'
                };

                return;
            }
        }

        if (args[3] !== 1) {
            // replace argument values for normalized/interpolated
            node.children.each(function(node, item, list) {
                if (node.type === 'Operator') {
                    if (node.value !== ',') {
                        list.remove(item);
                    }
                    return;
                }

                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: packNumber(args.shift(), null)
                };
            });

            return;
        }

        // otherwise convert to rgb, i.e. rgba(255, 0, 0, 1) -> rgb(255, 0, 0)
        functionName = 'rgb';
    }

    if (functionName === 'hsl') {
        args = args || parseFunctionArgs(node.children, 3, false);

        if (!args) {
            // something went wrong
            return;
        }

        // convert to rgb
        args = hslToRgb.apply(null, args);
        functionName = 'rgb';
    }

    if (functionName === 'rgb') {
        args = args || parseFunctionArgs(node.children, 3, true);

        if (!args) {
            // something went wrong
            return;
        }

        // check if color is not at the end and not followed by space
        var next = item.next;
        if (next && next.data.type !== 'WhiteSpace') {
            list.insert(list.createItem({
                type: 'WhiteSpace',
                value: ' '
            }), next);
        }

        item.data = {
            type: 'Hash',
            loc: node.loc,
            value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
        };

        compressHex(item.data, item);
    }
}

function compressIdent(node, item) {
    if (this.declaration === null) {
        return;
    }

    var color = node.name.toLowerCase();

    if (NAME_TO_HEX.hasOwnProperty(color) &&
        lexer.matchDeclaration(this.declaration).isType(node, 'color')) {
        var hex = NAME_TO_HEX[color];

        if (hex.length + 1 <= color.length) {
            // replace for shorter hex value
            item.data = {
                type: 'Hash',
                loc: node.loc,
                value: hex
            };
        } else {
            // special case for consistent colors
            if (color === 'grey') {
                color = 'gray';
            }

            // just replace value for lower cased name
            node.name = color;
        }
    }
}

function compressHex(node, item) {
    var color = node.value.toLowerCase();

    // #112233 -> #123
    if (color.length === 6 &&
        color[0] === color[1] &&
        color[2] === color[3] &&
        color[4] === color[5]) {
        color = color[0] + color[2] + color[4];
    }

    if (HEX_TO_NAME[color]) {
        item.data = {
            type: 'Identifier',
            loc: node.loc,
            name: HEX_TO_NAME[color]
        };
    } else {
        node.value = color;
    }
}

module.exports = {
    compressFunction: compressFunction,
    compressIdent: compressIdent,
    compressHex: compressHex
};


/***/ }),

/***/ 57602:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var walk = __nccwpck_require__(65035).walk;
var handlers = {
    Atrule: __nccwpck_require__(17460),
    AttributeSelector: __nccwpck_require__(95389),
    Value: __nccwpck_require__(66786),
    Dimension: __nccwpck_require__(4770),
    Percentage: __nccwpck_require__(96215),
    Number: __nccwpck_require__(42334),
    String: __nccwpck_require__(96407),
    Url: __nccwpck_require__(59176),
    Hash: __nccwpck_require__(16625).compressHex,
    Identifier: __nccwpck_require__(16625).compressIdent,
    Function: __nccwpck_require__(16625).compressFunction
};

module.exports = function(ast) {
    walk(ast, {
        leave: function(node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
                handlers[node.type].call(this, node, item, list);
            }
        }
    });
};


/***/ }),

/***/ 92239:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var List = __nccwpck_require__(65035).List;

module.exports = function compressBackground(node) {
    function lastType() {
        if (buffer.length) {
            return buffer[buffer.length - 1].type;
        }
    }

    function flush() {
        if (lastType() === 'WhiteSpace') {
            buffer.pop();
        }

        if (!buffer.length) {
            buffer.unshift(
                {
                    type: 'Number',
                    loc: null,
                    value: '0'
                },
                {
                    type: 'WhiteSpace',
                    value: ' '
                },
                {
                    type: 'Number',
                    loc: null,
                    value: '0'
                }
            );
        }

        newValue.push.apply(newValue, buffer);

        buffer = [];
    }

    var newValue = [];
    var buffer = [];

    node.children.each(function(node) {
        if (node.type === 'Operator' && node.value === ',') {
            flush();
            newValue.push(node);
            return;
        }

        // remove defaults
        if (node.type === 'Identifier') {
            if (node.name === 'transparent' ||
                node.name === 'none' ||
                node.name === 'repeat' ||
                node.name === 'scroll') {
                return;
            }
        }

        // don't add redundant spaces
        if (node.type === 'WhiteSpace' && (!buffer.length || lastType() === 'WhiteSpace')) {
            return;
        }

        buffer.push(node);
    });

    flush();
    node.children = new List().fromArray(newValue);
};


/***/ }),

/***/ 96346:
/***/ ((module) => {

function removeItemAndRedundantWhiteSpace(list, item) {
    var prev = item.prev;
    var next = item.next;

    if (next !== null) {
        if (next.data.type === 'WhiteSpace' && (prev === null || prev.data.type === 'WhiteSpace')) {
            list.remove(next);
        }
    } else if (prev !== null && prev.data.type === 'WhiteSpace') {
        list.remove(prev);
    }

    list.remove(item);
}

module.exports = function compressBorder(node) {
    node.children.each(function(node, item, list) {
        if (node.type === 'Identifier' && node.name.toLowerCase() === 'none') {
            if (list.head === list.tail) {
                // replace `none` for zero when `none` is a single term
                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: '0'
                };
            } else {
                removeItemAndRedundantWhiteSpace(list, item);
            }
        }
    });
};


/***/ }),

/***/ 79997:
/***/ ((module) => {

module.exports = function compressFontWeight(node) {
    var value = node.children.head.data;

    if (value.type === 'Identifier') {
        switch (value.name) {
            case 'normal':
                node.children.head.data = {
                    type: 'Number',
                    loc: value.loc,
                    value: '400'
                };
                break;
            case 'bold':
                node.children.head.data = {
                    type: 'Number',
                    loc: value.loc,
                    value: '700'
                };
                break;
        }
    }
};


/***/ }),

/***/ 99479:
/***/ ((module) => {

module.exports = function compressFont(node) {
    var list = node.children;

    list.eachRight(function(node, item) {
        if (node.type === 'Identifier') {
            if (node.name === 'bold') {
                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: '700'
                };
            } else if (node.name === 'normal') {
                var prev = item.prev;

                if (prev && prev.data.type === 'Operator' && prev.data.value === '/') {
                    this.remove(prev);
                }

                this.remove(item);
            } else if (node.name === 'medium') {
                var next = item.next;

                if (!next || next.data.type !== 'Operator') {
                    this.remove(item);
                }
            }
        }
    });

    // remove redundant spaces
    list.each(function(node, item) {
        if (node.type === 'WhiteSpace') {
            if (!item.prev || !item.next || item.next.data.type === 'WhiteSpace') {
                this.remove(item);
            }
        }
    });

    if (list.isEmpty()) {
        list.insert(list.createItem({
            type: 'Identifier',
            name: 'normal'
        }));
    }
};


/***/ }),

/***/ 76456:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var List = __nccwpck_require__(65035).List;
var resolveKeyword = __nccwpck_require__(65035).keyword;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var walk = __nccwpck_require__(65035).walk;

function addRuleToMap(map, item, list, single) {
    var node = item.data;
    var name = resolveKeyword(node.name).basename;
    var id = node.name.toLowerCase() + '/' + (node.prelude ? node.prelude.id : null);

    if (!hasOwnProperty.call(map, name)) {
        map[name] = Object.create(null);
    }

    if (single) {
        delete map[name][id];
    }

    if (!hasOwnProperty.call(map[name], id)) {
        map[name][id] = new List();
    }

    map[name][id].append(list.remove(item));
}

function relocateAtrules(ast, options) {
    var collected = Object.create(null);
    var topInjectPoint = null;

    ast.children.each(function(node, item, list) {
        if (node.type === 'Atrule') {
            var name = resolveKeyword(node.name).basename;

            switch (name) {
                case 'keyframes':
                    addRuleToMap(collected, item, list, true);
                    return;

                case 'media':
                    if (options.forceMediaMerge) {
                        addRuleToMap(collected, item, list, false);
                        return;
                    }
                    break;
            }

            if (topInjectPoint === null &&
                name !== 'charset' &&
                name !== 'import') {
                topInjectPoint = item;
            }
        } else {
            if (topInjectPoint === null) {
                topInjectPoint = item;
            }
        }
    });

    for (var atrule in collected) {
        for (var id in collected[atrule]) {
            ast.children.insertList(
                collected[atrule][id],
                atrule === 'media' ? null : topInjectPoint
            );
        }
    }
};

function isMediaRule(node) {
    return node.type === 'Atrule' && node.name === 'media';
}

function processAtrule(node, item, list) {
    if (!isMediaRule(node)) {
        return;
    }

    var prev = item.prev && item.prev.data;

    if (!prev || !isMediaRule(prev)) {
        return;
    }

    // merge @media with same query
    if (node.prelude &&
        prev.prelude &&
        node.prelude.id === prev.prelude.id) {
        prev.block.children.appendList(node.block.children);
        list.remove(item);

        // TODO: use it when we can refer to several points in source
        // prev.loc = {
        //     primary: prev.loc,
        //     merged: node.loc
        // };
    }
}

module.exports = function rejoinAtrule(ast, options) {
    relocateAtrules(ast, options);

    walk(ast, {
        visit: 'Atrule',
        reverse: true,
        enter: processAtrule
    });
};


/***/ }),

/***/ 34847:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var walk = __nccwpck_require__(65035).walk;
var utils = __nccwpck_require__(28011);

function processRule(node, item, list) {
    var selectors = node.prelude.children;
    var declarations = node.block.children;

    list.prevUntil(item.prev, function(prev) {
        // skip non-ruleset node if safe
        if (prev.type !== 'Rule') {
            return utils.unsafeToSkipNode.call(selectors, prev);
        }

        var prevSelectors = prev.prelude.children;
        var prevDeclarations = prev.block.children;

        // try to join rulesets with equal pseudo signature
        if (node.pseudoSignature === prev.pseudoSignature) {
            // try to join by selectors
            if (utils.isEqualSelectors(prevSelectors, selectors)) {
                prevDeclarations.appendList(declarations);
                list.remove(item);
                return true;
            }

            // try to join by declarations
            if (utils.isEqualDeclarations(declarations, prevDeclarations)) {
                utils.addSelectors(prevSelectors, selectors);
                list.remove(item);
                return true;
            }
        }

        // go to prev ruleset if has no selector similarities
        return utils.hasSimilarSelectors(selectors, prevSelectors);
    });
}

// NOTE: direction should be left to right, since rulesets merge to left
// ruleset. When direction right to left unmerged rulesets may prevent lookup
// TODO: remove initial merge
module.exports = function initialMergeRule(ast) {
    walk(ast, {
        visit: 'Rule',
        enter: processRule
    });
};


/***/ }),

/***/ 46624:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var List = __nccwpck_require__(65035).List;
var walk = __nccwpck_require__(65035).walk;

function processRule(node, item, list) {
    var selectors = node.prelude.children;

    // generate new rule sets:
    // .a, .b { color: red; }
    // ->
    // .a { color: red; }
    // .b { color: red; }

    // while there are more than 1 simple selector split for rulesets
    while (selectors.head !== selectors.tail) {
        var newSelectors = new List();
        newSelectors.insert(selectors.remove(selectors.head));

        list.insert(list.createItem({
            type: 'Rule',
            loc: node.loc,
            prelude: {
                type: 'SelectorList',
                loc: node.prelude.loc,
                children: newSelectors
            },
            block: {
                type: 'Block',
                loc: node.block.loc,
                children: node.block.children.copy()
            },
            pseudoSignature: node.pseudoSignature
        }), item);
    }
}

module.exports = function disjoinRule(ast) {
    walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter: processRule
    });
};


/***/ }),

/***/ 8563:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var List = __nccwpck_require__(65035).List;
var generate = __nccwpck_require__(65035).generate;
var walk = __nccwpck_require__(65035).walk;

var REPLACE = 1;
var REMOVE = 2;
var TOP = 0;
var RIGHT = 1;
var BOTTOM = 2;
var LEFT = 3;
var SIDES = ['top', 'right', 'bottom', 'left'];
var SIDE = {
    'margin-top': 'top',
    'margin-right': 'right',
    'margin-bottom': 'bottom',
    'margin-left': 'left',

    'padding-top': 'top',
    'padding-right': 'right',
    'padding-bottom': 'bottom',
    'padding-left': 'left',

    'border-top-color': 'top',
    'border-right-color': 'right',
    'border-bottom-color': 'bottom',
    'border-left-color': 'left',
    'border-top-width': 'top',
    'border-right-width': 'right',
    'border-bottom-width': 'bottom',
    'border-left-width': 'left',
    'border-top-style': 'top',
    'border-right-style': 'right',
    'border-bottom-style': 'bottom',
    'border-left-style': 'left'
};
var MAIN_PROPERTY = {
    'margin': 'margin',
    'margin-top': 'margin',
    'margin-right': 'margin',
    'margin-bottom': 'margin',
    'margin-left': 'margin',

    'padding': 'padding',
    'padding-top': 'padding',
    'padding-right': 'padding',
    'padding-bottom': 'padding',
    'padding-left': 'padding',

    'border-color': 'border-color',
    'border-top-color': 'border-color',
    'border-right-color': 'border-color',
    'border-bottom-color': 'border-color',
    'border-left-color': 'border-color',
    'border-width': 'border-width',
    'border-top-width': 'border-width',
    'border-right-width': 'border-width',
    'border-bottom-width': 'border-width',
    'border-left-width': 'border-width',
    'border-style': 'border-style',
    'border-top-style': 'border-style',
    'border-right-style': 'border-style',
    'border-bottom-style': 'border-style',
    'border-left-style': 'border-style'
};

function TRBL(name) {
    this.name = name;
    this.loc = null;
    this.iehack = undefined;
    this.sides = {
        'top': null,
        'right': null,
        'bottom': null,
        'left': null
    };
}

TRBL.prototype.getValueSequence = function(declaration, count) {
    var values = [];
    var iehack = '';
    var hasBadValues = declaration.value.type !== 'Value' || declaration.value.children.some(function(child) {
        var special = false;

        switch (child.type) {
            case 'Identifier':
                switch (child.name) {
                    case '\\0':
                    case '\\9':
                        iehack = child.name;
                        return;

                    case 'inherit':
                    case 'initial':
                    case 'unset':
                    case 'revert':
                        special = child.name;
                        break;
                }
                break;

            case 'Dimension':
                switch (child.unit) {
                    // is not supported until IE11
                    case 'rem':

                    // v* units is too buggy across browsers and better
                    // don't merge values with those units
                    case 'vw':
                    case 'vh':
                    case 'vmin':
                    case 'vmax':
                    case 'vm': // IE9 supporting "vm" instead of "vmin".
                        special = child.unit;
                        break;
                }
                break;

            case 'Hash': // color
            case 'Number':
            case 'Percentage':
                break;

            case 'Function':
                if (child.name === 'var') {
                    return true;
                }

                special = child.name;
                break;

            case 'WhiteSpace':
                return false; // ignore space

            default:
                return true;  // bad value
        }

        values.push({
            node: child,
            special: special,
            important: declaration.important
        });
    });

    if (hasBadValues || values.length > count) {
        return false;
    }

    if (typeof this.iehack === 'string' && this.iehack !== iehack) {
        return false;
    }

    this.iehack = iehack; // move outside

    return values;
};

TRBL.prototype.canOverride = function(side, value) {
    var currentValue = this.sides[side];

    return !currentValue || (value.important && !currentValue.important);
};

TRBL.prototype.add = function(name, declaration) {
    function attemptToAdd() {
        var sides = this.sides;
        var side = SIDE[name];

        if (side) {
            if (side in sides === false) {
                return false;
            }

            var values = this.getValueSequence(declaration, 1);

            if (!values || !values.length) {
                return false;
            }

            // can mix only if specials are equal
            for (var key in sides) {
                if (sides[key] !== null && sides[key].special !== values[0].special) {
                    return false;
                }
            }

            if (!this.canOverride(side, values[0])) {
                return true;
            }

            sides[side] = values[0];
            return true;
        } else if (name === this.name) {
            var values = this.getValueSequence(declaration, 4);

            if (!values || !values.length) {
                return false;
            }

            switch (values.length) {
                case 1:
                    values[RIGHT] = values[TOP];
                    values[BOTTOM] = values[TOP];
                    values[LEFT] = values[TOP];
                    break;

                case 2:
                    values[BOTTOM] = values[TOP];
                    values[LEFT] = values[RIGHT];
                    break;

                case 3:
                    values[LEFT] = values[RIGHT];
                    break;
            }

            // can mix only if specials are equal
            for (var i = 0; i < 4; i++) {
                for (var key in sides) {
                    if (sides[key] !== null && sides[key].special !== values[i].special) {
                        return false;
                    }
                }
            }

            for (var i = 0; i < 4; i++) {
                if (this.canOverride(SIDES[i], values[i])) {
                    sides[SIDES[i]] = values[i];
                }
            }

            return true;
        }
    }

    if (!attemptToAdd.call(this)) {
        return false;
    }

    // TODO: use it when we can refer to several points in source
    // if (this.loc) {
    //     this.loc = {
    //         primary: this.loc,
    //         merged: declaration.loc
    //     };
    // } else {
    //     this.loc = declaration.loc;
    // }
    if (!this.loc) {
        this.loc = declaration.loc;
    }

    return true;
};

TRBL.prototype.isOkToMinimize = function() {
    var top = this.sides.top;
    var right = this.sides.right;
    var bottom = this.sides.bottom;
    var left = this.sides.left;

    if (top && right && bottom && left) {
        var important =
            top.important +
            right.important +
            bottom.important +
            left.important;

        return important === 0 || important === 4;
    }

    return false;
};

TRBL.prototype.getValue = function() {
    var result = new List();
    var sides = this.sides;
    var values = [
        sides.top,
        sides.right,
        sides.bottom,
        sides.left
    ];
    var stringValues = [
        generate(sides.top.node),
        generate(sides.right.node),
        generate(sides.bottom.node),
        generate(sides.left.node)
    ];

    if (stringValues[LEFT] === stringValues[RIGHT]) {
        values.pop();
        if (stringValues[BOTTOM] === stringValues[TOP]) {
            values.pop();
            if (stringValues[RIGHT] === stringValues[TOP]) {
                values.pop();
            }
        }
    }

    for (var i = 0; i < values.length; i++) {
        if (i) {
            result.appendData({ type: 'WhiteSpace', value: ' ' });
        }

        result.appendData(values[i].node);
    }

    if (this.iehack) {
        result.appendData({ type: 'WhiteSpace', value: ' ' });
        result.appendData({
            type: 'Identifier',
            loc: null,
            name: this.iehack
        });
    }

    return {
        type: 'Value',
        loc: null,
        children: result
    };
};

TRBL.prototype.getDeclaration = function() {
    return {
        type: 'Declaration',
        loc: this.loc,
        important: this.sides.top.important,
        property: this.name,
        value: this.getValue()
    };
};

function processRule(rule, shorts, shortDeclarations, lastShortSelector) {
    var declarations = rule.block.children;
    var selector = rule.prelude.children.first().id;

    rule.block.children.eachRight(function(declaration, item) {
        var property = declaration.property;

        if (!MAIN_PROPERTY.hasOwnProperty(property)) {
            return;
        }

        var key = MAIN_PROPERTY[property];
        var shorthand;
        var operation;

        if (!lastShortSelector || selector === lastShortSelector) {
            if (key in shorts) {
                operation = REMOVE;
                shorthand = shorts[key];
            }
        }

        if (!shorthand || !shorthand.add(property, declaration)) {
            operation = REPLACE;
            shorthand = new TRBL(key);

            // if can't parse value ignore it and break shorthand children
            if (!shorthand.add(property, declaration)) {
                lastShortSelector = null;
                return;
            }
        }

        shorts[key] = shorthand;
        shortDeclarations.push({
            operation: operation,
            block: declarations,
            item: item,
            shorthand: shorthand
        });

        lastShortSelector = selector;
    });

    return lastShortSelector;
}

function processShorthands(shortDeclarations, markDeclaration) {
    shortDeclarations.forEach(function(item) {
        var shorthand = item.shorthand;

        if (!shorthand.isOkToMinimize()) {
            return;
        }

        if (item.operation === REPLACE) {
            item.item.data = markDeclaration(shorthand.getDeclaration());
        } else {
            item.block.remove(item.item);
        }
    });
}

module.exports = function restructBlock(ast, indexer) {
    var stylesheetMap = {};
    var shortDeclarations = [];

    walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter: function(node) {
            var stylesheet = this.block || this.stylesheet;
            var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
            var ruleMap;
            var shorts;

            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
                ruleMap = {
                    lastShortSelector: null
                };
                stylesheetMap[stylesheet.id] = ruleMap;
            } else {
                ruleMap = stylesheetMap[stylesheet.id];
            }

            if (ruleMap.hasOwnProperty(ruleId)) {
                shorts = ruleMap[ruleId];
            } else {
                shorts = {};
                ruleMap[ruleId] = shorts;
            }

            ruleMap.lastShortSelector = processRule.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
        }
    });

    processShorthands(shortDeclarations, indexer.declaration);
};


/***/ }),

/***/ 82286:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var resolveProperty = __nccwpck_require__(65035).property;
var resolveKeyword = __nccwpck_require__(65035).keyword;
var walk = __nccwpck_require__(65035).walk;
var generate = __nccwpck_require__(65035).generate;
var fingerprintId = 1;
var dontRestructure = {
    'src': 1 // https://github.com/afelix/csso/issues/50
};

var DONT_MIX_VALUE = {
    // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
    'display': /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
    // https://developer.mozilla.org/en/docs/Web/CSS/text-align
    'text-align': /^(start|end|match-parent|justify-all)$/i
};

var SAFE_VALUES = {
    cursor: [
        'auto', 'crosshair', 'default', 'move', 'text', 'wait', 'help',
        'n-resize', 'e-resize', 's-resize', 'w-resize',
        'ne-resize', 'nw-resize', 'se-resize', 'sw-resize',
        'pointer', 'progress', 'not-allowed', 'no-drop', 'vertical-text', 'all-scroll',
        'col-resize', 'row-resize'
    ],
    overflow: [
        'hidden', 'visible', 'scroll', 'auto'
    ],
    position: [
        'static', 'relative', 'absolute', 'fixed'
    ]
};

var NEEDLESS_TABLE = {
    'border-width': ['border'],
    'border-style': ['border'],
    'border-color': ['border'],
    'border-top': ['border'],
    'border-right': ['border'],
    'border-bottom': ['border'],
    'border-left': ['border'],
    'border-top-width': ['border-top', 'border-width', 'border'],
    'border-right-width': ['border-right', 'border-width', 'border'],
    'border-bottom-width': ['border-bottom', 'border-width', 'border'],
    'border-left-width': ['border-left', 'border-width', 'border'],
    'border-top-style': ['border-top', 'border-style', 'border'],
    'border-right-style': ['border-right', 'border-style', 'border'],
    'border-bottom-style': ['border-bottom', 'border-style', 'border'],
    'border-left-style': ['border-left', 'border-style', 'border'],
    'border-top-color': ['border-top', 'border-color', 'border'],
    'border-right-color': ['border-right', 'border-color', 'border'],
    'border-bottom-color': ['border-bottom', 'border-color', 'border'],
    'border-left-color': ['border-left', 'border-color', 'border'],
    'margin-top': ['margin'],
    'margin-right': ['margin'],
    'margin-bottom': ['margin'],
    'margin-left': ['margin'],
    'padding-top': ['padding'],
    'padding-right': ['padding'],
    'padding-bottom': ['padding'],
    'padding-left': ['padding'],
    'font-style': ['font'],
    'font-variant': ['font'],
    'font-weight': ['font'],
    'font-size': ['font'],
    'font-family': ['font'],
    'list-style-type': ['list-style'],
    'list-style-position': ['list-style'],
    'list-style-image': ['list-style']
};

function getPropertyFingerprint(propertyName, declaration, fingerprints) {
    var realName = resolveProperty(propertyName).basename;

    if (realName === 'background') {
        return propertyName + ':' + generate(declaration.value);
    }

    var declarationId = declaration.id;
    var fingerprint = fingerprints[declarationId];

    if (!fingerprint) {
        switch (declaration.value.type) {
            case 'Value':
                var vendorId = '';
                var iehack = '';
                var special = {};
                var raw = false;

                declaration.value.children.each(function walk(node) {
                    switch (node.type) {
                        case 'Value':
                        case 'Brackets':
                        case 'Parentheses':
                            node.children.each(walk);
                            break;

                        case 'Raw':
                            raw = true;
                            break;

                        case 'Identifier':
                            var name = node.name;

                            if (!vendorId) {
                                vendorId = resolveKeyword(name).vendor;
                            }

                            if (/\\[09]/.test(name)) {
                                iehack = RegExp.lastMatch;
                            }

                            if (SAFE_VALUES.hasOwnProperty(realName)) {
                                if (SAFE_VALUES[realName].indexOf(name) === -1) {
                                    special[name] = true;
                                }
                            } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                                if (DONT_MIX_VALUE[realName].test(name)) {
                                    special[name] = true;
                                }
                            }

                            break;

                        case 'Function':
                            var name = node.name;

                            if (!vendorId) {
                                vendorId = resolveKeyword(name).vendor;
                            }

                            if (name === 'rect') {
                                // there are 2 forms of rect:
                                //   rect(<top>, <right>, <bottom>, <left>) - standart
                                //   rect(<top> <right> <bottom> <left>)  backwards compatible syntax
                                // only the same form values can be merged
                                var hasComma = node.children.some(function(node) {
                                    return node.type === 'Operator' && node.value === ',';
                                });
                                if (!hasComma) {
                                    name = 'rect-backward';
                                }
                            }

                            special[name + '()'] = true;

                            // check nested tokens too
                            node.children.each(walk);

                            break;

                        case 'Dimension':
                            var unit = node.unit;

                            if (/\\[09]/.test(unit)) {
                                iehack = RegExp.lastMatch;
                            }

                            switch (unit) {
                                // is not supported until IE11
                                case 'rem':

                                // v* units is too buggy across browsers and better
                                // don't merge values with those units
                                case 'vw':
                                case 'vh':
                                case 'vmin':
                                case 'vmax':
                                case 'vm': // IE9 supporting "vm" instead of "vmin".
                                    special[unit] = true;
                                    break;
                            }
                            break;
                    }
                });

                fingerprint = raw
                    ? '!' + fingerprintId++
                    : '!' + Object.keys(special).sort() + '|' + iehack + vendorId;
                break;

            case 'Raw':
                fingerprint = '!' + declaration.value.value;
                break;

            default:
                fingerprint = generate(declaration.value);
        }

        fingerprints[declarationId] = fingerprint;
    }

    return propertyName + fingerprint;
}

function needless(props, declaration, fingerprints) {
    var property = resolveProperty(declaration.property);

    if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
        var table = NEEDLESS_TABLE[property.basename];

        for (var i = 0; i < table.length; i++) {
            var ppre = getPropertyFingerprint(property.prefix + table[i], declaration, fingerprints);
            var prev = props.hasOwnProperty(ppre) ? props[ppre] : null;

            if (prev && (!declaration.important || prev.item.data.important)) {
                return prev;
            }
        }
    }
}

function processRule(rule, item, list, props, fingerprints) {
    var declarations = rule.block.children;

    declarations.eachRight(function(declaration, declarationItem) {
        var property = declaration.property;
        var fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
        var prev = props[fingerprint];

        if (prev && !dontRestructure.hasOwnProperty(property)) {
            if (declaration.important && !prev.item.data.important) {
                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };

                prev.block.remove(prev.item);

                // TODO: use it when we can refer to several points in source
                // declaration.loc = {
                //     primary: declaration.loc,
                //     merged: prev.item.data.loc
                // };
            } else {
                declarations.remove(declarationItem);

                // TODO: use it when we can refer to several points in source
                // prev.item.data.loc = {
                //     primary: prev.item.data.loc,
                //     merged: declaration.loc
                // };
            }
        } else {
            var prev = needless(props, declaration, fingerprints);

            if (prev) {
                declarations.remove(declarationItem);

                // TODO: use it when we can refer to several points in source
                // prev.item.data.loc = {
                //     primary: prev.item.data.loc,
                //     merged: declaration.loc
                // };
            } else {
                declaration.fingerprint = fingerprint;

                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };
            }
        }
    });

    if (declarations.isEmpty()) {
        list.remove(item);
    }
}

module.exports = function restructBlock(ast) {
    var stylesheetMap = {};
    var fingerprints = Object.create(null);

    walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter: function(node, item, list) {
            var stylesheet = this.block || this.stylesheet;
            var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
            var ruleMap;
            var props;

            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
                ruleMap = {};
                stylesheetMap[stylesheet.id] = ruleMap;
            } else {
                ruleMap = stylesheetMap[stylesheet.id];
            }

            if (ruleMap.hasOwnProperty(ruleId)) {
                props = ruleMap[ruleId];
            } else {
                props = {};
                ruleMap[ruleId] = props;
            }

            processRule.call(this, node, item, list, props, fingerprints);
        }
    });
};


/***/ }),

/***/ 28136:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var walk = __nccwpck_require__(65035).walk;
var utils = __nccwpck_require__(28011);

/*
    At this step all rules has single simple selector. We try to join by equal
    declaration blocks to first rule, e.g.

    .a { color: red }
    b { ... }
    .b { color: red }
    ->
    .a, .b { color: red }
    b { ... }
*/

function processRule(node, item, list) {
    var selectors = node.prelude.children;
    var declarations = node.block.children;
    var nodeCompareMarker = selectors.first().compareMarker;
    var skippedCompareMarkers = {};

    list.nextUntil(item.next, function(next, nextItem) {
        // skip non-ruleset node if safe
        if (next.type !== 'Rule') {
            return utils.unsafeToSkipNode.call(selectors, next);
        }

        if (node.pseudoSignature !== next.pseudoSignature) {
            return true;
        }

        var nextFirstSelector = next.prelude.children.head;
        var nextDeclarations = next.block.children;
        var nextCompareMarker = nextFirstSelector.data.compareMarker;

        // if next ruleset has same marked as one of skipped then stop joining
        if (nextCompareMarker in skippedCompareMarkers) {
            return true;
        }

        // try to join by selectors
        if (selectors.head === selectors.tail) {
            if (selectors.first().id === nextFirstSelector.data.id) {
                declarations.appendList(nextDeclarations);
                list.remove(nextItem);
                return;
            }
        }

        // try to join by properties
        if (utils.isEqualDeclarations(declarations, nextDeclarations)) {
            var nextStr = nextFirstSelector.data.id;

            selectors.some(function(data, item) {
                var curStr = data.id;

                if (nextStr < curStr) {
                    selectors.insert(nextFirstSelector, item);
                    return true;
                }

                if (!item.next) {
                    selectors.insert(nextFirstSelector);
                    return true;
                }
            });

            list.remove(nextItem);
            return;
        }

        // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)
        if (nextCompareMarker === nodeCompareMarker) {
            return true;
        }

        skippedCompareMarkers[nextCompareMarker] = true;
    });
}

module.exports = function mergeRule(ast) {
    walk(ast, {
        visit: 'Rule',
        enter: processRule
    });
};


/***/ }),

/***/ 27440:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var List = __nccwpck_require__(65035).List;
var walk = __nccwpck_require__(65035).walk;
var utils = __nccwpck_require__(28011);

function calcSelectorLength(list) {
    var length = 0;

    list.each(function(data) {
        length += data.id.length + 1;
    });

    return length - 1;
}

function calcDeclarationsLength(tokens) {
    var length = 0;

    for (var i = 0; i < tokens.length; i++) {
        length += tokens[i].length;
    }

    return (
        length +          // declarations
        tokens.length - 1 // delimeters
    );
}

function processRule(node, item, list) {
    var avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
    var selectors = node.prelude.children;
    var block = node.block;
    var disallowDownMarkers = Object.create(null);
    var allowMergeUp = true;
    var allowMergeDown = true;

    list.prevUntil(item.prev, function(prev, prevItem) {
        var prevBlock = prev.block;
        var prevType = prev.type;

        if (prevType !== 'Rule') {
            var unsafe = utils.unsafeToSkipNode.call(selectors, prev);

            if (!unsafe && prevType === 'Atrule' && prevBlock) {
                walk(prevBlock, {
                    visit: 'Rule',
                    enter: function(node) {
                        node.prelude.children.each(function(data) {
                            disallowDownMarkers[data.compareMarker] = true;
                        });
                    }
                });
            }

            return unsafe;
        }

        var prevSelectors = prev.prelude.children;

        if (node.pseudoSignature !== prev.pseudoSignature) {
            return true;
        }

        allowMergeDown = !prevSelectors.some(function(selector) {
            return selector.compareMarker in disallowDownMarkers;
        });

        // try prev ruleset if simpleselectors has no equal specifity and element selector
        if (!allowMergeDown && !allowMergeUp) {
            return true;
        }

        // try to join by selectors
        if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {
            prevBlock.children.appendList(block.children);
            list.remove(item);
            return true;
        }

        // try to join by properties
        var diff = utils.compareDeclarations(block.children, prevBlock.children);

        // console.log(diff.eq, diff.ne1, diff.ne2);

        if (diff.eq.length) {
            if (!diff.ne1.length && !diff.ne2.length) {
                // equal blocks
                if (allowMergeDown) {
                    utils.addSelectors(selectors, prevSelectors);
                    list.remove(prevItem);
                }

                return true;
            } else if (!avoidRulesMerge) { /* probably we don't need to prevent those merges for @keyframes
                                              TODO: need to be checked */

                if (diff.ne1.length && !diff.ne2.length) {
                    // prevBlock is subset block
                    var selectorLength = calcSelectorLength(selectors);
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeUp && selectorLength < blockLength) {
                        utils.addSelectors(prevSelectors, selectors);
                        block.children = new List().fromArray(diff.ne1);
                    }
                } else if (!diff.ne1.length && diff.ne2.length) {
                    // node is subset of prevBlock
                    var selectorLength = calcSelectorLength(prevSelectors);
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeDown && selectorLength < blockLength) {
                        utils.addSelectors(selectors, prevSelectors);
                        prevBlock.children = new List().fromArray(diff.ne2);
                    }
                } else {
                    // diff.ne1.length && diff.ne2.length
                    // extract equal block
                    var newSelector = {
                        type: 'SelectorList',
                        loc: null,
                        children: utils.addSelectors(prevSelectors.copy(), selectors)
                    };
                    var newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    // create new ruleset if declarations length greater than
                    // ruleset description overhead
                    if (blockLength >= newBlockLength) {
                        var newItem = list.createItem({
                            type: 'Rule',
                            loc: null,
                            prelude: newSelector,
                            block: {
                                type: 'Block',
                                loc: null,
                                children: new List().fromArray(diff.eq)
                            },
                            pseudoSignature: node.pseudoSignature
                        });

                        block.children = new List().fromArray(diff.ne1);
                        prevBlock.children = new List().fromArray(diff.ne2overrided);

                        if (allowMergeUp) {
                            list.insert(newItem, prevItem);
                        } else {
                            list.insert(newItem, item);
                        }

                        return true;
                    }
                }
            }
        }

        if (allowMergeUp) {
            // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);
            // await property families to find property interception correctly
            allowMergeUp = !prevSelectors.some(function(prevSelector) {
                return selectors.some(function(selector) {
                    return selector.compareMarker === prevSelector.compareMarker;
                });
            });
        }

        prevSelectors.each(function(data) {
            disallowDownMarkers[data.compareMarker] = true;
        });
    });
}

module.exports = function restructRule(ast) {
    walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter: processRule
    });
};


/***/ }),

/***/ 59029:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var prepare = __nccwpck_require__(98516);
var mergeAtrule = __nccwpck_require__(76456);
var initialMergeRuleset = __nccwpck_require__(34847);
var disjoinRuleset = __nccwpck_require__(46624);
var restructShorthand = __nccwpck_require__(8563);
var restructBlock = __nccwpck_require__(82286);
var mergeRuleset = __nccwpck_require__(28136);
var restructRuleset = __nccwpck_require__(27440);

module.exports = function(ast, options) {
    // prepare ast for restructing
    var indexer = prepare(ast, options);
    options.logger('prepare', ast);

    mergeAtrule(ast, options);
    options.logger('mergeAtrule', ast);

    initialMergeRuleset(ast);
    options.logger('initialMergeRuleset', ast);

    disjoinRuleset(ast);
    options.logger('disjoinRuleset', ast);

    restructShorthand(ast, indexer);
    options.logger('restructShorthand', ast);

    restructBlock(ast);
    options.logger('restructBlock', ast);

    mergeRuleset(ast);
    options.logger('mergeRuleset', ast);

    restructRuleset(ast);
    options.logger('restructRuleset', ast);
};


/***/ }),

/***/ 94072:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var generate = __nccwpck_require__(65035).generate;

function Index() {
    this.seed = 0;
    this.map = Object.create(null);
}

Index.prototype.resolve = function(str) {
    var index = this.map[str];

    if (!index) {
        index = ++this.seed;
        this.map[str] = index;
    }

    return index;
};

module.exports = function createDeclarationIndexer() {
    var ids = new Index();

    return function markDeclaration(node) {
        var id = generate(node);

        node.id = ids.resolve(id);
        node.length = id.length;
        node.fingerprint = null;

        return node;
    };
};


/***/ }),

/***/ 98516:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var resolveKeyword = __nccwpck_require__(65035).keyword;
var walk = __nccwpck_require__(65035).walk;
var generate = __nccwpck_require__(65035).generate;
var createDeclarationIndexer = __nccwpck_require__(94072);
var processSelector = __nccwpck_require__(91753);

module.exports = function prepare(ast, options) {
    var markDeclaration = createDeclarationIndexer();

    walk(ast, {
        visit: 'Rule',
        enter: function processRule(node) {
            node.block.children.each(markDeclaration);
            processSelector(node, options.usage);
        }
    });

    walk(ast, {
        visit: 'Atrule',
        enter: function(node) {
            if (node.prelude) {
                node.prelude.id = null; // pre-init property to avoid multiple hidden class for generate
                node.prelude.id = generate(node.prelude);
            }

            // compare keyframe selectors by its values
            // NOTE: still no clarification about problems with keyframes selector grouping (issue #197)
            if (resolveKeyword(node.name).basename === 'keyframes') {
                node.block.avoidRulesMerge = true;  /* probably we don't need to prevent those merges for @keyframes
                                                       TODO: need to be checked */
                node.block.children.each(function(rule) {
                    rule.prelude.children.each(function(simpleselector) {
                        simpleselector.compareMarker = simpleselector.id;
                    });
                });
            }
        }
    });

    return {
        declaration: markDeclaration
    };
};


/***/ }),

/***/ 91753:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var generate = __nccwpck_require__(65035).generate;
var specificity = __nccwpck_require__(63160);

var nonFreezePseudoElements = {
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};
var nonFreezePseudoClasses = {
    'link': true,
    'visited': true,
    'hover': true,
    'active': true,
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};

module.exports = function freeze(node, usageData) {
    var pseudos = Object.create(null);
    var hasPseudo = false;

    node.prelude.children.each(function(simpleSelector) {
        var tagName = '*';
        var scope = 0;

        simpleSelector.children.each(function(node) {
            switch (node.type) {
                case 'ClassSelector':
                    if (usageData && usageData.scopes) {
                        var classScope = usageData.scopes[node.name] || 0;

                        if (scope !== 0 && classScope !== scope) {
                            throw new Error('Selector can\'t has classes from different scopes: ' + generate(simpleSelector));
                        }

                        scope = classScope;
                    }
                    break;

                case 'PseudoClassSelector':
                    var name = node.name.toLowerCase();

                    if (!nonFreezePseudoClasses.hasOwnProperty(name)) {
                        pseudos[':' + name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'PseudoElementSelector':
                    var name = node.name.toLowerCase();

                    if (!nonFreezePseudoElements.hasOwnProperty(name)) {
                        pseudos['::' + name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'TypeSelector':
                    tagName = node.name.toLowerCase();
                    break;

                case 'AttributeSelector':
                    if (node.flags) {
                        pseudos['[' + node.flags.toLowerCase() + ']'] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'WhiteSpace':
                case 'Combinator':
                    tagName = '*';
                    break;
            }
        });

        simpleSelector.compareMarker = specificity(simpleSelector).toString();
        simpleSelector.id = null; // pre-init property to avoid multiple hidden class
        simpleSelector.id = generate(simpleSelector);

        if (scope) {
            simpleSelector.compareMarker += ':' + scope;
        }

        if (tagName !== '*') {
            simpleSelector.compareMarker += ',' + tagName;
        }
    });

    // add property to all rule nodes to avoid multiple hidden class
    node.pseudoSignature = hasPseudo && Object.keys(pseudos).sort().join(',');
};


/***/ }),

/***/ 63160:
/***/ ((module) => {

module.exports = function specificity(simpleSelector) {
    var A = 0;
    var B = 0;
    var C = 0;

    simpleSelector.children.each(function walk(node) {
        switch (node.type) {
            case 'SelectorList':
            case 'Selector':
                node.children.each(walk);
                break;

            case 'IdSelector':
                A++;
                break;

            case 'ClassSelector':
            case 'AttributeSelector':
                B++;
                break;

            case 'PseudoClassSelector':
                switch (node.name.toLowerCase()) {
                    case 'not':
                        node.children.each(walk);
                        break;

                    case 'before':
                    case 'after':
                    case 'first-line':
                    case 'first-letter':
                        C++;
                        break;

                    // TODO: support for :nth-*(.. of <SelectorList>), :matches(), :has()
                    default:
                        B++;
                }
                break;

            case 'PseudoElementSelector':
                C++;
                break;

            case 'TypeSelector':
                // ignore universal selector
                if (node.name.charAt(node.name.length - 1) !== '*') {
                    C++;
                }
                break;

        }
    });

    return [A, B, C];
};


/***/ }),

/***/ 28011:
/***/ ((module) => {

var hasOwnProperty = Object.prototype.hasOwnProperty;

function isEqualSelectors(a, b) {
    var cursor1 = a.head;
    var cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function isEqualDeclarations(a, b) {
    var cursor1 = a.head;
    var cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function compareDeclarations(declarations1, declarations2) {
    var result = {
        eq: [],
        ne1: [],
        ne2: [],
        ne2overrided: []
    };

    var fingerprints = Object.create(null);
    var declarations2hash = Object.create(null);

    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
        declarations2hash[cursor.data.id] = true;
    }

    for (var cursor = declarations1.head; cursor; cursor = cursor.next)  {
        var data = cursor.data;

        if (data.fingerprint) {
            fingerprints[data.fingerprint] = data.important;
        }

        if (declarations2hash[data.id]) {
            declarations2hash[data.id] = false;
            result.eq.push(data);
        } else {
            result.ne1.push(data);
        }
    }

    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
        var data = cursor.data;

        if (declarations2hash[data.id]) {
            // when declarations1 has an overriding declaration, this is not a difference
            // unless no !important is used on prev and !important is used on the following
            if (!hasOwnProperty.call(fingerprints, data.fingerprint) ||
                (!fingerprints[data.fingerprint] && data.important)) {
                result.ne2.push(data);
            }

            result.ne2overrided.push(data);
        }
    }

    return result;
}

function addSelectors(dest, source) {
    source.each(function(sourceData) {
        var newStr = sourceData.id;
        var cursor = dest.head;

        while (cursor) {
            var nextStr = cursor.data.id;

            if (nextStr === newStr) {
                return;
            }

            if (nextStr > newStr) {
                break;
            }

            cursor = cursor.next;
        }

        dest.insert(dest.createItem(sourceData), cursor);
    });

    return dest;
}

// check if simpleselectors has no equal specificity and element selector
function hasSimilarSelectors(selectors1, selectors2) {
    var cursor1 = selectors1.head;

    while (cursor1 !== null) {
        var cursor2 = selectors2.head;

        while (cursor2 !== null) {
            if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
                return true;
            }

            cursor2 = cursor2.next;
        }

        cursor1 = cursor1.next;
    }

    return false;
}

// test node can't to be skipped
function unsafeToSkipNode(node) {
    switch (node.type) {
        case 'Rule':
            // unsafe skip ruleset with selector similarities
            return hasSimilarSelectors(node.prelude.children, this);

        case 'Atrule':
            // can skip at-rules with blocks
            if (node.block) {
                // unsafe skip at-rule if block contains something unsafe to skip
                return node.block.children.some(unsafeToSkipNode, this);
            }
            break;

        case 'Declaration':
            return false;
    }

    // unsafe by default
    return true;
}

module.exports = {
    isEqualSelectors: isEqualSelectors,
    isEqualDeclarations: isEqualDeclarations,
    compareDeclarations: compareDeclarations,
    addSelectors: addSelectors,
    hasSimilarSelectors: hasSimilarSelectors,
    unsafeToSkipNode: unsafeToSkipNode
};


/***/ }),

/***/ 29863:
/***/ ((module) => {

var hasOwnProperty = Object.prototype.hasOwnProperty;

function buildMap(list, caseInsensitive) {
    var map = Object.create(null);

    if (!Array.isArray(list)) {
        return null;
    }

    for (var i = 0; i < list.length; i++) {
        var name = list[i];

        if (caseInsensitive) {
            name = name.toLowerCase();
        }

        map[name] = true;
    }

    return map;
}

function buildList(data) {
    if (!data) {
        return null;
    }

    var tags = buildMap(data.tags, true);
    var ids = buildMap(data.ids);
    var classes = buildMap(data.classes);

    if (tags === null &&
        ids === null &&
        classes === null) {
        return null;
    }

    return {
        tags: tags,
        ids: ids,
        classes: classes
    };
}

function buildIndex(data) {
    var scopes = false;

    if (data.scopes && Array.isArray(data.scopes)) {
        scopes = Object.create(null);

        for (var i = 0; i < data.scopes.length; i++) {
            var list = data.scopes[i];

            if (!list || !Array.isArray(list)) {
                throw new Error('Wrong usage format');
            }

            for (var j = 0; j < list.length; j++) {
                var name = list[j];

                if (hasOwnProperty.call(scopes, name)) {
                    throw new Error('Class can\'t be used for several scopes: ' + name);
                }

                scopes[name] = i + 1;
            }
        }
    }

    return {
        whitelist: buildList(data),
        blacklist: buildList(data.blacklist),
        scopes: scopes
    };
}

module.exports = {
    buildIndex: buildIndex
};


/***/ }),

/***/ 14802:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attributeNames = exports.elementNames = void 0;
exports.elementNames = new Map([
    ["altglyph", "altGlyph"],
    ["altglyphdef", "altGlyphDef"],
    ["altglyphitem", "altGlyphItem"],
    ["animatecolor", "animateColor"],
    ["animatemotion", "animateMotion"],
    ["animatetransform", "animateTransform"],
    ["clippath", "clipPath"],
    ["feblend", "feBlend"],
    ["fecolormatrix", "feColorMatrix"],
    ["fecomponenttransfer", "feComponentTransfer"],
    ["fecomposite", "feComposite"],
    ["feconvolvematrix", "feConvolveMatrix"],
    ["fediffuselighting", "feDiffuseLighting"],
    ["fedisplacementmap", "feDisplacementMap"],
    ["fedistantlight", "feDistantLight"],
    ["fedropshadow", "feDropShadow"],
    ["feflood", "feFlood"],
    ["fefunca", "feFuncA"],
    ["fefuncb", "feFuncB"],
    ["fefuncg", "feFuncG"],
    ["fefuncr", "feFuncR"],
    ["fegaussianblur", "feGaussianBlur"],
    ["feimage", "feImage"],
    ["femerge", "feMerge"],
    ["femergenode", "feMergeNode"],
    ["femorphology", "feMorphology"],
    ["feoffset", "feOffset"],
    ["fepointlight", "fePointLight"],
    ["fespecularlighting", "feSpecularLighting"],
    ["fespotlight", "feSpotLight"],
    ["fetile", "feTile"],
    ["feturbulence", "feTurbulence"],
    ["foreignobject", "foreignObject"],
    ["glyphref", "glyphRef"],
    ["lineargradient", "linearGradient"],
    ["radialgradient", "radialGradient"],
    ["textpath", "textPath"],
]);
exports.attributeNames = new Map([
    ["definitionurl", "definitionURL"],
    ["attributename", "attributeName"],
    ["attributetype", "attributeType"],
    ["basefrequency", "baseFrequency"],
    ["baseprofile", "baseProfile"],
    ["calcmode", "calcMode"],
    ["clippathunits", "clipPathUnits"],
    ["diffuseconstant", "diffuseConstant"],
    ["edgemode", "edgeMode"],
    ["filterunits", "filterUnits"],
    ["glyphref", "glyphRef"],
    ["gradienttransform", "gradientTransform"],
    ["gradientunits", "gradientUnits"],
    ["kernelmatrix", "kernelMatrix"],
    ["kernelunitlength", "kernelUnitLength"],
    ["keypoints", "keyPoints"],
    ["keysplines", "keySplines"],
    ["keytimes", "keyTimes"],
    ["lengthadjust", "lengthAdjust"],
    ["limitingconeangle", "limitingConeAngle"],
    ["markerheight", "markerHeight"],
    ["markerunits", "markerUnits"],
    ["markerwidth", "markerWidth"],
    ["maskcontentunits", "maskContentUnits"],
    ["maskunits", "maskUnits"],
    ["numoctaves", "numOctaves"],
    ["pathlength", "pathLength"],
    ["patterncontentunits", "patternContentUnits"],
    ["patterntransform", "patternTransform"],
    ["patternunits", "patternUnits"],
    ["pointsatx", "pointsAtX"],
    ["pointsaty", "pointsAtY"],
    ["pointsatz", "pointsAtZ"],
    ["preservealpha", "preserveAlpha"],
    ["preserveaspectratio", "preserveAspectRatio"],
    ["primitiveunits", "primitiveUnits"],
    ["refx", "refX"],
    ["refy", "refY"],
    ["repeatcount", "repeatCount"],
    ["repeatdur", "repeatDur"],
    ["requiredextensions", "requiredExtensions"],
    ["requiredfeatures", "requiredFeatures"],
    ["specularconstant", "specularConstant"],
    ["specularexponent", "specularExponent"],
    ["spreadmethod", "spreadMethod"],
    ["startoffset", "startOffset"],
    ["stddeviation", "stdDeviation"],
    ["stitchtiles", "stitchTiles"],
    ["surfacescale", "surfaceScale"],
    ["systemlanguage", "systemLanguage"],
    ["tablevalues", "tableValues"],
    ["targetx", "targetX"],
    ["targety", "targetY"],
    ["textlength", "textLength"],
    ["viewbox", "viewBox"],
    ["viewtarget", "viewTarget"],
    ["xchannelselector", "xChannelSelector"],
    ["ychannelselector", "yChannelSelector"],
    ["zoomandpan", "zoomAndPan"],
]);


/***/ }),

/***/ 48621:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Module dependencies
 */
var ElementType = __importStar(__nccwpck_require__(53944));
var entities_1 = __nccwpck_require__(3000);
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_1 = __nccwpck_require__(14802);
var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript",
]);
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
    if (!attributes)
        return;
    return Object.keys(attributes)
        .map(function (key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */
            key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return key + "=\"" + (opts.decodeEntities !== false
            ? entities_1.encodeXML(value)
            : value.replace(/"/g, "&quot;")) + "\"";
    })
        .join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options) {
    if (options === void 0) { options = {}; }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
    }
    return output;
}
exports.default = render;
function renderNode(node, options) {
    switch (node.type) {
        case ElementType.Root:
            return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
    }
}
var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */
        if (elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: false });
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += " " + attribs;
    }
    if (elem.children.length === 0 &&
        (opts.xmlMode
            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                opts.selfClosingTags !== false
            : // User explicitly asked for self-closing tags, even in HTML mode
                opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
            tag += " ";
        tag += "/>";
    }
    else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</" + elem.name + ">";
        }
    }
    return tag;
}
function renderDirective(elem) {
    return "<" + elem.data + ">";
}
function renderText(elem, opts) {
    var data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (opts.decodeEntities !== false &&
        !(!opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
    }
    return data;
}
function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
}
function renderComment(elem) {
    return "<!--" + elem.data + "-->";
}


/***/ }),

/***/ 53944:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */
    ElementType["Text"] = "text";
    /** Type for <? ... ?> */
    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */
    ElementType["Comment"] = "comment";
    /** Type for <script> tags */
    ElementType["Script"] = "script";
    /** Type for <style> tags */
    ElementType["Style"] = "style";
    /** Type for Any tag */
    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */
    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */
    ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === ElementType.Tag ||
        elem.type === ElementType.Script ||
        elem.type === ElementType.Style);
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */
exports.Root = ElementType.Root;
/** Type for Text */
exports.Text = ElementType.Text;
/** Type for <? ... ?> */
exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */
exports.Comment = ElementType.Comment;
/** Type for <script> tags */
exports.Script = ElementType.Script;
/** Type for <style> tags */
exports.Style = ElementType.Style;
/** Type for Any tag */
exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
exports.Doctype = ElementType.Doctype;


/***/ }),

/***/ 74038:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DomHandler = void 0;
var domelementtype_1 = __nccwpck_require__(53944);
var node_1 = __nccwpck_require__(7822);
__exportStar(__nccwpck_require__(7822), exports);
var reWhitespace = /\s+/g;
// Default options
var defaultOpts = {
    normalizeWhitespace: false,
    withStartIndices: false,
    withEndIndices: false,
};
var DomHandler = /** @class */ (function () {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */
        this.dom = [];
        /** The root element for the DOM */
        this.root = new node_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */
        this.done = false;
        /** Stack of open tags. */
        this.tagStack = [this.root];
        /** A data node that is still being written to. */
        this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */
        this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function (parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function () {
        var _a;
        this.dom = [];
        this.root = new node_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = (_a = this.parser) !== null && _a !== void 0 ? _a : null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function () {
        if (this.done)
            return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function (error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function () {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
            this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function (name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function (data) {
        var normalizeWhitespace = this.options.normalizeWhitespace;
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
                lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            }
            else {
                lastNode.data += data;
            }
        }
        else {
            if (normalizeWhitespace) {
                data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function (data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function () {
        var text = new node_1.Text("");
        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function (name, data) {
        var node = new node_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function (error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        }
        else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function (node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}());
exports.DomHandler = DomHandler;
exports.default = DomHandler;


/***/ }),

/***/ 7822:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var domelementtype_1 = __nccwpck_require__(53944);
var nodeTypes = new Map([
    [domelementtype_1.ElementType.Tag, 1],
    [domelementtype_1.ElementType.Script, 1],
    [domelementtype_1.ElementType.Style, 1],
    [domelementtype_1.ElementType.Directive, 1],
    [domelementtype_1.ElementType.Text, 3],
    [domelementtype_1.ElementType.CDATA, 4],
    [domelementtype_1.ElementType.Comment, 8],
    [domelementtype_1.ElementType.Root, 9],
]);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node = /** @class */ (function () {
    /**
     *
     * @param type The type of the node.
     */
    function Node(type) {
        this.type = type;
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "nodeType", {
        // Read-only aliases
        get: function () {
            var _a;
            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        get: function () {
            return this.parent;
        },
        set: function (parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        get: function () {
            return this.prev;
        },
        set: function (prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        get: function () {
            return this.next;
        },
        set: function (next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    Node.prototype.cloneNode = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        return cloneNode(this, recursive);
    };
    return Node;
}());
exports.Node = Node;
var DataNode = /** @class */ (function (_super) {
    __extends(DataNode, _super);
    /**
     * @param type The type of the node
     * @param data The content of the data node
     */
    function DataNode(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        get: function () {
            return this.data;
        },
        set: function (data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node));
exports.DataNode = DataNode;
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text(data) {
        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
    }
    return Text;
}(DataNode));
exports.Text = Text;
var Comment = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment(data) {
        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
    }
    return Comment;
}(DataNode));
exports.Comment = Comment;
var ProcessingInstruction = /** @class */ (function (_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
    }
    return ProcessingInstruction;
}(DataNode));
exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren = /** @class */ (function (_super) {
    __extends(NodeWithChildren, _super);
    /**
     * @param type Type of the node.
     * @param children Children of the node. Only certain node types can have children.
     */
    function NodeWithChildren(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        get: function () {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        get: function () {
            return this.children;
        },
        set: function (children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node));
exports.NodeWithChildren = NodeWithChildren;
var Document = /** @class */ (function (_super) {
    __extends(Document, _super);
    function Document(children) {
        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
    }
    return Document;
}(NodeWithChildren));
exports.Document = Document;
var Element = /** @class */ (function (_super) {
    __extends(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    function Element(name, attribs, children, type) {
        if (children === void 0) { children = []; }
        if (type === void 0) { type = name === "script"
            ? domelementtype_1.ElementType.Script
            : name === "style"
                ? domelementtype_1.ElementType.Style
                : domelementtype_1.ElementType.Tag; }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
    }
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        get: function () {
            return this.name;
        },
        set: function (name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
                var _a, _b;
                return ({
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren));
exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag(node) {
    return domelementtype_1.isTag(node);
}
exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
}
exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
    return node.type === domelementtype_1.ElementType.Text;
}
exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
    return node.type === domelementtype_1.ElementType.Comment;
}
exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
    return node.type === domelementtype_1.ElementType.Directive;
}
exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
    return node.type === domelementtype_1.ElementType.Root;
}
exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
 */
function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive) {
    if (recursive === void 0) { recursive = false; }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    }
    else if (isComment(node)) {
        result = new Comment(node.data);
    }
    else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function (child) { return (child.parent = clone_1); });
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    }
    else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
        children.forEach(function (child) { return (child.parent = clone_2); });
        result = clone_2;
    }
    else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function (child) { return (child.parent = clone_3); });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    }
    else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    }
    else {
        throw new Error("Not implemented yet: " + node.type);
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    return result;
}
exports.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function (child) { return cloneNode(child, true); });
    for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}


/***/ }),

/***/ 61447:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;
var domhandler_1 = __nccwpck_require__(74038);
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */
function removeSubsets(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
exports.removeSubsets = removeSubsets;
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = domhandler_1.hasChildren(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = domhandler_1.hasChildren(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return 1 /* DISCONNECTED */;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
        }
        return 4 /* FOLLOWING */;
    }
    if (sharedParent === nodeA) {
        return 2 /* PRECEDING */ | 8 /* CONTAINS */;
    }
    return 2 /* PRECEDING */;
}
exports.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
    nodes.sort(function (a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2 /* PRECEDING */) {
            return -1;
        }
        else if (relative & 4 /* FOLLOWING */) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
exports.uniqueSort = uniqueSort;


/***/ }),

/***/ 11754:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(__nccwpck_require__(29561), exports);
__exportStar(__nccwpck_require__(79228), exports);
__exportStar(__nccwpck_require__(20177), exports);
__exportStar(__nccwpck_require__(39908), exports);
__exportStar(__nccwpck_require__(72185), exports);
__exportStar(__nccwpck_require__(61447), exports);
var domhandler_1 = __nccwpck_require__(74038);
Object.defineProperty(exports, "isTag", ({ enumerable: true, get: function () { return domhandler_1.isTag; } }));
Object.defineProperty(exports, "isCDATA", ({ enumerable: true, get: function () { return domhandler_1.isCDATA; } }));
Object.defineProperty(exports, "isText", ({ enumerable: true, get: function () { return domhandler_1.isText; } }));
Object.defineProperty(exports, "isComment", ({ enumerable: true, get: function () { return domhandler_1.isComment; } }));
Object.defineProperty(exports, "isDocument", ({ enumerable: true, get: function () { return domhandler_1.isDocument; } }));
Object.defineProperty(exports, "hasChildren", ({ enumerable: true, get: function () { return domhandler_1.hasChildren; } }));


/***/ }),

/***/ 72185:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
var domhandler_1 = __nccwpck_require__(74038);
var querying_1 = __nccwpck_require__(39908);
var Checks = {
    tag_name: function (name) {
        if (typeof name === "function") {
            return function (elem) { return domhandler_1.isTag(elem) && name(elem.name); };
        }
        else if (name === "*") {
            return domhandler_1.isTag;
        }
        return function (elem) { return domhandler_1.isTag(elem) && elem.name === name; };
    },
    tag_type: function (type) {
        if (typeof type === "function") {
            return function (elem) { return type(elem.type); };
        }
        return function (elem) { return elem.type === type; };
    },
    tag_contains: function (data) {
        if (typeof data === "function") {
            return function (elem) { return domhandler_1.isText(elem) && data(elem.data); };
        }
        return function (elem) { return domhandler_1.isText(elem) && elem.data === data; };
    },
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a particular value.
 */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function (elem) { return domhandler_1.isTag(elem) && value(elem.attribs[attrib]); };
    }
    return function (elem) { return domhandler_1.isTag(elem) && elem.attribs[attrib] === value; };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either
 * of the input functions returns `true` for the node.
 */
function combineFuncs(a, b) {
    return function (elem) { return a(elem) || b(elem); };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true`
 * if any of them match a node.
 */
function compileTest(options) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return key in Checks
            ? Checks[key](value)
            : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
exports.testElement = testElement;
/**
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    var test = compileTest(options);
    return test ? querying_1.filter(test, nodes, recurse, limit) : [];
}
exports.getElements = getElements;
/**
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    if (!Array.isArray(nodes))
        nodes = [nodes];
    return querying_1.findOne(getAttribCheck("id", id), nodes, recurse);
}
exports.getElementById = getElementById;
/**
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return querying_1.filter(Checks.tag_name(tagName), nodes, recurse, limit);
}
exports.getElementsByTagName = getElementsByTagName;
/**
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return querying_1.filter(Checks.tag_type(type), nodes, recurse, limit);
}
exports.getElementsByTagType = getElementsByTagType;


/***/ }),

/***/ 20177:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @param elem The element to be removed
 */
function removeElement(elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
    }
}
exports.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
    var prev = (replacement.prev = elem.prev);
    if (prev) {
        prev.next = replacement;
    }
    var next = (replacement.next = elem.next);
    if (next) {
        next.prev = replacement;
    }
    var parent = (replacement.parent = elem.parent);
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
    }
}
exports.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild(elem, child) {
    removeElement(child);
    child.next = null;
    child.parent = elem;
    if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    }
    else {
        child.prev = null;
    }
}
exports.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    }
    else if (parent) {
        parent.children.push(next);
    }
}
exports.append = append;
/**
 * Prepend a child to an element.
 *
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(elem, child) {
    removeElement(child);
    child.parent = elem;
    child.prev = null;
    if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
    }
    else {
        child.next = null;
    }
}
exports.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
exports.prepend = prepend;


/***/ }),

/***/ 39908:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
var domhandler_1 = __nccwpck_require__(74038);
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter(test, node, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    if (!Array.isArray(node))
        node = [node];
    return find(test, node, recurse, limit);
}
exports.filter = filter;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
    var result = [];
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                break;
        }
        if (recurse && domhandler_1.hasChildren(elem) && elem.children.length > 0) {
            var children = find(test, elem.children, recurse, limit);
            result.push.apply(result, children);
            limit -= children.length;
            if (limit <= 0)
                break;
        }
    }
    return result;
}
exports.find = find;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 */
function findOneChild(test, nodes) {
    return nodes.find(test);
}
exports.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */
function findOne(test, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    var elem = null;
    for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!domhandler_1.isTag(checked)) {
            continue;
        }
        else if (test(checked)) {
            elem = checked;
        }
        else if (recurse && checked.children.length > 0) {
            elem = findOne(test, checked.children);
        }
    }
    return elem;
}
exports.findOne = findOne;
/**
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing a test.
 */
function existsOne(test, nodes) {
    return nodes.some(function (checked) {
        return domhandler_1.isTag(checked) &&
            (test(checked) ||
                (checked.children.length > 0 &&
                    existsOne(test, checked.children)));
    });
}
exports.existsOne = existsOne;
/**
 * Search and array of nodes and its children for nodes passing a test function.
 *
 * Same as `find`, only with less options, leading to reduced complexity.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll(test, nodes) {
    var _a;
    var result = [];
    var stack = nodes.filter(domhandler_1.isTag);
    var elem;
    while ((elem = stack.shift())) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
        if (children && children.length > 0) {
            stack.unshift.apply(stack, children);
        }
        if (test(elem))
            result.push(elem);
    }
    return result;
}
exports.findAll = findAll;


/***/ }),

/***/ 29561:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
var domhandler_1 = __nccwpck_require__(74038);
var dom_serializer_1 = __importDefault(__nccwpck_require__(48621));
var domelementtype_1 = __nccwpck_require__(53944);
/**
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
    return dom_serializer_1.default(node, options);
}
exports.getOuterHTML = getOuterHTML;
/**
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
    return domhandler_1.hasChildren(node)
        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
        : "";
}
exports.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
 *
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText(node) {
    if (Array.isArray(node))
        return node.map(getText).join("");
    if (domhandler_1.isTag(node))
        return node.name === "br" ? "\n" : getText(node.children);
    if (domhandler_1.isCDATA(node))
        return getText(node.children);
    if (domhandler_1.isText(node))
        return node.data;
    return "";
}
exports.getText = getText;
/**
 * Get a node's text content.
 *
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
    if (Array.isArray(node))
        return node.map(textContent).join("");
    if (domhandler_1.isTag(node))
        return textContent(node.children);
    if (domhandler_1.isCDATA(node))
        return textContent(node.children);
    if (domhandler_1.isText(node))
        return node.data;
    return "";
}
exports.textContent = textContent;
/**
 * Get a node's inner text.
 *
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
    if (Array.isArray(node))
        return node.map(innerText).join("");
    if (domhandler_1.hasChildren(node) && node.type === domelementtype_1.ElementType.Tag) {
        return innerText(node.children);
    }
    if (domhandler_1.isCDATA(node))
        return innerText(node.children);
    if (domhandler_1.isText(node))
        return node.data;
    return "";
}
exports.innerText = innerText;


/***/ }),

/***/ 79228:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
var domhandler_1 = __nccwpck_require__(74038);
var emptyArray = [];
/**
 * Get a node's children.
 *
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren(elem) {
    var _a;
    return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
}
exports.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */
function getParent(elem) {
    return elem.parent || null;
}
exports.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first.
 * If we don't have a parent (the element is a root node),
 * we walk the element's `prev` & `next` to get all remaining nodes.
 *
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */
function getSiblings(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
        return getChildren(parent);
    var siblings = [elem];
    var prev = elem.prev, next = elem.next;
    while (prev != null) {
        siblings.unshift(prev);
        (_a = prev, prev = _a.prev);
    }
    while (next != null) {
        siblings.push(next);
        (_b = next, next = _b.next);
    }
    return siblings;
}
exports.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
exports.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib(elem, name) {
    return (elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
        elem.attribs[name] != null);
}
exports.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName(elem) {
    return elem.name;
}
exports.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */
function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !domhandler_1.isTag(next))
        (_a = next, next = _a.next);
    return next;
}
exports.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag.
 */
function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !domhandler_1.isTag(prev))
        (_a = prev, prev = _a.prev);
    return prev;
}
exports.prevElementSibling = prevElementSibling;


/***/ }),

/***/ 46719:
/***/ ((module) => {

module.exports = {
	"0.20": "39",
	"0.21": "41",
	"0.22": "41",
	"0.23": "41",
	"0.24": "41",
	"0.25": "42",
	"0.26": "42",
	"0.27": "43",
	"0.28": "43",
	"0.29": "43",
	"0.30": "44",
	"0.31": "45",
	"0.32": "45",
	"0.33": "45",
	"0.34": "45",
	"0.35": "45",
	"0.36": "47",
	"0.37": "49",
	"1.0": "49",
	"1.1": "50",
	"1.2": "51",
	"1.3": "52",
	"1.4": "53",
	"1.5": "54",
	"1.6": "56",
	"1.7": "58",
	"1.8": "59",
	"2.0": "61",
	"2.1": "61",
	"3.0": "66",
	"3.1": "66",
	"4.0": "69",
	"4.1": "69",
	"4.2": "69",
	"5.0": "73",
	"6.0": "76",
	"6.1": "76",
	"7.0": "78",
	"7.1": "78",
	"7.2": "78",
	"7.3": "78",
	"8.0": "80",
	"8.1": "80",
	"8.2": "80",
	"8.3": "80",
	"8.4": "80",
	"8.5": "80",
	"9.0": "83",
	"9.1": "83",
	"9.2": "83",
	"9.3": "83",
	"9.4": "83",
	"10.0": "85",
	"10.1": "85",
	"10.2": "85",
	"10.3": "85",
	"10.4": "85",
	"11.0": "87",
	"11.1": "87",
	"11.2": "87",
	"11.3": "87",
	"11.4": "87",
	"12.0": "89",
	"13.0": "91",
	"13.1": "91",
	"13.2": "91",
	"14.0": "93",
	"15.0": "94"
};

/***/ }),

/***/ 85107:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
var entities_json_1 = __importDefault(__nccwpck_require__(84007));
var legacy_json_1 = __importDefault(__nccwpck_require__(17802));
var xml_json_1 = __importDefault(__nccwpck_require__(2228));
var decode_codepoint_1 = __importDefault(__nccwpck_require__(31227));
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
exports.decodeXML = getStrictDecoder(xml_json_1.default);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function (str) { return String(str).replace(strictEntityRe, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
exports.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        return map[str.slice(1, -1)] || str;
    };
}


/***/ }),

/***/ 31227:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var decode_json_1 = __importDefault(__nccwpck_require__(14589));
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
var fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint ||
    function (codePoint) {
        var output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint(codePoint);
}
exports.default = decodeCodePoint;


/***/ }),

/***/ 2006:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
var xml_json_1 = __importDefault(__nccwpck_require__(2228));
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault(__nccwpck_require__(84007));
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
/**
 * Encodes all entities and non-ASCII characters in the input.
 *
 * This includes characters that are valid ASCII characters in HTML documents.
 * For example `#` will be encoded as `&num;`. To get a more compact output,
 * consider using the `encodeNonAsciiHTML` function.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
// /[^\0-\x7F]/gu
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function (str) { return str.codePointAt(0); }
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function (c) {
            return (c.charCodeAt(0) - 0xd800) * 0x400 +
                c.charCodeAt(1) -
                0xdc00 +
                0x10000;
        };
function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
        .toString(16)
        .toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
}
exports.escape = escape;
/**
 * Encodes all characters not valid in XML documents using numeric hexadecimal
 * reference (eg. `&#xfc;`).
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
}
exports.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
    return function (data) {
        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
    };
}


/***/ }),

/***/ 3000:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = __nccwpck_require__(85107);
var encode_1 = __nccwpck_require__(2006);
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeXML` or `decodeHTML` directly.
 */
function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
 */
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
 */
function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = __nccwpck_require__(2006);
Object.defineProperty(exports, "encodeXML", ({ enumerable: true, get: function () { return encode_2.encodeXML; } }));
Object.defineProperty(exports, "encodeHTML", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));
Object.defineProperty(exports, "encodeNonAsciiHTML", ({ enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } }));
Object.defineProperty(exports, "escape", ({ enumerable: true, get: function () { return encode_2.escape; } }));
Object.defineProperty(exports, "escapeUTF8", ({ enumerable: true, get: function () { return encode_2.escapeUTF8; } }));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));
Object.defineProperty(exports, "encodeHTML5", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));
var decode_2 = __nccwpck_require__(85107);
Object.defineProperty(exports, "decodeXML", ({ enumerable: true, get: function () { return decode_2.decodeXML; } }));
Object.defineProperty(exports, "decodeHTML", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTMLStrict", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTML5", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTML4Strict", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeHTML5Strict", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeXMLStrict", ({ enumerable: true, get: function () { return decode_2.decodeXML; } }));


/***/ }),

/***/ 85729:
/***/ (function(module) {

/**
 * @license Fraction.js v4.1.1 23/05/2021
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/


/**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <nominator>, 1 => <denominator> ]
 * [ n => <nominator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */

(function(root) {

  "use strict";

  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
  var MAX_CYCLE_LEN = 2000;

  // Parsed data to avoid calling "new" all the time
  var P = {
    "s": 1,
    "n": 0,
    "d": 1
  };

  function createError(name) {

    function errorConstructor() {
      var temp = Error.apply(this, arguments);
      temp['name'] = this['name'] = name;
      this['stack'] = temp['stack'];
      this['message'] = temp['message'];
    }

    /**
     * Error constructor
     *
     * @constructor
     */
    function IntermediateInheritor() { }
    IntermediateInheritor.prototype = Error.prototype;
    errorConstructor.prototype = new IntermediateInheritor();

    return errorConstructor;
  }

  var DivisionByZero = Fraction['DivisionByZero'] = createError('DivisionByZero');
  var InvalidParameter = Fraction['InvalidParameter'] = createError('InvalidParameter');

  function assign(n, s) {

    if (isNaN(n = parseInt(n, 10))) {
      throwInvalidParam();
    }
    return n * s;
  }

  function throwInvalidParam() {
    throw new InvalidParameter();
  }

  function factorize(num) {

    var factors = {};

    var n = num;
    var i = 2;
    var s = 4;

    while (s <= n) {

      while (n % i === 0) {
        n /= i;
        factors[i] = (factors[i] || 0) + 1;
      }
      s += 1 + 2 * i++;
    }

    if (n !== num) {
      if (n > 1)
      factors[n] = (factors[n] || 0) + 1;
    } else {
      factors[num] = (factors[num] || 0) + 1;
    }
    return factors;
  }

  var parse = function(p1, p2) {

    var n = 0, d = 1, s = 1;
    var v = 0, w = 0, x = 0, y = 1, z = 1;

    var A = 0, B = 1;
    var C = 1, D = 1;

    var N = 10000000;
    var M;

    if (p1 === undefined || p1 === null) {
      /* void */
    } else if (p2 !== undefined) {
      n = p1;
      d = p2;
      s = n * d;
    } else
      switch (typeof p1) {

        case "object":
          {
            if ("d" in p1 && "n" in p1) {
              n = p1["n"];
              d = p1["d"];
              if ("s" in p1)
                n *= p1["s"];
            } else if (0 in p1) {
              n = p1[0];
              if (1 in p1)
                d = p1[1];
            } else {
              throwInvalidParam();
            }
            s = n * d;
            break;
          }
        case "number":
          {
            if (p1 < 0) {
              s = p1;
              p1 = -p1;
            }

            if (p1 % 1 === 0) {
              n = p1;
            } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

              if (p1 >= 1) {
                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                p1 /= z;
              }

              // Using Farey Sequences
              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

              while (B <= N && D <= N) {
                M = (A + C) / (B + D);

                if (p1 === M) {
                  if (B + D <= N) {
                    n = A + C;
                    d = B + D;
                  } else if (D > B) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                  break;

                } else {

                  if (p1 > M) {
                    A += C;
                    B += D;
                  } else {
                    C += A;
                    D += B;
                  }

                  if (B > N) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                }
              }
              n *= z;
            } else if (isNaN(p1) || isNaN(p2)) {
              d = n = NaN;
            }
            break;
          }
        case "string":
          {
            B = p1.match(/\d+|./g);

            if (B === null)
              throwInvalidParam();

            if (B[A] === '-') {// Check for minus sign at the beginning
              s = -1;
              A++;
            } else if (B[A] === '+') {// Check for plus sign at the beginning
              A++;
            }

            if (B.length === A + 1) { // Check if it's just a simple number "1234"
              w = assign(B[A++], s);
            } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number

              if (B[A] !== '.') { // Handle 0.5 and .5
                v = assign(B[A++], s);
              }
              A++;

              // Check for decimal places
              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                w = assign(B[A], s);
                y = Math.pow(10, B[A].length);
                A++;
              }

              // Check for repeating places
              if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                x = assign(B[A + 1], s);
                z = Math.pow(10, B[A + 1].length) - 1;
                A += 3;
              }

            } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction "123/456" or "123:456"
              w = assign(B[A], s);
              y = assign(B[A + 2], 1);
              A += 3;
            } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction "123 1/2"
              v = assign(B[A], s);
              w = assign(B[A + 2], s);
              y = assign(B[A + 4], 1);
              A += 5;
            }

            if (B.length <= A) { // Check for more tokens on the stack
              d = y * z;
              s = /* void */
              n = x + d * v + z * w;
              break;
            }

            /* Fall through on error */
          }
        default:
          throwInvalidParam();
      }

    if (d === 0) {
      throw new DivisionByZero();
    }

    P["s"] = s < 0 ? -1 : 1;
    P["n"] = Math.abs(n);
    P["d"] = Math.abs(d);
  };

  function modpow(b, e, m) {

    var r = 1;
    for (; e > 0; b = (b * b) % m, e >>= 1) {

      if (e & 1) {
        r = (r * b) % m;
      }
    }
    return r;
  }


  function cycleLen(n, d) {

    for (; d % 2 === 0;
      d /= 2) {
    }

    for (; d % 5 === 0;
      d /= 5) {
    }

    if (d === 1) // Catch non-cyclic numbers
      return 0;

    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
    // 10^(d-1) % d == 1
    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
    // as we want to translate the numbers to strings.

    var rem = 10 % d;
    var t = 1;

    for (; rem !== 1; t++) {
      rem = rem * 10 % d;

      if (t > MAX_CYCLE_LEN)
        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
    }
    return t;
  }


  function cycleStart(n, d, len) {

    var rem1 = 1;
    var rem2 = modpow(10, len, d);

    for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)
      // Solve 10^s == 10^(s+t) (mod d)

      if (rem1 === rem2)
        return t;

      rem1 = rem1 * 10 % d;
      rem2 = rem2 * 10 % d;
    }
    return 0;
  }

  function gcd(a, b) {

    if (!a)
      return b;
    if (!b)
      return a;

    while (1) {
      a %= b;
      if (!a)
        return b;
      b %= a;
      if (!b)
        return a;
    }
  };

  /**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction=} a
   * @param {number=} b
   */
  function Fraction(a, b) {

    if (!(this instanceof Fraction)) {
      return new Fraction(a, b);
    }

    parse(a, b);

    if (Fraction['REDUCE']) {
      a = gcd(P["d"], P["n"]); // Abuse a
    } else {
      a = 1;
    }

    this["s"] = P["s"];
    this["n"] = P["n"] / a;
    this["d"] = P["d"] / a;
  }

  /**
   * Boolean global variable to be able to disable automatic reduction of the fraction
   *
   */
  Fraction['REDUCE'] = 1;

  Fraction.prototype = {

    "s": 1,
    "n": 0,
    "d": 1,

    /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/
    "abs": function() {

      return new Fraction(this["n"], this["d"]);
    },

    /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/
    "neg": function() {

      return new Fraction(-this["s"] * this["n"], this["d"]);
    },

    /**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
     **/
    "add": function(a, b) {

      parse(a, b);
      return new Fraction(
        this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
     **/
    "sub": function(a, b) {

      parse(a, b);
      return new Fraction(
        this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/
    "mul": function(a, b) {

      parse(a, b);
      return new Fraction(
        this["s"] * P["s"] * this["n"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/
    "div": function(a, b) {

      parse(a, b);
      return new Fraction(
        this["s"] * P["s"] * this["n"] * P["d"],
        this["d"] * P["n"]
      );
    },

    /**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/
    "clone": function() {
      return new Fraction(this);
    },

    /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/
    "mod": function(a, b) {

      if (isNaN(this['n']) || isNaN(this['d'])) {
        return new Fraction(NaN);
      }

      if (a === undefined) {
        return new Fraction(this["s"] * this["n"] % this["d"], 1);
      }

      parse(a, b);
      if (0 === P["n"] && 0 === this["d"]) {
        Fraction(0, 0); // Throw DivisionByZero
      }

      /*
       * First silly attempt, kinda slow
       *
       return that["sub"]({
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
       });*/

      /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */
      return new Fraction(
        this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
        P["d"] * this["d"]
      );
    },

    /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */
    "gcd": function(a, b) {

      parse(a, b);

      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

      return new Fraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
    },

    /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */
    "lcm": function(a, b) {

      parse(a, b);

      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

      if (P["n"] === 0 && this["n"] === 0) {
        return new Fraction;
      }
      return new Fraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
    },

    /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/
    "ceil": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return new Fraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/
    "floor": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return new Fraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/
    "round": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return new Fraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Gets the inverse of the fraction, means numerator and denominator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/
    "inverse": function() {

      return new Fraction(this["s"] * this["d"], this["n"]);
    },

    /**
     * Calculates the fraction to some rational exponent, if possible
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */
    "pow": function(a, b) {

      parse(a, b);

      // Trivial case when exp is an integer

      if (P['d'] === 1) {

        if (P['s'] < 0) {
          return new Fraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
        } else {
          return new Fraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
        }
      }

      // Negative roots become complex
      //     (-a/b)^(c/d) = x
      // <=> (-1)^(c/d) * (a/b)^(c/d) = x
      // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180
      // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
      // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
      if (this['s'] < 0) return null;

      // Now prime factor n and d
      var N = factorize(this['n']);
      var D = factorize(this['d']);

      // Exponentiate and take root for n and d individually
      var n = 1;
      var d = 1;
      for (var k in N) {
        if (k === '1') continue;
        if (k === '0') {
          n = 0;
          break;
        }
        N[k]*= P['n'];

        if (N[k] % P['d'] === 0) {
          N[k]/= P['d'];
        } else return null;
        n*= Math.pow(k, N[k]);
      }

      for (var k in D) {
        if (k === '1') continue;
        D[k]*= P['n'];

        if (D[k] % P['d'] === 0) {
          D[k]/= P['d'];
        } else return null;
        d*= Math.pow(k, D[k]);
      }

      if (P['s'] < 0) {
        return new Fraction(d, n);
      }
      return new Fraction(n, d);
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "equals": function(a, b) {

      parse(a, b);
      return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "compare": function(a, b) {

      parse(a, b);
      var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
      return (0 < t) - (t < 0);
    },

    "simplify": function(eps) {

      // First naive implementation, needs improvement

      if (isNaN(this['n']) || isNaN(this['d'])) {
        return this;
      }

      var cont = this['abs']()['toContinued']();

      eps = eps || 0.001;

      function rec(a) {
        if (a.length === 1)
          return new Fraction(a[0]);
        return rec(a.slice(1))['inverse']()['add'](a[0]);
      }

      for (var i = 0; i < cont.length; i++) {
        var tmp = rec(cont.slice(0, i + 1));
        if (tmp['sub'](this['abs']())['abs']().valueOf() < eps) {
          return tmp['mul'](this['s']);
        }
      }
      return this;
    },

    /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */
    "divisible": function(a, b) {

      parse(a, b);
      return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
    },

    /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/
    'valueOf': function() {

      return this["s"] * this["n"] / this["d"];
    },

    /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
     **/
    'toFraction': function(excludeWhole) {

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) {
        str += '-';
      }

      if (d === 1) {
        str += n;
      } else {

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
          str += whole;
          str += " ";
          n %= d;
        }

        str += n;
        str += '/';
        str += d;
      }
      return str;
    },

    /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
     **/
    'toLatex': function(excludeWhole) {

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) {
        str += '-';
      }

      if (d === 1) {
        str += n;
      } else {

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
          str += whole;
          n %= d;
        }

        str += "\\frac{";
        str += n;
        str += '}{';
        str += d;
        str += '}';
      }
      return str;
    },

    /**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */
    'toContinued': function() {

      var t;
      var a = this['n'];
      var b = this['d'];
      var res = [];

      if (isNaN(a) || isNaN(b)) {
        return res;
      }

      do {
        res.push(Math.floor(a / b));
        t = a % b;
        a = b;
        b = t;
      } while (a !== 1);

      return res;
    },

    /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/
    'toString': function(dec) {

      var g;
      var N = this["n"];
      var D = this["d"];

      if (isNaN(N) || isNaN(D)) {
        return "NaN";
      }

      if (!Fraction['REDUCE']) {
        g = gcd(N, D);
        N /= g;
        D /= g;
      }

      dec = dec || 15; // 15 = decimal places when no repetation

      var cycLen = cycleLen(N, D); // Cycle length
      var cycOff = cycleStart(N, D, cycLen); // Cycle start

      var str = this['s'] === -1 ? "-" : "";

      str += N / D | 0;

      N %= D;
      N *= 10;

      if (N)
        str += ".";

      if (cycLen) {

        for (var i = cycOff; i--;) {
          str += N / D | 0;
          N %= D;
          N *= 10;
        }
        str += "(";
        for (var i = cycLen; i--;) {
          str += N / D | 0;
          N %= D;
          N *= 10;
        }
        str += ")";
      } else {
        for (var i = dec; N && i--;) {
          str += N / D | 0;
          N %= D;
          N *= 10;
        }
      }
      return str;
    }
  };

  if (typeof define === "function" && define["amd"]) {
    define([], function() {
      return Fraction;
    });
  } else if (true) {
    Object.defineProperty(Fraction, "__esModule", { 'value': true });
    Fraction['default'] = Fraction;
    Fraction['Fraction'] = Fraction;
    module['exports'] = Fraction;
  } else {}

})(this);


/***/ }),

/***/ 34064:
/***/ ((module) => {

"use strict";


module.exports = url => {
	if (typeof url !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof url}\``);
	}

	// Don't match Windows paths `c:\`
	if (/^[a-zA-Z]:\\/.test(url)) {
		return false;
	}

	// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
	// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
	return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url);
};


/***/ }),

/***/ 80922:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var inspect = __nccwpck_require__(31669).inspect;

module.exports = function isResolvable(moduleId, options) {
	if (typeof moduleId !== 'string') {
		throw new TypeError(inspect(moduleId) + ' is not a string. Expected a valid Node.js module identifier (<string>), for example \'eslint\', \'./index.js\', \'./lib\'.');
	}

	try {
		require.resolve(moduleId, options);
		return true;
	} catch (err) {
		return false;
	}
};


/***/ }),

/***/ 73727:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;
const path = __nccwpck_require__(85622);
const fs = __nccwpck_require__(35747);
const os = __nccwpck_require__(12087);
const fsReadFileAsync = fs.promises.readFile;
function getDefaultSearchPlaces(name) {
    return [
        'package.json',
        `.${name}rc.json`,
        `.${name}rc.js`,
        `${name}.config.js`,
        `.${name}rc.cjs`,
        `${name}.config.cjs`,
    ];
}
function getSearchPaths(startDir, stopDir) {
    return startDir
        .split(path.sep)
        .reduceRight((acc, _, ind, arr) => {
        const currentPath = arr.slice(0, ind + 1).join(path.sep);
        if (!acc.passedStopDir)
            acc.searchPlaces.push(currentPath || path.sep);
        if (currentPath === stopDir)
            acc.passedStopDir = true;
        return acc;
    }, { searchPlaces: [], passedStopDir: false }).searchPlaces;
}
exports.defaultLoaders = Object.freeze({
    '.js': require,
    '.json': require,
    '.cjs': require,
    noExt(_, content) {
        return JSON.parse(content);
    },
});
function getExtDesc(ext) {
    return ext === 'noExt' ? 'files without extensions' : `extension "${ext}"`;
}
function getOptions(name, options = {}) {
    const conf = {
        stopDir: os.homedir(),
        searchPlaces: getDefaultSearchPlaces(name),
        ignoreEmptySearchPlaces: true,
        transform: (x) => x,
        packageProp: [name],
        ...options,
        loaders: { ...exports.defaultLoaders, ...options.loaders },
    };
    conf.searchPlaces.forEach(place => {
        const key = path.extname(place) || 'noExt';
        const loader = conf.loaders[key];
        if (!loader) {
            throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item "${place}" is invalid`);
        }
        if (typeof loader !== 'function') {
            throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
        }
    });
    return conf;
}
function getPackageProp(props, obj) {
    if (typeof props === 'string' && props in obj)
        return obj[props];
    return ((Array.isArray(props) ? props : props.split('.')).reduce((acc, prop) => (acc === undefined ? acc : acc[prop]), obj) || null);
}
function getSearchItems(searchPlaces, searchPaths) {
    return searchPaths.reduce((acc, searchPath) => {
        searchPlaces.forEach(fileName => acc.push({
            fileName,
            filepath: path.join(searchPath, fileName),
            loaderKey: path.extname(fileName) || 'noExt',
        }));
        return acc;
    }, []);
}
function validateFilePath(filepath) {
    if (!filepath)
        throw new Error('load must pass a non-empty string');
}
function validateLoader(loader, ext) {
    if (!loader)
        throw new Error(`No loader specified for extension "${ext}"`);
    if (typeof loader !== 'function')
        throw new Error('loader is not a function');
}
function lilconfig(name, options) {
    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, } = getOptions(name, options);
    return {
        async search(searchFrom = process.cwd()) {
            const searchPaths = getSearchPaths(searchFrom, stopDir);
            const result = {
                config: null,
                filepath: '',
            };
            const searchItems = getSearchItems(searchPlaces, searchPaths);
            for (const { fileName, filepath, loaderKey } of searchItems) {
                try {
                    await fs.promises.access(filepath);
                }
                catch (_a) {
                    continue;
                }
                const content = String(await fsReadFileAsync(filepath));
                const loader = loaders[loaderKey];
                if (fileName === 'package.json') {
                    const pkg = loader(filepath, content);
                    const maybeConfig = getPackageProp(packageProp, pkg);
                    if (maybeConfig != null) {
                        result.config = maybeConfig;
                        result.filepath = filepath;
                        break;
                    }
                    continue;
                }
                const isEmpty = content.trim() === '';
                if (isEmpty && ignoreEmptySearchPlaces)
                    continue;
                if (isEmpty) {
                    result.isEmpty = true;
                    result.config = undefined;
                }
                else {
                    validateLoader(loader, loaderKey);
                    result.config = loader(filepath, content);
                }
                result.filepath = filepath;
                break;
            }
            if (result.filepath === '' && result.config === null)
                return transform(null);
            return transform(result);
        },
        async load(filepath) {
            validateFilePath(filepath);
            const { base, ext } = path.parse(filepath);
            const loaderKey = ext || 'noExt';
            const loader = loaders[loaderKey];
            validateLoader(loader, loaderKey);
            const content = String(await fsReadFileAsync(filepath));
            if (base === 'package.json') {
                const pkg = await loader(filepath, content);
                return transform({
                    config: getPackageProp(packageProp, pkg),
                    filepath,
                });
            }
            const result = {
                config: null,
                filepath,
            };
            const isEmpty = content.trim() === '';
            if (isEmpty && ignoreEmptySearchPlaces)
                return transform({
                    config: undefined,
                    filepath,
                    isEmpty: true,
                });
            result.config = isEmpty
                ? undefined
                : await loader(filepath, content);
            return transform(isEmpty ? { ...result, isEmpty, config: undefined } : result);
        },
    };
}
exports.lilconfig = lilconfig;
function lilconfigSync(name, options) {
    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, } = getOptions(name, options);
    return {
        search(searchFrom = process.cwd()) {
            const searchPaths = getSearchPaths(searchFrom, stopDir);
            const result = {
                config: null,
                filepath: '',
            };
            const searchItems = getSearchItems(searchPlaces, searchPaths);
            for (const { fileName, filepath, loaderKey } of searchItems) {
                try {
                    fs.accessSync(filepath);
                }
                catch (_a) {
                    continue;
                }
                const loader = loaders[loaderKey];
                const content = String(fs.readFileSync(filepath));
                if (fileName === 'package.json') {
                    const pkg = loader(filepath, content);
                    const maybeConfig = getPackageProp(packageProp, pkg);
                    if (maybeConfig != null) {
                        result.config = maybeConfig;
                        result.filepath = filepath;
                        break;
                    }
                    continue;
                }
                const isEmpty = content.trim() === '';
                if (isEmpty && ignoreEmptySearchPlaces)
                    continue;
                if (isEmpty) {
                    result.isEmpty = true;
                    result.config = undefined;
                }
                else {
                    validateLoader(loader, loaderKey);
                    result.config = loader(filepath, content);
                }
                result.filepath = filepath;
                break;
            }
            if (result.filepath === '' && result.config === null)
                return transform(null);
            return transform(result);
        },
        load(filepath) {
            validateFilePath(filepath);
            const { base, ext } = path.parse(filepath);
            const loaderKey = ext || 'noExt';
            const loader = loaders[loaderKey];
            validateLoader(loader, loaderKey);
            const content = String(fs.readFileSync(filepath));
            if (base === 'package.json') {
                const pkg = loader(filepath, content);
                return transform({
                    config: getPackageProp(packageProp, pkg),
                    filepath,
                });
            }
            const result = {
                config: null,
                filepath,
            };
            const isEmpty = content.trim() === '';
            if (isEmpty && ignoreEmptySearchPlaces)
                return transform({
                    filepath,
                    config: undefined,
                    isEmpty: true,
                });
            result.config = isEmpty ? undefined : loader(filepath, content);
            return transform(isEmpty ? { ...result, isEmpty, config: undefined } : result);
        },
    };
}
exports.lilconfigSync = lilconfigSync;


/***/ }),

/***/ 24538:
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = memoize;


/***/ }),

/***/ 78216:
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    Set = getNative(root, 'Set'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = uniq;


/***/ }),

/***/ 24251:
/***/ ((module) => {

"use strict";

module.exports = {
  wrap: wrapRange,
  limit: limitRange,
  validate: validateRange,
  test: testRange,
  curry: curry,
  name: name
};

function wrapRange(min, max, value) {
  var maxLessMin = max - min;
  return ((value - min) % maxLessMin + maxLessMin) % maxLessMin + min;
}

function limitRange(min, max, value) {
  return Math.max(min, Math.min(max, value));
}

function validateRange(min, max, value, minExclusive, maxExclusive) {
  if (!testRange(min, max, value, minExclusive, maxExclusive)) {
    throw new Error(value + ' is outside of range [' + min + ',' + max + ')');
  }
  return value;
}

function testRange(min, max, value, minExclusive, maxExclusive) {
  return !(
       value < min ||
       value > max ||
       (maxExclusive && (value === max)) ||
       (minExclusive && (value === min))
  );
}

function name(min, max, minExcl, maxExcl) {
  return (minExcl ? '(' : '[') + min + ',' + max + (maxExcl ? ')' : ']');
}

function curry(min, max, minExclusive, maxExclusive) {
  var boundNameFn = name.bind(null, min, max, minExclusive, maxExclusive);
  return {
    wrap: wrapRange.bind(null, min, max),
    limit: limitRange.bind(null, min, max),
    validate: function(value) {
      return validateRange(min, max, value, minExclusive, maxExclusive);
    },
    test: function(value) {
      return testRange(min, max, value, minExclusive, maxExclusive);
    },
    toString: boundNameFn,
    name: boundNameFn
  };
}


/***/ }),

/***/ 17952:
/***/ ((module) => {

"use strict";


// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
const DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';
const DATA_URL_DEFAULT_CHARSET = 'us-ascii';

const testParameter = (name, filters) => {
	return filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);
};

const normalizeDataURL = (urlString, {stripHash}) => {
	const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);

	if (!match) {
		throw new Error(`Invalid URL: ${urlString}`);
	}

	let {type, data, hash} = match.groups;
	const mediaType = type.split(';');
	hash = stripHash ? '' : hash;

	let isBase64 = false;
	if (mediaType[mediaType.length - 1] === 'base64') {
		mediaType.pop();
		isBase64 = true;
	}

	// Lowercase MIME type
	const mimeType = (mediaType.shift() || '').toLowerCase();
	const attributes = mediaType
		.map(attribute => {
			let [key, value = ''] = attribute.split('=').map(string => string.trim());

			// Lowercase `charset`
			if (key === 'charset') {
				value = value.toLowerCase();

				if (value === DATA_URL_DEFAULT_CHARSET) {
					return '';
				}
			}

			return `${key}${value ? `=${value}` : ''}`;
		})
		.filter(Boolean);

	const normalizedMediaType = [
		...attributes
	];

	if (isBase64) {
		normalizedMediaType.push('base64');
	}

	if (normalizedMediaType.length !== 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {
		normalizedMediaType.unshift(mimeType);
	}

	return `data:${normalizedMediaType.join(';')},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ''}`;
};

const normalizeUrl = (urlString, options) => {
	options = {
		defaultProtocol: 'http:',
		normalizeProtocol: true,
		forceHttp: false,
		forceHttps: false,
		stripAuthentication: true,
		stripHash: false,
		stripTextFragment: true,
		stripWWW: true,
		removeQueryParameters: [/^utm_\w+/i],
		removeTrailingSlash: true,
		removeSingleSlash: true,
		removeDirectoryIndex: false,
		sortQueryParameters: true,
		...options
	};

	urlString = urlString.trim();

	// Data URL
	if (/^data:/i.test(urlString)) {
		return normalizeDataURL(urlString, options);
	}

	if (/^view-source:/i.test(urlString)) {
		throw new Error('`view-source:` is not supported as it is a non-standard protocol');
	}

	const hasRelativeProtocol = urlString.startsWith('//');
	const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);

	// Prepend protocol
	if (!isRelativeUrl) {
		urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
	}

	const urlObj = new URL(urlString);

	if (options.forceHttp && options.forceHttps) {
		throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
	}

	if (options.forceHttp && urlObj.protocol === 'https:') {
		urlObj.protocol = 'http:';
	}

	if (options.forceHttps && urlObj.protocol === 'http:') {
		urlObj.protocol = 'https:';
	}

	// Remove auth
	if (options.stripAuthentication) {
		urlObj.username = '';
		urlObj.password = '';
	}

	// Remove hash
	if (options.stripHash) {
		urlObj.hash = '';
	} else if (options.stripTextFragment) {
		urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, '');
	}

	// Remove duplicate slashes if not preceded by a protocol
	if (urlObj.pathname) {
		urlObj.pathname = urlObj.pathname.replace(/(?<!\b(?:[a-z][a-z\d+\-.]{1,50}:))\/{2,}/g, '/');
	}

	// Decode URI octets
	if (urlObj.pathname) {
		try {
			urlObj.pathname = decodeURI(urlObj.pathname);
		} catch (_) {}
	}

	// Remove directory index
	if (options.removeDirectoryIndex === true) {
		options.removeDirectoryIndex = [/^index\.[a-z]+$/];
	}

	if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
		let pathComponents = urlObj.pathname.split('/');
		const lastComponent = pathComponents[pathComponents.length - 1];

		if (testParameter(lastComponent, options.removeDirectoryIndex)) {
			pathComponents = pathComponents.slice(0, pathComponents.length - 1);
			urlObj.pathname = pathComponents.slice(1).join('/') + '/';
		}
	}

	if (urlObj.hostname) {
		// Remove trailing dot
		urlObj.hostname = urlObj.hostname.replace(/\.$/, '');

		// Remove `www.`
		if (options.stripWWW && /^www\.(?!www\.)(?:[a-z\-\d]{1,63})\.(?:[a-z.\-\d]{2,63})$/.test(urlObj.hostname)) {
			// Each label should be max 63 at length (min: 1).
			// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
			// Each TLD should be up to 63 characters long (min: 2).
			// It is technically possible to have a single character TLD, but none currently exist.
			urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
		}
	}

	// Remove query unwanted parameters
	if (Array.isArray(options.removeQueryParameters)) {
		for (const key of [...urlObj.searchParams.keys()]) {
			if (testParameter(key, options.removeQueryParameters)) {
				urlObj.searchParams.delete(key);
			}
		}
	}

	if (options.removeQueryParameters === true) {
		urlObj.search = '';
	}

	// Sort query parameters
	if (options.sortQueryParameters) {
		urlObj.searchParams.sort();
	}

	if (options.removeTrailingSlash) {
		urlObj.pathname = urlObj.pathname.replace(/\/$/, '');
	}

	const oldUrlString = urlString;

	// Take advantage of many of the Node `url` normalizations
	urlString = urlObj.toString();

	if (!options.removeSingleSlash && urlObj.pathname === '/' && !oldUrlString.endsWith('/') && urlObj.hash === '') {
		urlString = urlString.replace(/\/$/, '');
	}

	// Remove ending `/` unless removeSingleSlash is false
	if ((options.removeTrailingSlash || urlObj.pathname === '/') && urlObj.hash === '' && options.removeSingleSlash) {
		urlString = urlString.replace(/\/$/, '');
	}

	// Restore relative protocol, if applicable
	if (hasRelativeProtocol && !options.normalizeProtocol) {
		urlString = urlString.replace(/^http:\/\//, '//');
	}

	// Remove http/https
	if (options.stripProtocol) {
		urlString = urlString.replace(/^(?:https?:)?\/\//, '');
	}

	return urlString;
};

module.exports = normalizeUrl;


/***/ }),

/***/ 29241:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compile = void 0;
var boolbase_1 = __nccwpck_require__(44159);
/**
 * Returns a function that checks if an elements index matches the given rule
 * highly optimized to return the fastest solution.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A highly optimized function that returns whether an index matches the nth-check.
 * @example
 * const check = nthCheck.compile([2, 3]);
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function compile(parsed) {
    var a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    var b = parsed[1] - 1;
    /*
     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
     * Besides, the specification states that no elements are
     * matched when `a` and `b` are 0.
     *
     * `b < 0` here as we subtracted 1 from `b` above.
     */
    if (b < 0 && a <= 0)
        return boolbase_1.falseFunc;
    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
    if (a === -1)
        return function (index) { return index <= b; };
    if (a === 0)
        return function (index) { return index === b; };
    // When `b <= 0` and `a === 1`, they match any element.
    if (a === 1)
        return b < 0 ? boolbase_1.trueFunc : function (index) { return index >= b; };
    /*
     * Otherwise, modulo can be used to check if there is a match.
     *
     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
     */
    var absA = Math.abs(a);
    // Get `b mod a`, + a if this is negative.
    var bMod = ((b % absA) + absA) % absA;
    return a > 1
        ? function (index) { return index >= b && index % absA === bMod; }
        : function (index) { return index <= b && index % absA === bMod; };
}
exports.compile = compile;


/***/ }),

/***/ 51260:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compile = exports.parse = void 0;
var parse_1 = __nccwpck_require__(57869);
Object.defineProperty(exports, "parse", ({ enumerable: true, get: function () { return parse_1.parse; } }));
var compile_1 = __nccwpck_require__(29241);
Object.defineProperty(exports, "compile", ({ enumerable: true, get: function () { return compile_1.compile; } }));
/**
 * Parses and compiles a formula to a highly optimized function.
 * Combination of `parse` and `compile`.
 *
 * If the formula doesn't match any elements,
 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
 * Otherwise, a function accepting an _index_ is returned, which returns
 * whether or not the passed _index_ matches the formula.
 *
 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
 *
 * @param formula The formula to compile.
 * @example
 * const check = nthCheck("2n+3");
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function nthCheck(formula) {
    return (0, compile_1.compile)((0, parse_1.parse)(formula));
}
exports.default = nthCheck;


/***/ }),

/***/ 57869:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = void 0;
// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
var whitespace = new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
/**
 * Parses an expression.
 *
 * @throws An `Error` if parsing fails.
 * @returns An array containing the integer step size and the integer offset of the nth rule.
 * @example nthCheck.parse("2n+3"); // returns [2, 3]
 */
function parse(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") {
        return [2, 0];
    }
    else if (formula === "odd") {
        return [2, 1];
    }
    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
    var idx = 0;
    var a = 0;
    var sign = readSign();
    var number = readNumber();
    if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
            sign = readSign();
            skipWhitespace();
            number = readNumber();
        }
        else {
            sign = number = 0;
        }
    }
    // Throw if there is anything else
    if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('" + formula + "')");
    }
    return [a, sign * number];
    function readSign() {
        if (formula.charAt(idx) === "-") {
            idx++;
            return -1;
        }
        if (formula.charAt(idx) === "+") {
            idx++;
        }
        return 1;
    }
    function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length &&
            formula.charCodeAt(idx) >= ZERO &&
            formula.charCodeAt(idx) <= NINE) {
            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
            idx++;
        }
        // Return `null` if we didn't read anything.
        return idx === start ? null : value;
    }
    function skipWhitespace() {
        while (idx < formula.length &&
            whitespace.has(formula.charCodeAt(idx))) {
            idx++;
        }
    }
}
exports.parse = parse;


/***/ }),

/***/ 31624:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _transform = _interopRequireDefault(__nccwpck_require__(23854));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function pluginCreator(opts) {
  const options = Object.assign({
    precision: 5,
    preserve: false,
    warnWhenCannotResolve: false,
    mediaQueries: false,
    selectors: false
  }, opts);
  return {
    postcssPlugin: 'postcss-calc',

    OnceExit(css, {
      result
    }) {
      css.walk(node => {
        const {
          type
        } = node;

        if (type === 'decl') {
          (0, _transform.default)(node, "value", options, result);
        }

        if (type === 'atrule' && options.mediaQueries) {
          (0, _transform.default)(node, "params", options, result);
        }

        if (type === 'rule' && options.selectors) {
          (0, _transform.default)(node, "selector", options, result);
        }
      });
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 65313:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
const conversions = {
  // Absolute length units
  'px': {
    'px': 1,
    'cm': 96 / 2.54,
    'mm': 96 / 25.4,
    'q': 96 / 101.6,
    'in': 96,
    'pt': 96 / 72,
    'pc': 16
  },
  'cm': {
    'px': 2.54 / 96,
    'cm': 1,
    'mm': 0.1,
    'q': 0.025,
    'in': 2.54,
    'pt': 2.54 / 72,
    'pc': 2.54 / 6
  },
  'mm': {
    'px': 25.4 / 96,
    'cm': 10,
    'mm': 1,
    'q': 0.25,
    'in': 25.4,
    'pt': 25.4 / 72,
    'pc': 25.4 / 6
  },
  'q': {
    'px': 101.6 / 96,
    'cm': 40,
    'mm': 4,
    'q': 1,
    'in': 101.6,
    'pt': 101.6 / 72,
    'pc': 101.6 / 6
  },
  'in': {
    'px': 1 / 96,
    'cm': 1 / 2.54,
    'mm': 1 / 25.4,
    'q': 1 / 101.6,
    'in': 1,
    'pt': 1 / 72,
    'pc': 1 / 6
  },
  'pt': {
    'px': 0.75,
    'cm': 72 / 2.54,
    'mm': 72 / 25.4,
    'q': 72 / 101.6,
    'in': 72,
    'pt': 1,
    'pc': 12
  },
  'pc': {
    'px': 0.0625,
    'cm': 6 / 2.54,
    'mm': 6 / 25.4,
    'q': 6 / 101.6,
    'in': 6,
    'pt': 6 / 72,
    'pc': 1
  },
  // Angle units
  'deg': {
    'deg': 1,
    'grad': 0.9,
    'rad': 180 / Math.PI,
    'turn': 360
  },
  'grad': {
    'deg': 400 / 360,
    'grad': 1,
    'rad': 200 / Math.PI,
    'turn': 400
  },
  'rad': {
    'deg': Math.PI / 180,
    'grad': Math.PI / 200,
    'rad': 1,
    'turn': Math.PI * 2
  },
  'turn': {
    'deg': 1 / 360,
    'grad': 0.0025,
    'rad': 0.5 / Math.PI,
    'turn': 1
  },
  // Duration units
  's': {
    's': 1,
    'ms': 0.001
  },
  'ms': {
    's': 1000,
    'ms': 1
  },
  // Frequency units
  'hz': {
    'hz': 1,
    'khz': 1000
  },
  'khz': {
    'hz': 0.001,
    'khz': 1
  },
  // Resolution units
  'dpi': {
    'dpi': 1,
    'dpcm': 1 / 2.54,
    'dppx': 1 / 96
  },
  'dpcm': {
    'dpi': 2.54,
    'dpcm': 1,
    'dppx': 2.54 / 96
  },
  'dppx': {
    'dpi': 96,
    'dpcm': 96 / 2.54,
    'dppx': 1
  }
};

function convertUnit(value, sourceUnit, targetUnit, precision) {
  const sourceUnitNormalized = sourceUnit.toLowerCase();
  const targetUnitNormalized = targetUnit.toLowerCase();

  if (!conversions[targetUnitNormalized]) {
    throw new Error("Cannot convert to " + targetUnit);
  }

  if (!conversions[targetUnitNormalized][sourceUnitNormalized]) {
    throw new Error("Cannot convert from " + sourceUnit + " to " + targetUnit);
  }

  const converted = conversions[targetUnitNormalized][sourceUnitNormalized] * value;

  if (precision !== false) {
    precision = Math.pow(10, parseInt(precision) || 5);
    return Math.round(converted * precision) / precision;
  }

  return converted;
}

var _default = convertUnit;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 28538:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _convertUnit = _interopRequireDefault(__nccwpck_require__(65313));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isValueType(type) {
  switch (type) {
    case 'LengthValue':
    case 'AngleValue':
    case 'TimeValue':
    case 'FrequencyValue':
    case 'ResolutionValue':
    case 'EmValue':
    case 'ExValue':
    case 'ChValue':
    case 'RemValue':
    case 'VhValue':
    case 'VwValue':
    case 'VminValue':
    case 'VmaxValue':
    case 'PercentageValue':
    case 'Number':
      return true;
  }

  return false;
}

function flip(operator) {
  return operator === '+' ? '-' : '+';
}

function isAddSubOperator(operator) {
  return operator === '+' || operator === '-';
}

function collectAddSubItems(preOperator, node, collected, precision) {
  if (!isAddSubOperator(preOperator)) {
    throw new Error(`invalid operator ${preOperator}`);
  }

  const type = node.type;

  if (isValueType(type)) {
    const itemIndex = collected.findIndex(x => x.node.type === type);

    if (itemIndex >= 0) {
      if (node.value === 0) {
        return;
      }

      const {
        left: reducedNode,
        right: current
      } = covertNodesUnits(collected[itemIndex].node, node, precision);

      if (collected[itemIndex].preOperator === '-') {
        collected[itemIndex].preOperator = '+';
        reducedNode.value *= -1;
      }

      if (preOperator === "+") {
        reducedNode.value += current.value;
      } else {
        reducedNode.value -= current.value;
      } // make sure reducedNode.value >= 0


      if (reducedNode.value >= 0) {
        collected[itemIndex] = {
          node: reducedNode,
          preOperator: '+'
        };
      } else {
        reducedNode.value *= -1;
        collected[itemIndex] = {
          node: reducedNode,
          preOperator: '-'
        };
      }
    } else {
      // make sure node.value >= 0
      if (node.value >= 0) {
        collected.push({
          node,
          preOperator
        });
      } else {
        node.value *= -1;
        collected.push({
          node,
          preOperator: flip(preOperator)
        });
      }
    }
  } else if (type === "MathExpression") {
    if (isAddSubOperator(node.operator)) {
      collectAddSubItems(preOperator, node.left, collected, precision);
      const collectRightOperator = preOperator === '-' ? flip(node.operator) : node.operator;
      collectAddSubItems(collectRightOperator, node.right, collected, precision);
    } else {
      // * or /
      const reducedNode = reduce(node, precision); // prevent infinite recursive call

      if (reducedNode.type !== "MathExpression" || isAddSubOperator(reducedNode.operator)) {
        collectAddSubItems(preOperator, reducedNode, collected, precision);
      } else {
        collected.push({
          node: reducedNode,
          preOperator
        });
      }
    }
  } else {
    collected.push({
      node,
      preOperator
    });
  }
}

function reduceAddSubExpression(node, precision) {
  const collected = [];
  collectAddSubItems('+', node, collected, precision);
  const withoutZeroItem = collected.filter(item => !(isValueType(item.node.type) && item.node.value === 0));
  const firstNonZeroItem = withoutZeroItem[0]; // could be undefined
  // prevent producing "calc(-var(--a))" or "calc()"
  // which is invalid css

  if (!firstNonZeroItem || firstNonZeroItem.preOperator === '-' && !isValueType(firstNonZeroItem.node.type)) {
    const firstZeroItem = collected.find(item => isValueType(item.node.type) && item.node.value === 0);
    withoutZeroItem.unshift(firstZeroItem);
  } // make sure the preOperator of the first item is +


  if (withoutZeroItem[0].preOperator === '-' && isValueType(withoutZeroItem[0].node.type)) {
    withoutZeroItem[0].node.value *= -1;
    withoutZeroItem[0].preOperator = '+';
  }

  let root = withoutZeroItem[0].node;

  for (let i = 1; i < withoutZeroItem.length; i++) {
    root = {
      type: 'MathExpression',
      operator: withoutZeroItem[i].preOperator,
      left: root,
      right: withoutZeroItem[i].node
    };
  }

  return root;
}

function reduceDivisionExpression(node) {
  if (!isValueType(node.right.type)) {
    return node;
  }

  if (node.right.type !== 'Number') {
    throw new Error(`Cannot divide by "${node.right.unit}", number expected`);
  }

  return applyNumberDivision(node.left, node.right.value);
} // apply (expr) / number


function applyNumberDivision(node, divisor) {
  if (divisor === 0) {
    throw new Error('Cannot divide by zero');
  }

  if (isValueType(node.type)) {
    node.value /= divisor;
    return node;
  }

  if (node.type === "MathExpression" && isAddSubOperator(node.operator)) {
    // turn (a + b) / num into a/num + b/num
    // is good for further reduction
    // checkout the test case
    // "should reduce division before reducing additions"
    return {
      type: "MathExpression",
      operator: node.operator,
      left: applyNumberDivision(node.left, divisor),
      right: applyNumberDivision(node.right, divisor)
    };
  } // it is impossible to reduce it into a single value
  // .e.g the node contains css variable
  // so we just preserve the division and let browser do it


  return {
    type: "MathExpression",
    operator: '/',
    left: node,
    right: {
      type: "Number",
      value: divisor
    }
  };
}

function reduceMultiplicationExpression(node) {
  // (expr) * number
  if (node.right.type === 'Number') {
    return applyNumberMultiplication(node.left, node.right.value);
  } // number * (expr)


  if (node.left.type === 'Number') {
    return applyNumberMultiplication(node.right, node.left.value);
  }

  return node;
} // apply (expr) / number


function applyNumberMultiplication(node, multiplier) {
  if (isValueType(node.type)) {
    node.value *= multiplier;
    return node;
  }

  if (node.type === "MathExpression" && isAddSubOperator(node.operator)) {
    // turn (a + b) * num into a*num + b*num
    // is good for further reduction
    // checkout the test case
    // "should reduce multiplication before reducing additions"
    return {
      type: "MathExpression",
      operator: node.operator,
      left: applyNumberMultiplication(node.left, multiplier),
      right: applyNumberMultiplication(node.right, multiplier)
    };
  } // it is impossible to reduce it into a single value
  // .e.g the node contains css variable
  // so we just preserve the division and let browser do it


  return {
    type: "MathExpression",
    operator: '*',
    left: node,
    right: {
      type: "Number",
      value: multiplier
    }
  };
}

function covertNodesUnits(left, right, precision) {
  switch (left.type) {
    case 'LengthValue':
    case 'AngleValue':
    case 'TimeValue':
    case 'FrequencyValue':
    case 'ResolutionValue':
      if (right.type === left.type && right.unit && left.unit) {
        const converted = (0, _convertUnit.default)(right.value, right.unit, left.unit, precision);
        right = {
          type: left.type,
          value: converted,
          unit: left.unit
        };
      }

      return {
        left,
        right
      };

    default:
      return {
        left,
        right
      };
  }
}

function reduce(node, precision) {
  if (node.type === "MathExpression") {
    if (isAddSubOperator(node.operator)) {
      // reduceAddSubExpression will call reduce recursively
      return reduceAddSubExpression(node, precision);
    }

    node.left = reduce(node.left, precision);
    node.right = reduce(node.right, precision);

    switch (node.operator) {
      case "/":
        return reduceDivisionExpression(node, precision);

      case "*":
        return reduceMultiplicationExpression(node, precision);
    }

    return node;
  }

  return node;
}

var _default = reduce;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 23297:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;
const order = {
  "*": 0,
  "/": 0,
  "+": 1,
  "-": 1
};

function round(value, prec) {
  if (prec !== false) {
    const precision = Math.pow(10, prec);
    return Math.round(value * precision) / precision;
  }

  return value;
}

function stringify(node, prec) {
  switch (node.type) {
    case "MathExpression":
      {
        const {
          left,
          right,
          operator: op
        } = node;
        let str = "";

        if (left.type === 'MathExpression' && order[op] < order[left.operator]) {
          str += `(${stringify(left, prec)})`;
        } else {
          str += stringify(left, prec);
        }

        str += order[op] ? ` ${node.operator} ` : node.operator;

        if (right.type === 'MathExpression' && order[op] < order[right.operator]) {
          str += `(${stringify(right, prec)})`;
        } else {
          str += stringify(right, prec);
        }

        return str;
      }

    case 'Number':
      return round(node.value, prec);

    case 'Function':
      return node.value;

    default:
      return round(node.value, prec) + node.unit;
  }
}

function _default(calc, node, originalValue, options, result, item) {
  let str = stringify(node, options.precision);
  const shouldPrintCalc = node.type === "MathExpression" || node.type === "Function";

  if (shouldPrintCalc) {
    // if calc expression couldn't be resolved to a single value, re-wrap it as
    // a calc()
    str = `${calc}(${str})`; // if the warnWhenCannotResolve option is on, inform the user that the calc
    // expression could not be resolved to a single value

    if (options.warnWhenCannotResolve) {
      result.warn("Could not reduce expression: " + originalValue, {
        plugin: 'postcss-calc',
        node: item
      });
    }
  }

  return str;
}

module.exports = exports.default;

/***/ }),

/***/ 23854:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssSelectorParser = _interopRequireDefault(__nccwpck_require__(32997));

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

var _parser = __nccwpck_require__(59561);

var _reducer = _interopRequireDefault(__nccwpck_require__(28538));

var _stringifier = _interopRequireDefault(__nccwpck_require__(23297));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/no-unresolved
const MATCH_CALC = /((?:-(moz|webkit)-)?calc)/i;

function transformValue(value, options, result, item) {
  return (0, _postcssValueParser.default)(value).walk(node => {
    // skip anything which isn't a calc() function
    if (node.type !== 'function' || !MATCH_CALC.test(node.value)) {
      return node;
    } // stringify calc expression and produce an AST


    const contents = _postcssValueParser.default.stringify(node.nodes);

    const ast = _parser.parser.parse(contents); // reduce AST to its simplest form, that is, either to a single value
    // or a simplified calc expression


    const reducedAst = (0, _reducer.default)(ast, options.precision); // stringify AST and write it back

    node.type = 'word';
    node.value = (0, _stringifier.default)(node.value, reducedAst, value, options, result, item);
    return false;
  }).toString();
}

function transformSelector(value, options, result, item) {
  return (0, _postcssSelectorParser.default)(selectors => {
    selectors.walk(node => {
      // attribute value
      // e.g. the "calc(3*3)" part of "div[data-size="calc(3*3)"]"
      if (node.type === 'attribute' && node.value) {
        node.setValue(transformValue(node.value, options, result, item));
      } // tag value
      // e.g. the "calc(3*3)" part of "div:nth-child(2n + calc(3*3))"


      if (node.type === 'tag') {
        node.value = transformValue(node.value, options, result, item);
      }

      return;
    });
  }).processSync(value);
}

var _default = (node, property, options, result) => {
  const value = property === "selector" ? transformSelector(node[property], options, result, node) : transformValue(node[property], options, result, node); // if the preserve option is enabled and the value has changed, write the
  // transformed value into a cloned node which is inserted before the current
  // node, preserving the original value. Otherwise, overwrite the original
  // value.

  if (options.preserve && node[property] !== value) {
    const clone = node.clone();
    clone[property] = value;
    node.parent.insertBefore(node, clone);
  } else {
    node[property] = value;
  }
};

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 59561:
/***/ ((__unused_webpack_module, exports) => {


/* parser generated by jison 0.6.1-215 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journes Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var parser = (function () {


// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';




        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. ["classic","merge"]
    //   test-compile action mode: ........ "parser:*,lexer:*"
    //   try..catch: ...................... true
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() { },
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "$accept": 0,
  "$end": 1,
  "ADD": 6,
  "ANGLE": 12,
  "CALC": 3,
  "CHS": 19,
  "DIV": 9,
  "EMS": 17,
  "EOF": 1,
  "EXS": 18,
  "FREQ": 14,
  "FUNCTION": 10,
  "LENGTH": 11,
  "LPAREN": 4,
  "MUL": 8,
  "NUMBER": 26,
  "PERCENTAGE": 25,
  "REMS": 20,
  "RES": 15,
  "RPAREN": 5,
  "SUB": 7,
  "TIME": 13,
  "UNKNOWN_DIMENSION": 16,
  "VHS": 21,
  "VMAXS": 24,
  "VMINS": 23,
  "VWS": 22,
  "dimension": 30,
  "error": 2,
  "expression": 27,
  "function": 29,
  "math_expression": 28,
  "number": 31
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "CALC",
  4: "LPAREN",
  5: "RPAREN",
  6: "ADD",
  7: "SUB",
  8: "MUL",
  9: "DIV",
  10: "FUNCTION",
  11: "LENGTH",
  12: "ANGLE",
  13: "TIME",
  14: "FREQ",
  15: "RES",
  16: "UNKNOWN_DIMENSION",
  17: "EMS",
  18: "EXS",
  19: "CHS",
  20: "REMS",
  21: "VHS",
  22: "VWS",
  23: "VMINS",
  24: "VMAXS",
  25: "PERCENTAGE",
  26: "NUMBER"
},
TERROR: 2,
    EOF: 1,

    // internals: defined here so the object *structure* doesn't get modified by parse() et al,
    // thus helping JIT compilers like Chrome V8.
    originalQuoteName: null,
    originalParseError: null,
    cleanupAfterParse: null,
    constructParseErrorInfo: null,
    yyMergeLocationInfo: null,

    __reentrant_call_depth: 0,      // INTERNAL USE ONLY
    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

    // APIs which will be set up depending on user action code analysis:
    //yyRecovering: 0,
    //yyErrOk: 0,
    //yyClearIn: 0,

    // Helper APIs
    // -----------

    // Helper function which can be overridden by user code later on: put suitable quotes around
    // literal IDs in a description string.
    quoteName: function parser_quoteName(id_str) {
        return '"' + id_str + '"';
    },

    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
    //
    // Return NULL when the symbol is unknown to the parser.
    getSymbolName: function parser_getSymbolName(symbol) {
        if (this.terminals_[symbol]) {
            return this.terminals_[symbol];
        }

        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
        //
        // An example of this may be where a rule's action code contains a call like this:
        //
        //      parser.getSymbolName(#$)
        //
        // to obtain a human-readable name of the current grammar rule.
        var s = this.symbols_;
        for (var key in s) {
            if (s[key] === symbol) {
                return key;
            }
        }
        return null;
    },

    // Return a more-or-less human-readable description of the given symbol, when available,
    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
    //
    // Return NULL when the symbol is unknown to the parser.
    describeSymbol: function parser_describeSymbol(symbol) {
        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
            return this.terminal_descriptions_[symbol];
        }
        else if (symbol === this.EOF) {
            return 'end of input';
        }
        var id = this.getSymbolName(symbol);
        if (id) {
            return this.quoteName(id);
        }
        return null;
    },

    // Produce a (more or less) human-readable list of expected tokens at the point of failure.
    //
    // The produced list may contain token or token set descriptions instead of the tokens
    // themselves to help turning this output into something that easier to read by humans
    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
    // expected terminals and nonterminals is produced.
    //
    // The returned list (array) will not contain any duplicate entries.
    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
        var TERROR = this.TERROR;
        var tokenset = [];
        var check = {};
        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
        // If so, use that one instead of the less palatable token set.
        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
            return [
                this.state_descriptions_[state]
            ];
        }
        for (var p in this.table[state]) {
            p = +p;
            if (p !== TERROR) {
                var d = do_not_describe ? p : this.describeSymbol(p);
                if (d && !check[d]) {
                    tokenset.push(d);
                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.
                }
            }
        }
        return tokenset;
    },
productions_: bp({
  pop: u([
  27,
  s,
  [28, 9],
  29,
  s,
  [30, 17],
  s,
  [31, 3]
]),
  rule: u([
  2,
  4,
  s,
  [3, 5],
  s,
  [1, 19],
  2,
  2,
  c,
  [3, 3]
])
}),
performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : expression $end */

    // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):
    this.$ = yyvstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)
    break;

case 1:
    /*! Production::    expression : math_expression EOF */

    // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):
    this.$ = yyvstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)
    
    
    return yyvstack[yysp - 1];
    break;

case 2:
    /*! Production::    math_expression : CALC LPAREN math_expression RPAREN */
case 7:
    /*! Production::    math_expression : LPAREN math_expression RPAREN */

    this.$ = yyvstack[yysp - 1];
    break;

case 3:
    /*! Production::    math_expression : math_expression ADD math_expression */
case 4:
    /*! Production::    math_expression : math_expression SUB math_expression */
case 5:
    /*! Production::    math_expression : math_expression MUL math_expression */
case 6:
    /*! Production::    math_expression : math_expression DIV math_expression */

    this.$ = { type: 'MathExpression', operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp] };
    break;

case 8:
    /*! Production::    math_expression : function */
case 9:
    /*! Production::    math_expression : dimension */
case 10:
    /*! Production::    math_expression : number */

    this.$ = yyvstack[yysp];
    break;

case 11:
    /*! Production::    function : FUNCTION */

    this.$ = { type: 'Function', value: yyvstack[yysp] };
    break;

case 12:
    /*! Production::    dimension : LENGTH */

    this.$ = { type: 'LengthValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 13:
    /*! Production::    dimension : ANGLE */

    this.$ = { type: 'AngleValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 14:
    /*! Production::    dimension : TIME */

    this.$ = { type: 'TimeValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 15:
    /*! Production::    dimension : FREQ */

    this.$ = { type: 'FrequencyValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 16:
    /*! Production::    dimension : RES */

    this.$ = { type: 'ResolutionValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 17:
    /*! Production::    dimension : UNKNOWN_DIMENSION */

    this.$ = { type: 'UnknownDimension', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 18:
    /*! Production::    dimension : EMS */

    this.$ = { type: 'EmValue', value: parseFloat(yyvstack[yysp]), unit: 'em' };
    break;

case 19:
    /*! Production::    dimension : EXS */

    this.$ = { type: 'ExValue', value: parseFloat(yyvstack[yysp]), unit: 'ex' };
    break;

case 20:
    /*! Production::    dimension : CHS */

    this.$ = { type: 'ChValue', value: parseFloat(yyvstack[yysp]), unit: 'ch' };
    break;

case 21:
    /*! Production::    dimension : REMS */

    this.$ = { type: 'RemValue', value: parseFloat(yyvstack[yysp]), unit: 'rem' };
    break;

case 22:
    /*! Production::    dimension : VHS */

    this.$ = { type: 'VhValue', value: parseFloat(yyvstack[yysp]), unit: 'vh' };
    break;

case 23:
    /*! Production::    dimension : VWS */

    this.$ = { type: 'VwValue', value: parseFloat(yyvstack[yysp]), unit: 'vw' };
    break;

case 24:
    /*! Production::    dimension : VMINS */

    this.$ = { type: 'VminValue', value: parseFloat(yyvstack[yysp]), unit: 'vmin' };
    break;

case 25:
    /*! Production::    dimension : VMAXS */

    this.$ = { type: 'VmaxValue', value: parseFloat(yyvstack[yysp]), unit: 'vmax' };
    break;

case 26:
    /*! Production::    dimension : PERCENTAGE */

    this.$ = { type: 'PercentageValue', value: parseFloat(yyvstack[yysp]), unit: '%' };
    break;

case 27:
    /*! Production::    dimension : ADD dimension */

    var prev = yyvstack[yysp]; this.$ = prev;
    break;

case 28:
    /*! Production::    dimension : SUB dimension */

    var prev = yyvstack[yysp]; prev.value *= -1; this.$ = prev;
    break;

case 29:
    /*! Production::    number : NUMBER */
case 30:
    /*! Production::    number : ADD NUMBER */

    this.$ = { type: 'Number', value: parseFloat(yyvstack[yysp]) };
    break;

case 31:
    /*! Production::    number : SUB NUMBER */

    this.$ = { type: 'Number', value: parseFloat(yyvstack[yysp]) * -1 };
    break;

}
},
table: bt({
  len: u([
  26,
  1,
  5,
  1,
  25,
  s,
  [0, 19],
  19,
  19,
  0,
  0,
  s,
  [25, 5],
  5,
  0,
  0,
  18,
  18,
  0,
  0,
  6,
  6,
  0,
  0,
  c,
  [11, 3]
]),
  symbol: u([
  3,
  4,
  6,
  7,
  s,
  [10, 22, 1],
  1,
  1,
  s,
  [6, 4, 1],
  4,
  c,
  [33, 21],
  c,
  [32, 4],
  6,
  7,
  c,
  [22, 16],
  30,
  c,
  [19, 19],
  c,
  [63, 25],
  c,
  [25, 100],
  s,
  [5, 5, 1],
  c,
  [149, 17],
  c,
  [167, 18],
  30,
  1,
  c,
  [42, 5],
  c,
  [6, 6],
  c,
  [5, 5]
]),
  type: u([
  s,
  [2, 21],
  s,
  [0, 5],
  1,
  s,
  [2, 27],
  s,
  [0, 4],
  c,
  [22, 19],
  c,
  [19, 37],
  c,
  [63, 25],
  c,
  [25, 103],
  c,
  [148, 19],
  c,
  [18, 18]
]),
  state: u([
  1,
  2,
  5,
  6,
  7,
  33,
  c,
  [4, 3],
  34,
  38,
  40,
  c,
  [6, 3],
  41,
  c,
  [4, 3],
  42,
  c,
  [4, 3],
  43,
  c,
  [4, 3],
  44,
  c,
  [22, 5]
]),
  mode: u([
  s,
  [1, 228],
  s,
  [2, 4],
  c,
  [6, 8],
  s,
  [1, 5]
]),
  goto: u([
  3,
  4,
  24,
  25,
  s,
  [8, 16, 1],
  s,
  [26, 7, 1],
  c,
  [27, 21],
  36,
  37,
  c,
  [18, 15],
  35,
  c,
  [18, 17],
  39,
  c,
  [57, 21],
  c,
  [21, 84],
  45,
  c,
  [168, 4],
  c,
  [128, 17],
  c,
  [17, 17],
  s,
  [3, 4],
  30,
  31,
  s,
  [4, 4],
  30,
  31,
  46,
  c,
  [51, 4]
])
}),
defaultActions: bda({
  idx: u([
  s,
  [5, 19, 1],
  26,
  27,
  34,
  35,
  38,
  39,
  42,
  43,
  45,
  46
]),
  goto: u([
  s,
  [8, 19, 1],
  29,
  1,
  27,
  30,
  28,
  31,
  5,
  6,
  7,
  2
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack

    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks


    


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 47 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };








    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;

        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };






































































































































    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,

            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,

            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    try {
        this.__reentrant_call_depth++;

        lexer.setInput(input, sharedState_yy);

        // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
        // this initial `setInput()` call: hence we can now check and decide
        // whether we'll go with the standard, slower, lex() API or the
        // `fast_lex()` one:
        if (typeof lexer.canIUse === 'function') {
            var lexerInfo = lexer.canIUse();
            if (lexerInfo.fastLex && typeof fastLex === 'function') {
                lex = fastLex;
            }
        } 



        vstack[sp] = null;
        sstack[sp] = 0;
        stack[sp] = 0;
        ++sp;





        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex();
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];











                // handle parse error
                if (!action) {
                    var errStr;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }
                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }
                    // we cannot recover from the error!
                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }


            }










            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;

            // shift:
            case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;

                sstack[sp] = newState; // push state

                ++sp;
                symbol = 0;




                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:




                continue;

            // reduce:
            case 2:



                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                yyrulelen = this_production[1];










                r = this.performAction.call(yyval, newState, sp - 1, vstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;

                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;









                continue;

            // accept:
            case 3:
                if (sp !== -2) {
                    retval = true;
                    // Return the `$accept` rule's `$$` result, if available.
                    //
                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                    // default, action):
                    //
                    //     $accept: <startSymbol> $end
                    //                  %{ $$ = $1; @$ = @1; %}
                    //
                    // which, combined with the parse kernel's `$accept` state behaviour coded below,
                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                    //
                    // In code:
                    //
                    //                  %{
                    //                      @$ = @1;            // if location tracking support is included
                    //                      if (typeof $1 !== 'undefined')
                    //                          return $1;
                    //                      else
                    //                          return true;           // the default parse result if the rule actions don't produce anything
                    //                  %}
                    sp--;
                    if (typeof vstack[sp] !== 'undefined') {
                        retval = vstack[sp];
                    }
                }
                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
            throw ex;
        }
        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
            throw ex;
        }

        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
        retval = false;
        r = this.parseError(p.errStr, p, this.JisonParserError);
        if (typeof r !== 'undefined') {
            retval = r;
        }
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }   // /finally

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;
/* lexer generated by jison-lex 0.6.1-215 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */


var lexer = function() {
  /**
   * See also:
   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
   * with userland code which might access the derived class in a 'classic' way.
   *
   * @public
   * @constructor
   * @nocollapse
   */
  function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
      enumerable: false,
      writable: false,
      value: 'JisonLexerError'
    });

    if (msg == null)
      msg = '???';

    Object.defineProperty(this, 'message', {
      enumerable: false,
      writable: true,
      value: msg
    });

    this.hash = hash;
    var stacktrace;

    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }

    if (!stacktrace) {
      if (Error.hasOwnProperty('captureStackTrace')) {
        // V8
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }

    if (stacktrace) {
      Object.defineProperty(this, 'stack', {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }

  if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
  } else {
    JisonLexerError.prototype = Object.create(Error.prototype);
  }

  JisonLexerError.prototype.constructor = JisonLexerError;
  JisonLexerError.prototype.name = 'JisonLexerError';

  var lexer = {
    
// Code Generator Information Report
// ---------------------------------
//
// Options:
//
//   backtracking: .................... false
//   location.ranges: ................. false
//   location line+column tracking: ... true
//
//
// Forwarded Parser Analysis flags:
//
//   uses yyleng: ..................... false
//   uses yylineno: ................... false
//   uses yytext: ..................... false
//   uses yylloc: ..................... false
//   uses lexer values: ............... true / true
//   location tracking: ............... false
//   location assignment: ............. false
//
//
// Lexer Analysis flags:
//
//   uses yyleng: ..................... ???
//   uses yylineno: ................... ???
//   uses yytext: ..................... ???
//   uses yylloc: ..................... ???
//   uses ParseError API: ............. ???
//   uses yyerror: .................... ???
//   uses location tracking & editing:  ???
//   uses more() API: ................. ???
//   uses unput() API: ................ ???
//   uses reject() API: ............... ???
//   uses less() API: ................. ???
//   uses display APIs pastInput(), upcomingInput(), showPosition():
//        ............................. ???
//   uses describeYYLLOC() API: ....... ???
//
// --------- END OF REPORT -----------

EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

    // options: {},                             /// <-- injected by the code generator

    // yy: ...,                                 /// <-- injected by setInput()

    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
    done: false,                                /// INTERNAL USE ONLY  
    _backtrack: false,                          /// INTERNAL USE ONLY  
    _input: '',                                 /// INTERNAL USE ONLY  
    _more: false,                               /// INTERNAL USE ONLY  
    _signaled_error_token: false,               /// INTERNAL USE ONLY  
    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

    /**
     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
      msg = '' + msg;

      // heuristic to determine if the error message already contains a (partial) source code dump
      // as produced by either `showPosition()` or `prettyPrintRange()`:
      if (show_input_position == undefined) {
        show_input_position = !(msg.indexOf('\n') > 0 && msg.indexOf('^') > 0);
      }

      if (this.yylloc && show_input_position) {
        if (typeof this.prettyPrintRange === 'function') {
          var pretty_src = this.prettyPrintRange(this.yylloc);

          if (!/\n\s*$/.test(msg)) {
            msg += '\n';
          }

          msg += '\n  Erroneous area:\n' + this.prettyPrintRange(this.yylloc);
        } else if (typeof this.showPosition === 'function') {
          var pos_str = this.showPosition();

          if (pos_str) {
            if (msg.length && msg[msg.length - 1] !== '\n' && pos_str[0] !== '\n') {
              msg += '\n' + pos_str;
            } else {
              msg += pos_str;
            }
          }
        }
      }

      /** @constructor */
      var pei = {
        errStr: msg,
        recoverable: !!recoverable,
        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
        token: null,
        line: this.yylineno,
        loc: this.yylloc,
        yy: this.yy,
        lexer: this,

        /**
         * and make sure the error info doesn't stay due to potential
         * ref cycle via userland code manipulations.
         * These would otherwise all be memory leak opportunities!
         * 
         * Note that only array and object references are nuked as those
         * constitute the set of elements which can produce a cyclic ref.
         * The rest of the members is kept intact as they are harmless.
         * 
         * @public
         * @this {LexErrorInfo}
         */
        destroy: function destructLexErrorInfo() {
          // remove cyclic references added to error info:
          // info.yy = null;
          // info.lexer = null;
          // ...
          var rec = !!this.recoverable;

          for (var key in this) {
            if (this.hasOwnProperty(key) && typeof key === 'object') {
              this[key] = undefined;
            }
          }

          this.recoverable = rec;
        }
      };

      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
      this.__error_infos.push(pei);

      return pei;
    },

    /**
     * handler which is invoked when a lexer error occurs.
     * 
     * @public
     * @this {RegExpLexer}
     */
    parseError: function lexer_parseError(str, hash, ExceptionClass) {
      if (!ExceptionClass) {
        ExceptionClass = this.JisonLexerError;
      }

      if (this.yy) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        }
      }

      throw new ExceptionClass(str, hash);
    },

    /**
     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
     * 
     * @public
     * @this {RegExpLexer}
     */
    yyerror: function yyError(str /*, ...args */) {
      var lineno_msg = '';

      if (this.yylloc) {
        lineno_msg = ' on line ' + (this.yylineno + 1);
      }

      var p = this.constructLexErrorInfo(
        'Lexical error' + lineno_msg + ': ' + str,
        this.options.lexerErrorsAreRecoverable
      );

      // Add any extra args to the hash under the name `extra_error_attributes`:
      var args = Array.prototype.slice.call(arguments, 1);

      if (args.length) {
        p.extra_error_attributes = args;
      }

      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
    },

    /**
     * final cleanup function for when we have completed lexing the input;
     * make it an API so that external code can use this one once userland
     * code has decided it's time to destroy any lingering lexer error
     * hash object instances and the like: this function helps to clean
     * up these constructs, which *may* carry cyclic references which would
     * otherwise prevent the instances from being properly and timely
     * garbage-collected, i.e. this function helps prevent memory leaks!
     * 
     * @public
     * @this {RegExpLexer}
     */
    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
      // prevent lingering circular references from causing memory leaks:
      this.setInput('', {});

      // nuke the error hash info instances created during this run.
      // Userland code must COPY any data/references
      // in the error hash instance(s) it is more permanently interested in.
      if (!do_not_nuke_errorinfos) {
        for (var i = this.__error_infos.length - 1; i >= 0; i--) {
          var el = this.__error_infos[i];

          if (el && typeof el.destroy === 'function') {
            el.destroy();
          }
        }

        this.__error_infos.length = 0;
      }

      return this;
    },

    /**
     * clear the lexer token context; intended for internal use only
     * 
     * @public
     * @this {RegExpLexer}
     */
    clear: function lexer_clear() {
      this.yytext = '';
      this.yyleng = 0;
      this.match = '';

      // - DO NOT reset `this.matched`
      this.matches = false;

      this._more = false;
      this._backtrack = false;
      var col = (this.yylloc ? this.yylloc.last_column : 0);

      this.yylloc = {
        first_line: this.yylineno + 1,
        first_column: col,
        last_line: this.yylineno + 1,
        last_column: col,
        range: [this.offset, this.offset]
      };
    },

    /**
     * resets the lexer, sets new input
     * 
     * @public
     * @this {RegExpLexer}
     */
    setInput: function lexer_setInput(input, yy) {
      this.yy = yy || this.yy || {};

      // also check if we've fully initialized the lexer instance,
      // including expansion work to be done to go from a loaded
      // lexer to a usable lexer:
      if (!this.__decompressed) {
        // step 1: decompress the regex list:
        var rules = this.rules;

        for (var i = 0, len = rules.length; i < len; i++) {
          var rule_re = rules[i];

          // compression: is the RE an xref to another RE slot in the rules[] table?
          if (typeof rule_re === 'number') {
            rules[i] = rules[rule_re];
          }
        }

        // step 2: unfold the conditions[] set to make these ready for use:
        var conditions = this.conditions;

        for (var k in conditions) {
          var spec = conditions[k];
          var rule_ids = spec.rules;
          var len = rule_ids.length;
          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
          var rule_new_ids = new Array(len + 1);

          for (var i = 0; i < len; i++) {
            var idx = rule_ids[i];
            var rule_re = rules[idx];
            rule_regexes[i + 1] = rule_re;
            rule_new_ids[i + 1] = idx;
          }

          spec.rules = rule_new_ids;
          spec.__rule_regexes = rule_regexes;
          spec.__rule_count = len;
        }

        this.__decompressed = true;
      }

      this._input = input || '';
      this.clear();
      this._signaled_error_token = false;
      this.done = false;
      this.yylineno = 0;
      this.matched = '';
      this.conditionStack = ['INITIAL'];
      this.__currentRuleSet__ = null;

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    /**
     * edit the remaining input via user-specified callback.
     * This can be used to forward-adjust the input-to-parse, 
     * e.g. inserting macro expansions and alike in the
     * input which has yet to be lexed.
     * The behaviour of this API contrasts the `unput()` et al
     * APIs as those act on the *consumed* input, while this
     * one allows one to manipulate the future, without impacting
     * the current `yyloc` cursor location or any history. 
     * 
     * Use this API to help implement C-preprocessor-like
     * `#include` statements, etc.
     * 
     * The provided callback must be synchronous and is
     * expected to return the edited input (string).
     *
     * The `cpsArg` argument value is passed to the callback
     * as-is.
     *
     * `callback` interface: 
     * `function callback(input, cpsArg)`
     * 
     * - `input` will carry the remaining-input-to-lex string
     *   from the lexer.
     * - `cpsArg` is `cpsArg` passed into this API.
     * 
     * The `this` reference for the callback will be set to
     * reference this lexer instance so that userland code
     * in the callback can easily and quickly access any lexer
     * API. 
     *
     * When the callback returns a non-string-type falsey value,
     * we assume the callback did not edit the input and we
     * will using the input as-is.
     *
     * When the callback returns a non-string-type value, it
     * is converted to a string for lexing via the `"" + retval`
     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
     * -- that way any returned object's `toValue()` and `toString()`
     * methods will be invoked in a proper/desirable order.)
     * 
     * @public
     * @this {RegExpLexer}
     */
    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
      var rv = callback.call(this, this._input, cpsArg);

      if (typeof rv !== 'string') {
        if (rv) {
          this._input = '' + rv;
        } 
        // else: keep `this._input` as is.  
      } else {
        this._input = rv;
      }

      return this;
    },

    /**
     * consumes and returns one char from the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    input: function lexer_input() {
      if (!this._input) {
        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
        return null;
      }

      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;

      // Count the linenumber up when we hit the LF (or a stand-alone CR).
      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
      // and we advance immediately past the LF as well, returning both together as if
      // it was all a single 'character' only.
      var slice_len = 1;

      var lines = false;

      if (ch === '\n') {
        lines = true;
      } else if (ch === '\r') {
        lines = true;
        var ch2 = this._input[1];

        if (ch2 === '\n') {
          slice_len++;
          ch += ch2;
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          this.yylloc.range[1]++;
        }
      }

      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }

      this.yylloc.range[1]++;
      this._input = this._input.slice(slice_len);
      return ch;
    },

    /**
     * unshifts one char (or an entire string) into the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    unput: function lexer_unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.yyleng = this.yytext.length;
      this.offset -= len;
      this.match = this.match.substr(0, this.match.length - len);
      this.matched = this.matched.substr(0, this.matched.length - len);

      if (lines.length > 1) {
        this.yylineno -= lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;

        // Get last entirely matched line into the `pre_lines[]` array's
        // last index slot; we don't mind when other previously 
        // matched lines end up in the array too. 
        var pre = this.match;

        var pre_lines = pre.split(/(?:\r\n?|\n)/g);

        if (pre_lines.length === 1) {
          pre = this.matched;
          pre_lines = pre.split(/(?:\r\n?|\n)/g);
        }

        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
      } else {
        this.yylloc.last_column -= len;
      }

      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
      this.done = false;
      return this;
    },

    /**
     * cache matched text and append it on next action
     * 
     * @public
     * @this {RegExpLexer}
     */
    more: function lexer_more() {
      this._more = true;
      return this;
    },

    /**
     * signal the lexer that this rule fails to match the input, so the
     * next matching rule (regex) should be tested instead.
     * 
     * @public
     * @this {RegExpLexer}
     */
    reject: function lexer_reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        // when the `parseError()` call returns, we MUST ensure that the error is registered.
        // We accomplish this by signaling an 'error' token to be produced for the current
        // `.lex()` run.
        var lineno_msg = '';

        if (this.yylloc) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).',
          false
        );

        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      }

      return this;
    },

    /**
     * retain first n characters of the match
     * 
     * @public
     * @this {RegExpLexer}
     */
    less: function lexer_less(n) {
      return this.unput(this.match.slice(n));
    },

    /**
     * return (part of the) already matched input, i.e. for error
     * messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of
     * input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     * 
     * @public
     * @this {RegExpLexer}
     */
    pastInput: function lexer_pastInput(maxSize, maxLines) {
      var past = this.matched.substring(0, this.matched.length - this.match.length);

      if (maxSize < 0)
        maxSize = past.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = past.length;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substr` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      past = past.substr(-maxSize * 2 - 2);

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = past.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(-maxLines);
      past = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis prefix...
      if (past.length > maxSize) {
        past = '...' + past.substr(-maxSize);
      }

      return past;
    },

    /**
     * return (part of the) upcoming input, i.e. for error messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     *
     * > ### NOTE ###
     * >
     * > *"upcoming input"* is defined as the whole of the both
     * > the *currently lexed* input, together with any remaining input
     * > following that. *"currently lexed"* input is the input 
     * > already recognized by the lexer but not yet returned with
     * > the lexer token. This happens when you are invoking this API
     * > from inside any lexer rule action code block. 
     * >
     * 
     * @public
     * @this {RegExpLexer}
     */
    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
      var next = this.match;

      if (maxSize < 0)
        maxSize = next.length + this._input.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = maxSize;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substring` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      if (next.length < maxSize * 2 + 2) {
        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 
      }

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = next.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(0, maxLines);
      next = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis postfix...
      if (next.length > maxSize) {
        next = next.substring(0, maxSize) + '...';
      }

      return next;
    },

    /**
     * return a string which displays the character position where the
     * lexing error occurred, i.e. for error messages
     * 
     * @public
     * @this {RegExpLexer}
     */
    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
      var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
      var c = new Array(pre.length + 1).join('-');
      return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    /**
     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
     * it MAY be NULL) and you MUST have a valid location info object anyway:
     * then we take the given context of the `preceding` and `following` locations, IFF those are available,
     * and reconstruct the `actual` location info from those.
     * If this fails, the heuristic is to take the `current` location, IFF available.
     * If this fails as well, we assume the sought location is at/around the current lexer position
     * and then produce that one as a response. DO NOTE that these heuristic/derived location info
     * values MAY be inaccurate!
     *
     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
     * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
     * 
     * @public
     * @this {RegExpLexer}
     */
    deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
      var loc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      if (actual) {
        loc.first_line = actual.first_line | 0;
        loc.last_line = actual.last_line | 0;
        loc.first_column = actual.first_column | 0;
        loc.last_column = actual.last_column | 0;

        if (actual.range) {
          loc.range[0] = actual.range[0] | 0;
          loc.range[1] = actual.range[1] | 0;
        }
      }

      if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
        // plan B: heuristic using preceding and following:
        if (loc.first_line <= 0 && preceding) {
          loc.first_line = preceding.last_line | 0;
          loc.first_column = preceding.last_column | 0;

          if (preceding.range) {
            loc.range[0] = actual.range[1] | 0;
          }
        }

        if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
          loc.last_line = following.first_line | 0;
          loc.last_column = following.first_column | 0;

          if (following.range) {
            loc.range[1] = actual.range[0] | 0;
          }
        }

        // plan C?: see if the 'current' location is useful/sane too:
        if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
          loc.first_line = current.first_line | 0;
          loc.first_column = current.first_column | 0;

          if (current.range) {
            loc.range[0] = current.range[0] | 0;
          }
        }

        if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
          loc.last_line = current.last_line | 0;
          loc.last_column = current.last_column | 0;

          if (current.range) {
            loc.range[1] = current.range[1] | 0;
          }
        }
      }

      // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter
      // or plan D heuristics to produce a 'sensible' last_line value:
      if (loc.last_line <= 0) {
        if (loc.first_line <= 0) {
          loc.first_line = this.yylloc.first_line;
          loc.last_line = this.yylloc.last_line;
          loc.first_column = this.yylloc.first_column;
          loc.last_column = this.yylloc.last_column;
          loc.range[0] = this.yylloc.range[0];
          loc.range[1] = this.yylloc.range[1];
        } else {
          loc.last_line = this.yylloc.last_line;
          loc.last_column = this.yylloc.last_column;
          loc.range[1] = this.yylloc.range[1];
        }
      }

      if (loc.first_line <= 0) {
        loc.first_line = loc.last_line;
        loc.first_column = 0;  // loc.last_column; 
        loc.range[1] = loc.range[0];
      }

      if (loc.first_column < 0) {
        loc.first_column = 0;
      }

      if (loc.last_column < 0) {
        loc.last_column = (loc.first_column > 0 ? loc.first_column : 80);
      }

      return loc;
    },

    /**
     * return a string which displays the lines & columns of input which are referenced 
     * by the given location info range, plus a few lines of context.
     * 
     * This function pretty-prints the indicated section of the input, with line numbers 
     * and everything!
     * 
     * This function is very useful to provide highly readable error reports, while
     * the location range may be specified in various flexible ways:
     * 
     * - `loc` is the location info object which references the area which should be
     *   displayed and 'marked up': these lines & columns of text are marked up by `^`
     *   characters below each character in the entire input range.
     * 
     * - `context_loc` is the *optional* location info object which instructs this
     *   pretty-printer how much *leading* context should be displayed alongside
     *   the area referenced by `loc`. This can help provide context for the displayed
     *   error, etc.
     * 
     *   When this location info is not provided, a default context of 3 lines is
     *   used.
     * 
     * - `context_loc2` is another *optional* location info object, which serves
     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
     *   context lines to display in the pretty-print output.
     * 
     *   When this location info is not provided, a default context of 1 line only is
     *   used.
     * 
     * Special Notes:
     * 
     * - when the `loc`-indicated range is very large (about 5 lines or more), then
     *   only the first and last few lines of this block are printed while a
     *   `...continued...` message will be printed between them.
     * 
     *   This serves the purpose of not printing a huge amount of text when the `loc`
     *   range happens to be huge: this way a manageable & readable output results
     *   for arbitrary large ranges.
     * 
     * - this function can display lines of input which whave not yet been lexed.
     *   `prettyPrintRange()` can access the entire input!
     * 
     * @public
     * @this {RegExpLexer}
     */
    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
      loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
      const CONTEXT = 3;
      const CONTEXT_TAIL = 1;
      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
      var input = this.matched + this._input;
      var lines = input.split('\n');
      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));
      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));
      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
      var ws_prefix = new Array(lineno_display_width).join(' ');
      var nonempty_line_indexes = [];

      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
        var lno = index + l0;
        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
        var rv = lno_pfx + ': ' + line;
        var errpfx = new Array(lineno_display_width + 1).join('^');
        var offset = 2 + 1;
        var len = 0;

        if (lno === loc.first_line) {
          offset += loc.first_column;

          len = Math.max(
            2,
            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1
          );
        } else if (lno === loc.last_line) {
          len = Math.max(2, loc.last_column + 1);
        } else if (lno > loc.first_line && lno < loc.last_line) {
          len = Math.max(2, line.length + 1);
        }

        if (len) {
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        }

        rv = rv.replace(/\t/g, ' ');
        return rv;
      });

      // now make sure we don't print an overly large amount of error area: limit it 
      // to the top and bottom line count:
      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
        intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
      }

      return rv.join('\n');
    },

    /**
     * helper function, used to produce a human readable description as a string, given
     * the input `yylloc` location object.
     * 
     * Set `display_range_too` to TRUE to include the string character index position(s)
     * in the description if the `yylloc.range` is available.
     * 
     * @public
     * @this {RegExpLexer}
     */
    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
      var l1 = yylloc.first_line;
      var l2 = yylloc.last_line;
      var c1 = yylloc.first_column;
      var c2 = yylloc.last_column;
      var dl = l2 - l1;
      var dc = c2 - c1;
      var rv;

      if (dl === 0) {
        rv = 'line ' + l1 + ', ';

        if (dc <= 1) {
          rv += 'column ' + c1;
        } else {
          rv += 'columns ' + c1 + ' .. ' + c2;
        }
      } else {
        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
      }

      if (yylloc.range && display_range_too) {
        var r1 = yylloc.range[0];
        var r2 = yylloc.range[1] - 1;

        if (r2 <= r1) {
          rv += ' {String Offset: ' + r1 + '}';
        } else {
          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
        }
      }

      return rv;
    },

    /**
     * test the lexed token: return FALSE when not a match, otherwise return token.
     * 
     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
     * contains the actually matched text string.
     * 
     * Also move the input cursor forward and update the match collectors:
     * 
     * - `yytext`
     * - `yyleng`
     * - `match`
     * - `matches`
     * - `yylloc`
     * - `offset`
     * 
     * @public
     * @this {RegExpLexer}
     */
    test_match: function lexer_test_match(match, indexed_rule) {
      var token, lines, backup, match_str, match_str_len;

      if (this.options.backtrack_lexer) {
        // save context
        backup = {
          yylineno: this.yylineno,

          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.yylloc.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column,
            range: this.yylloc.range.slice(0)
          },

          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,

          //_signaled_error_token: this._signaled_error_token,
          yy: this.yy,

          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
      }

      match_str = match[0];
      match_str_len = match_str.length;

      // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
      lines = match_str.split(/(?:\r\n?|\n)/g);

      if (lines.length > 1) {
        this.yylineno += lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = lines[lines.length - 1].length;
      } else {
        this.yylloc.last_column += match_str_len;
      }

      // }
      this.yytext += match_str;

      this.match += match_str;
      this.matched += match_str;
      this.matches = match;
      this.yyleng = this.yytext.length;
      this.yylloc.range[1] += match_str_len;

      // previous lex rules MAY have invoked the `more()` API rather than producing a token:
      // those rules will already have moved this `offset` forward matching their match lengths,
      // hence we must only add our own match length now:
      this.offset += match_str_len;

      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match_str_len);

      // calling this method:
      //
      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
      token = this.performAction.call(
        this,
        this.yy,
        indexed_rule,
        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
      );

      // otherwise, when the action codes are all simple return token statements:
      //token = this.simpleCaseActionClusters[indexed_rule];

      if (this.done && this._input) {
        this.done = false;
      }

      if (token) {
        return token;
      } else if (this._backtrack) {
        // recover context
        for (var k in backup) {
          this[k] = backup[k];
        }

        this.__currentRuleSet__ = null;
        return false;  // rule action called reject() implying the next rule should be tested instead. 
      } else if (this._signaled_error_token) {
        // produce one 'error' token as `.parseError()` in `reject()`
        // did not guarantee a failure signal by throwing an exception!
        token = this._signaled_error_token;

        this._signaled_error_token = false;
        return token;
      }

      return false;
    },

    /**
     * return next match in input
     * 
     * @public
     * @this {RegExpLexer}
     */
    next: function lexer_next() {
      if (this.done) {
        this.clear();
        return this.EOF;
      }

      if (!this._input) {
        this.done = true;
      }

      var token, match, tempMatch, index;

      if (!this._more) {
        this.clear();
      }

      var spec = this.__currentRuleSet__;

      if (!spec) {
        // Update the ruleset cache as we apparently encountered a state change or just started lexing.
        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
        // speed up those activities a tiny bit.
        spec = this.__currentRuleSet__ = this._currentRules();

        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
        if (!spec || !spec.rules) {
          var lineno_msg = '';

          if (this.options.trackPosition) {
            lineno_msg = ' on line ' + (this.yylineno + 1);
          }

          var p = this.constructLexErrorInfo(
            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!',
            false
          );

          // produce one 'error' token until this situation has been resolved, most probably by parse termination!
          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
      }

      var rule_ids = spec.rules;
      var regexes = spec.__rule_regexes;
      var len = spec.__rule_count;

      // Note: the arrays are 1-based, while `len` itself is a valid index,
      // hence the non-standard less-or-equal check in the next loop condition!
      for (var i = 1; i <= len; i++) {
        tempMatch = this._input.match(regexes[i]);

        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;

          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rule_ids[i]);

            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = undefined;
              continue;  // rule action called reject() implying a rule MISmatch. 
            } else {
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }

      if (match) {
        token = this.test_match(match, rule_ids[index]);

        if (token !== false) {
          return token;
        }

        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
        return false;
      }

      if (!this._input) {
        this.done = true;
        this.clear();
        return this.EOF;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': Unrecognized text.',
          this.options.lexerErrorsAreRecoverable
        );

        var pendingInput = this._input;
        var activeCondition = this.topState();
        var conditionStackDepth = this.conditionStack.length;
        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

        if (token === this.ERROR) {
          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
          // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`
          // has not consumed/modified any pending input or changed state in the error handler:
          if (!this.matches && // and make sure the input has been modified/consumed ...
          pendingInput === this._input && // ...or the lexer state has been modified significantly enough
          // to merit a non-consuming error handling action right now.
          activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
            this.input();
          }
        }

        return token;
      }
    },

    /**
     * return next match that has a token
     * 
     * @public
     * @this {RegExpLexer}
     */
    lex: function lexer_lex() {
      var r;

      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
      if (typeof this.pre_lex === 'function') {
        r = this.pre_lex.call(this, 0);
      }

      if (typeof this.options.pre_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.pre_lex.call(this, r) || r;
      }

      if (this.yy && typeof this.yy.pre_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.yy.pre_lex.call(this, r) || r;
      }

      while (!r) {
        r = this.next();
      }

      if (this.yy && typeof this.yy.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.yy.post_lex.call(this, r) || r;
      }

      if (typeof this.options.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.post_lex.call(this, r) || r;
      }

      if (typeof this.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.post_lex.call(this, r) || r;
      }

      return r;
    },

    /**
     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the 
     * `pre_lex()` nor any of the `post_lex()` callbacks.
     * 
     * @public
     * @this {RegExpLexer}
     */
    fastLex: function lexer_fastLex() {
      var r;

      while (!r) {
        r = this.next();
      }

      return r;
    },

    /**
     * return info about the lexer state that can help a parser or other lexer API user to use the
     * most efficient means available. This API is provided to aid run-time performance for larger
     * systems which employ this lexer.
     * 
     * @public
     * @this {RegExpLexer}
     */
    canIUse: function lexer_canIUse() {
      var rv = {
        fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'
      };

      return rv;
    },

    /**
     * backwards compatible alias for `pushState()`;
     * the latter is symmetrical with `popState()` and we advise to use
     * those APIs in any modern lexer code, rather than `begin()`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    begin: function lexer_begin(condition) {
      return this.pushState(condition);
    },

    /**
     * activates a new lexer condition state (pushes the new lexer
     * condition state onto the condition stack)
     * 
     * @public
     * @this {RegExpLexer}
     */
    pushState: function lexer_pushState(condition) {
      this.conditionStack.push(condition);
      this.__currentRuleSet__ = null;
      return this;
    },

    /**
     * pop the previously active lexer condition state off the condition
     * stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    popState: function lexer_popState() {
      var n = this.conditionStack.length - 1;

      if (n > 0) {
        this.__currentRuleSet__ = null;
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },

    /**
     * return the currently active lexer condition state; when an index
     * argument is provided it produces the N-th previous condition state,
     * if available
     * 
     * @public
     * @this {RegExpLexer}
     */
    topState: function lexer_topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);

      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return 'INITIAL';
      }
    },

    /**
     * (internal) determine the lexer rule set which is active for the
     * currently active lexer condition state
     * 
     * @public
     * @this {RegExpLexer}
     */
    _currentRules: function lexer__currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
      } else {
        return this.conditions['INITIAL'];
      }
    },

    /**
     * return the number of states currently on the stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    stateStackSize: function lexer_stateStackSize() {
      return this.conditionStack.length;
    },

    options: {
      trackPosition: true,
      caseInsensitive: true
    },

    JisonLexerError: JisonLexerError,

    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
      var yy_ = this;
      var YYSTATE = YY_START;

      switch (yyrulenumber) {
      case 0:
        /*! Conditions:: INITIAL */
        /*! Rule::       \s+ */
        /* skip whitespace */
        break;

      default:
        return this.simpleCaseActionClusters[yyrulenumber];
      }
    },

    simpleCaseActionClusters: {
      /*! Conditions:: INITIAL */
      /*! Rule::       (-(webkit|moz)-)?calc\b */
      1: 3,

      /*! Conditions:: INITIAL */
      /*! Rule::       [a-z][a-z0-9-]*\s*\((?:(?:"(?:\\.|[^\"\\])*"|'(?:\\.|[^\'\\])*')|\([^)]*\)|[^\(\)]*)*\) */
      2: 10,

      /*! Conditions:: INITIAL */
      /*! Rule::       \* */
      3: 8,

      /*! Conditions:: INITIAL */
      /*! Rule::       \/ */
      4: 9,

      /*! Conditions:: INITIAL */
      /*! Rule::       \+ */
      5: 6,

      /*! Conditions:: INITIAL */
      /*! Rule::       - */
      6: 7,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)em\b */
      7: 17,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)ex\b */
      8: 18,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)ch\b */
      9: 19,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)rem\b */
      10: 20,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)vw\b */
      11: 22,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)vh\b */
      12: 21,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)vmin\b */
      13: 23,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)vmax\b */
      14: 24,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)cm\b */
      15: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)mm\b */
      16: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)Q\b */
      17: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)in\b */
      18: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)pt\b */
      19: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)pc\b */
      20: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)px\b */
      21: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)deg\b */
      22: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)grad\b */
      23: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)rad\b */
      24: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)turn\b */
      25: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)s\b */
      26: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)ms\b */
      27: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)Hz\b */
      28: 14,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)kHz\b */
      29: 14,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)dpi\b */
      30: 15,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)dpcm\b */
      31: 15,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)dppx\b */
      32: 15,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)% */
      33: 25,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)\b */
      34: 26,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)-?([a-zA-Z_]|[\240-\377]|(\\[0-9a-fA-F]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-fA-F]))([a-zA-Z0-9_-]|[\240-\377]|(\\[0-9a-fA-F]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-fA-F]))*\b */
      35: 16,

      /*! Conditions:: INITIAL */
      /*! Rule::       \( */
      36: 4,

      /*! Conditions:: INITIAL */
      /*! Rule::       \) */
      37: 5,

      /*! Conditions:: INITIAL */
      /*! Rule::       $ */
      38: 1
    },

    rules: [
      /*  0: */  /^(?:\s+)/i,
      /*  1: */  /^(?:(-(webkit|moz)-)?calc\b)/i,
      /*  2: */  /^(?:[a-z][\d\-a-z]*\s*\((?:(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*')|\([^)]*\)|[^()]*)*\))/i,
      /*  3: */  /^(?:\*)/i,
      /*  4: */  /^(?:\/)/i,
      /*  5: */  /^(?:\+)/i,
      /*  6: */  /^(?:-)/i,
      /*  7: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)em\b)/i,
      /*  8: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)ex\b)/i,
      /*  9: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)ch\b)/i,
      /* 10: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)rem\b)/i,
      /* 11: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vw\b)/i,
      /* 12: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vh\b)/i,
      /* 13: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vmin\b)/i,
      /* 14: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vmax\b)/i,
      /* 15: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)cm\b)/i,
      /* 16: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)mm\b)/i,
      /* 17: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)Q\b)/i,
      /* 18: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)in\b)/i,
      /* 19: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)pt\b)/i,
      /* 20: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)pc\b)/i,
      /* 21: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)px\b)/i,
      /* 22: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)deg\b)/i,
      /* 23: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)grad\b)/i,
      /* 24: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)rad\b)/i,
      /* 25: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)turn\b)/i,
      /* 26: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)s\b)/i,
      /* 27: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)ms\b)/i,
      /* 28: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)Hz\b)/i,
      /* 29: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)kHz\b)/i,
      /* 30: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)dpi\b)/i,
      /* 31: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)dpcm\b)/i,
      /* 32: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)dppx\b)/i,
      /* 33: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)%)/i,
      /* 34: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)\b)/i,
      /* 35: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)-?([^\W\d]|[-]|(\\[\dA-Fa-f]{1,6}(\r\n|[\t\n\f\r ])?|\\[^\d\n\f\rA-Fa-f]))([\w\-]|[-]|(\\[\dA-Fa-f]{1,6}(\r\n|[\t\n\f\r ])?|\\[^\d\n\f\rA-Fa-f]))*\b)/i,
      /* 36: */  /^(?:\()/i,
      /* 37: */  /^(?:\))/i,
      /* 38: */  /^(?:$)/i
    ],

    conditions: {
      'INITIAL': {
        rules: [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38
        ],

        inclusive: true
      }
    }
  };

  return lexer;
}();
parser.lexer = lexer;



function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (true) {
  exports.parser = parser;
  exports.Parser = parser.Parser;
  exports.parse = function () {
    return parser.parse.apply(parser, arguments);
  };
  
}


/***/ }),

/***/ 13697:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _browserslist = _interopRequireDefault(__nccwpck_require__(55478));

var _caniuseApi = __nccwpck_require__(78390);

var _postcssValueParser = _interopRequireWildcard(__nccwpck_require__(19285));

var _minifyColor = _interopRequireDefault(__nccwpck_require__(10896));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function walk(parent, callback) {
  parent.nodes.forEach((node, index) => {
    const bubble = callback(node, index, parent);

    if (node.nodes && bubble !== false) {
      walk(node, callback);
    }
  });
}
/*
 * IE 8 & 9 do not properly handle clicks on elements
 * with a `transparent` `background-color`.
 *
 * https://developer.mozilla.org/en-US/docs/Web/Events/click#Internet_Explorer
 */


function hasTransparentBug(browser) {
  return ~['ie 8', 'ie 9'].indexOf(browser);
}

function isMathFunctionNode(node) {
  if (node.type !== 'function') {
    return false;
  }

  return ['calc', 'min', 'max', 'clamp'].includes(node.value.toLowerCase());
}

function transform(value, options) {
  const parsed = (0, _postcssValueParser.default)(value);
  walk(parsed, (node, index, parent) => {
    if (node.type === 'function') {
      if (/^(rgb|hsl)a?$/i.test(node.value)) {
        const {
          value: originalValue
        } = node;
        node.value = (0, _minifyColor.default)((0, _postcssValueParser.stringify)(node), options);
        node.type = 'word';
        const next = parent.nodes[index + 1];

        if (node.value !== originalValue && next && (next.type === 'word' || next.type === 'function')) {
          parent.nodes.splice(index + 1, 0, {
            type: 'space',
            value: ' '
          });
        }
      } else if (isMathFunctionNode(node)) {
        return false;
      }
    } else if (node.type === 'word') {
      node.value = (0, _minifyColor.default)(node.value, options);
    }
  });
  return parsed.toString();
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-colormin',

    prepare(result) {
      const resultOpts = result.opts || {};
      const browsers = (0, _browserslist.default)(null, {
        stats: resultOpts.stats,
        path: __dirname,
        env: resultOpts.env
      });
      const options = {
        supportsTransparent: browsers.some(hasTransparentBug) === false,
        supportsAlphaHex: (0, _caniuseApi.isSupported)('css-rrggbbaa', browsers)
      };
      const cache = {};
      return {
        OnceExit(css) {
          css.walkDecls(decl => {
            if (/^(composes|font|filter|-webkit-tap-highlight-color)/i.test(decl.prop)) {
              return;
            }

            const value = decl.value;

            if (!value) {
              return;
            }

            const cacheKey = JSON.stringify({
              value,
              options,
              browsers
            });

            if (cache[cacheKey]) {
              decl.value = cache[cacheKey];
              return;
            }

            const newValue = transform(value, options);
            decl.value = newValue;
            cache[cacheKey] = newValue;
          });
        }

      };
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 21458:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "process", ({
  enumerable: true,
  get: function () {
    return _colord.colord;
  }
}));
Object.defineProperty(exports, "getFormat", ({
  enumerable: true,
  get: function () {
    return _colord.getFormat;
  }
}));

var _colord = __nccwpck_require__(43);

var _names = _interopRequireDefault(__nccwpck_require__(44517));

var _getShortestString = _interopRequireDefault(__nccwpck_require__(3987));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let minifierPlugin = Colord => {
  /**
   * Shortens a color to 3 or 4 digit hexadecimal string if it's possible.
   * Returns the original (6 or 8 digit) hex if the it can't be shortened.
   */
  Colord.prototype.toShortHex = function ({
    formatAlpha
  }) {
    let hex = this.toHex();
    let [, r1, r2, g1, g2, b1, b2, a1, a2] = hex.split(''); // Check if the string can be shorten

    if (r1 === r2 && g1 === g2 && b1 === b2) {
      if (this.alpha() === 1) {
        // Express as 3 digit hexadecimal string if the color doesn't have an alpha channel
        return '#' + r1 + g1 + b1;
      } else if (formatAlpha && a1 === a2) {
        // Format 4 digit hex
        return '#' + r1 + g1 + b1 + a1;
      }
    }

    return hex;
  };
  /**
   * Returns the shortest representation of a color.
   */


  Colord.prototype.toShortString = function ({
    supportsTransparent,
    supportsAlphaHex
  }) {
    let {
      r,
      g,
      b
    } = this.toRgb();
    let a = this.alpha(); // RGB[A] and HSL[A] functional notations

    let options = [this.toRgbString(), // e.g. "rgb(128, 128, 128)" or "rgba(128, 128, 128, 0.5)"
    this.toHslString() // e.g. "hsl(180, 50%, 50%)" or "hsla(180, 50%, 50%, 0.5)"
    ]; // Hexadecimal notations

    if (supportsAlphaHex && a < 1) {
      let alphaHex = this.toShortHex({
        formatAlpha: true
      }); // e.g. "#7777" or "#80808080"
      // Output 4 or 8 digit hex only if the color conversion is lossless

      if ((0, _colord.colord)(alphaHex).alpha() === a) {
        options.push(alphaHex);
      }
    } else if (a === 1) {
      options.push(this.toShortHex({
        formatAlpha: false
      })); // e.g. "#777" or "#808080"
    } // CSS keyword


    if (supportsTransparent && r === 0 && g === 0 && b === 0 && a === 0) {
      options.push('transparent');
    } else if (a === 1) {
      let name = this.toName(); // e.g. "gray"

      if (name) {
        options.push(name);
      }
    } // Find the shortest option available


    return (0, _getShortestString.default)(options);
  };
};

(0, _colord.extend)([_names.default, minifierPlugin]);

/***/ }),

/***/ 3987:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

/**
 * Returns the shortest string in array
 */
const getShortestString = strings => {
  let shortest = null;

  for (let string of strings) {
    if (shortest === null || string.length < shortest.length) {
      shortest = string;
    }
  }

  return shortest;
};

var _default = getShortestString;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 10896:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = minifyColor;

var _color = __nccwpck_require__(21458);

var _getShortestString = _interopRequireDefault(__nccwpck_require__(3987));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Performs color value minification
 *
 * @param {string} input - CSS value
 * @param {boolean} options.supportsAlphaHex - Does the browser support 4 & 8 character hex notation
 * @param {boolean} options.supportsTransparent  Does the browser support "transparent" value properly
 */
function minifyColor(input, options = {}) {
  const settings = {
    supportsAlphaHex: false,
    supportsTransparent: true,
    ...options
  };
  const instance = (0, _color.process)(input);

  if (instance.isValid()) {
    // Try to shorten the string if it is a valid CSS color value.
    // Fall back to the original input if it's smaller or has equal length/
    return (0, _getShortestString.default)([input.toLowerCase(), instance.toShortString(settings)]);
  } else {
    // Possibly malformed, so pass through
    return input;
  }
}

module.exports = exports.default;

/***/ }),

/***/ 8853:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireWildcard(__nccwpck_require__(19285));

var _convert = _interopRequireDefault(__nccwpck_require__(73834));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const LENGTH_UNITS = ['em', 'ex', 'ch', 'rem', 'vw', 'vh', 'vmin', 'vmax', 'cm', 'mm', 'q', 'in', 'pt', 'pc', 'px'];
/*
 * Numbers without digits after the dot are technically invalid,
 * but in that case css-value-parser returns the dot as part of the unit,
 * so we use this to remove the dot.
 */

function stripLeadingDot(item) {
  if (item.charCodeAt(0) === '.'.charCodeAt(0)) {
    return item.slice(1);
  } else {
    return item;
  }
}

function parseWord(node, opts, keepZeroUnit) {
  const pair = (0, _postcssValueParser.unit)(node.value);

  if (pair) {
    const num = Number(pair.number);
    const u = stripLeadingDot(pair.unit);

    if (num === 0) {
      node.value = 0 + (keepZeroUnit || !~LENGTH_UNITS.indexOf(u.toLowerCase()) && u !== '%' ? u : '');
    } else {
      node.value = (0, _convert.default)(num, u, opts);

      if (typeof opts.precision === 'number' && u.toLowerCase() === 'px' && ~pair.number.indexOf('.')) {
        const precision = Math.pow(10, opts.precision);
        node.value = Math.round(parseFloat(node.value) * precision) / precision + u;
      }
    }
  }
}

function clampOpacity(node) {
  const pair = (0, _postcssValueParser.unit)(node.value);

  if (!pair) {
    return;
  }

  let num = Number(pair.number);

  if (num > 1) {
    node.value = pair.unit === '%' ? num + pair.unit : 1 + pair.unit;
  } else if (num < 0) {
    node.value = 0 + pair.unit;
  }
}

function shouldKeepUnit(decl) {
  const {
    parent
  } = decl;
  const lowerCasedProp = decl.prop.toLowerCase();
  return ~decl.value.indexOf('%') && (lowerCasedProp === 'max-height' || lowerCasedProp === 'height') || parent.parent && parent.parent.name && parent.parent.name.toLowerCase() === 'keyframes' && lowerCasedProp === 'stroke-dasharray' || lowerCasedProp === 'stroke-dashoffset' || lowerCasedProp === 'stroke-width' || lowerCasedProp === 'line-height';
}

function transform(opts, decl) {
  const lowerCasedProp = decl.prop.toLowerCase();

  if (~lowerCasedProp.indexOf('flex') || lowerCasedProp.indexOf('--') === 0) {
    return;
  }

  decl.value = (0, _postcssValueParser.default)(decl.value).walk(node => {
    const lowerCasedValue = node.value.toLowerCase();

    if (node.type === 'word') {
      parseWord(node, opts, shouldKeepUnit(decl));

      if (lowerCasedProp === 'opacity' || lowerCasedProp === 'shape-image-threshold') {
        clampOpacity(node);
      }
    } else if (node.type === 'function') {
      if (lowerCasedValue === 'calc' || lowerCasedValue === 'min' || lowerCasedValue === 'max' || lowerCasedValue === 'clamp' || lowerCasedValue === 'hsl' || lowerCasedValue === 'hsla') {
        (0, _postcssValueParser.walk)(node.nodes, n => {
          if (n.type === 'word') {
            parseWord(n, opts, true);
          }
        });
        return false;
      }

      if (lowerCasedValue === 'url') {
        return false;
      }
    }
  }).toString();
}

const plugin = 'postcss-convert-values';

function pluginCreator(opts = {
  precision: false
}) {
  return {
    postcssPlugin: plugin,

    OnceExit(css) {
      css.walkDecls(transform.bind(null, opts));
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 73834:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;
const lengthConv = {
  in: 96,
  px: 1,
  pt: 4 / 3,
  pc: 16
};
const timeConv = {
  s: 1000,
  ms: 1
};
const angleConv = {
  turn: 360,
  deg: 1
};

function dropLeadingZero(number) {
  const value = String(number);

  if (number % 1) {
    if (value[0] === '0') {
      return value.slice(1);
    }

    if (value[0] === '-' && value[1] === '0') {
      return '-' + value.slice(2);
    }
  }

  return value;
}

function transform(number, unit, conversion) {
  const lowerCasedUnit = unit.toLowerCase();
  let one, base;
  let convertionUnits = Object.keys(conversion).filter(u => {
    if (conversion[u] === 1) {
      one = u;
    }

    return lowerCasedUnit !== u;
  });

  if (lowerCasedUnit === one) {
    base = number / conversion[lowerCasedUnit];
  } else {
    base = number * conversion[lowerCasedUnit];
  }

  return convertionUnits.map(u => dropLeadingZero(base / conversion[u]) + u).reduce((a, b) => a.length < b.length ? a : b);
}

function _default(number, unit, {
  time,
  length,
  angle
}) {
  let value = dropLeadingZero(number) + (unit ? unit : '');
  let converted;

  if (length !== false && unit.toLowerCase() in lengthConv) {
    converted = transform(number, unit, lengthConv);
  }

  if (time !== false && unit.toLowerCase() in timeConv) {
    converted = transform(number, unit, timeConv);
  }

  if (angle !== false && unit.toLowerCase() in angleConv) {
    converted = transform(number, unit, angleConv);
  }

  if (converted && converted.length < value.length) {
    value = converted;
  }

  return value;
}

module.exports = exports.default;

/***/ }),

/***/ 79475:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _commentRemover = _interopRequireDefault(__nccwpck_require__(41192));

var _commentParser = _interopRequireDefault(__nccwpck_require__(465));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function pluginCreator(opts = {}) {
  const remover = new _commentRemover.default(opts);
  const matcherCache = {};
  const replacerCache = {};

  function matchesComments(source) {
    if (matcherCache[source]) {
      return matcherCache[source];
    }

    const result = (0, _commentParser.default)(source).filter(([type]) => type);
    matcherCache[source] = result;
    return result;
  }

  function replaceComments(source, space, separator = ' ') {
    const key = source + '@|@' + separator;

    if (replacerCache[key]) {
      return replacerCache[key];
    }

    const parsed = (0, _commentParser.default)(source).reduce((value, [type, start, end]) => {
      const contents = source.slice(start, end);

      if (!type) {
        return value + contents;
      }

      if (remover.canRemove(contents)) {
        return value + separator;
      }

      return `${value}/*${contents}*/`;
    }, '');
    const result = space(parsed).join(' ');
    replacerCache[key] = result;
    return result;
  }

  return {
    postcssPlugin: 'postcss-discard-comments',

    OnceExit(css, {
      list
    }) {
      css.walk(node => {
        if (node.type === 'comment' && remover.canRemove(node.text)) {
          node.remove();
          return;
        }

        if (node.raws.between) {
          node.raws.between = replaceComments(node.raws.between, list.space);
        }

        if (node.type === 'decl') {
          if (node.raws.value && node.raws.value.raw) {
            if (node.raws.value.value === node.value) {
              node.value = replaceComments(node.raws.value.raw, list.space);
            } else {
              node.value = replaceComments(node.value, list.space);
            }

            node.raws.value = null;
          }

          if (node.raws.important) {
            node.raws.important = replaceComments(node.raws.important, list.space);
            const b = matchesComments(node.raws.important);
            node.raws.important = b.length ? node.raws.important : '!important';
          }

          return;
        }

        if (node.type === 'rule' && node.raws.selector && node.raws.selector.raw) {
          node.raws.selector.raw = replaceComments(node.raws.selector.raw, list.space, '');
          return;
        }

        if (node.type === 'atrule') {
          if (node.raws.afterName) {
            const commentsReplaced = replaceComments(node.raws.afterName, list.space);

            if (!commentsReplaced.length) {
              node.raws.afterName = commentsReplaced + ' ';
            } else {
              node.raws.afterName = ' ' + commentsReplaced + ' ';
            }
          }

          if (node.raws.params && node.raws.params.raw) {
            node.raws.params.raw = replaceComments(node.raws.params.raw, list.space);
          }
        }
      });
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 465:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = commentParser;

function commentParser(input) {
  const tokens = [];
  const length = input.length;
  let pos = 0;
  let next;

  while (pos < length) {
    next = input.indexOf('/*', pos);

    if (~next) {
      tokens.push([0, pos, next]);
      pos = next;
      next = input.indexOf('*/', pos + 2);
      tokens.push([1, pos + 2, next]);
      pos = next + 2;
    } else {
      tokens.push([0, pos, length]);
      pos = length;
    }
  }

  return tokens;
}

module.exports = exports.default;

/***/ }),

/***/ 41192:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

function CommentRemover(options) {
  this.options = options;
}

CommentRemover.prototype.canRemove = function (comment) {
  const remove = this.options.remove;

  if (remove) {
    return remove(comment);
  } else {
    const isImportant = comment.indexOf('!') === 0;

    if (!isImportant) {
      return true;
    }

    if (this.options.removeAll || this._hasFirst) {
      return true;
    } else if (this.options.removeAllButFirst && !this._hasFirst) {
      this._hasFirst = true;
      return false;
    }
  }
};

var _default = CommentRemover;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 28648:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

function noop() {}

function trimValue(value) {
  return value ? value.trim() : value;
}

function empty(node) {
  return !node.nodes.filter(child => child.type !== 'comment').length;
}

function equals(a, b) {
  if (a.type !== b.type) {
    return false;
  }

  if (a.important !== b.important) {
    return false;
  }

  if (a.raws && !b.raws || !a.raws && b.raws) {
    return false;
  }

  switch (a.type) {
    case 'rule':
      if (a.selector !== b.selector) {
        return false;
      }

      break;

    case 'atrule':
      if (a.name !== b.name || a.params !== b.params) {
        return false;
      }

      if (a.raws && trimValue(a.raws.before) !== trimValue(b.raws.before)) {
        return false;
      }

      if (a.raws && trimValue(a.raws.afterName) !== trimValue(b.raws.afterName)) {
        return false;
      }

      break;

    case 'decl':
      if (a.prop !== b.prop || a.value !== b.value) {
        return false;
      }

      if (a.raws && trimValue(a.raws.before) !== trimValue(b.raws.before)) {
        return false;
      }

      break;
  }

  if (a.nodes) {
    if (a.nodes.length !== b.nodes.length) {
      return false;
    }

    for (let i = 0; i < a.nodes.length; i++) {
      if (!equals(a.nodes[i], b.nodes[i])) {
        return false;
      }
    }
  }

  return true;
}

function dedupeRule(last, nodes) {
  let index = nodes.indexOf(last) - 1;

  while (index >= 0) {
    const node = nodes[index--];

    if (node && node.type === 'rule' && node.selector === last.selector) {
      last.each(child => {
        if (child.type === 'decl') {
          dedupeNode(child, node.nodes);
        }
      });

      if (empty(node)) {
        node.remove();
      }
    }
  }
}

function dedupeNode(last, nodes) {
  let index = ~nodes.indexOf(last) ? nodes.indexOf(last) - 1 : nodes.length - 1;

  while (index >= 0) {
    const node = nodes[index--];

    if (node && equals(node, last)) {
      node.remove();
    }
  }
}

const handlers = {
  rule: dedupeRule,
  atrule: dedupeNode,
  decl: dedupeNode,
  comment: noop
};

function dedupe(root) {
  const {
    nodes
  } = root;

  if (!nodes) {
    return;
  }

  let index = nodes.length - 1;

  while (index >= 0) {
    let last = nodes[index--];

    if (!last || !last.parent) {
      continue;
    }

    dedupe(last);
    handlers[last.type](last, nodes);
  }
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-discard-duplicates',

    OnceExit(css) {
      dedupe(css);
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 94888:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
const plugin = 'postcss-discard-empty';

function discardAndReport(css, result) {
  function discardEmpty(node) {
    const {
      type,
      nodes: sub,
      params
    } = node;

    if (sub) {
      node.each(discardEmpty);
    }

    if (type === 'decl' && !node.value || type === 'rule' && !node.selector || sub && !sub.length || type === 'atrule' && (!sub && !params || !params && !sub.length)) {
      node.remove();
      result.messages.push({
        type: 'removal',
        plugin,
        node
      });
    }
  }

  css.each(discardEmpty);
}

function pluginCreator() {
  return {
    postcssPlugin: plugin,

    OnceExit(css, {
      result
    }) {
      discardAndReport(css, result);
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 27467:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
const OVERRIDABLE_RULES = ['keyframes', 'counter-style'];
const SCOPE_RULES = ['media', 'supports'];

function vendorUnprefixed(prop) {
  return prop.replace(/^-\w+-/, '');
}

function isOverridable(name) {
  return ~OVERRIDABLE_RULES.indexOf(vendorUnprefixed(name.toLowerCase()));
}

function isScope(name) {
  return ~SCOPE_RULES.indexOf(vendorUnprefixed(name.toLowerCase()));
}

function getScope(node) {
  let current = node.parent;
  const chain = [node.name.toLowerCase(), node.params];

  do {
    if (current.type === 'atrule' && isScope(current.name)) {
      chain.unshift(current.name + ' ' + current.params);
    }

    current = current.parent;
  } while (current);

  return chain.join('|');
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-discard-overridden',

    prepare() {
      const cache = {};
      const rules = [];
      return {
        OnceExit(css) {
          css.walkAtRules(node => {
            if (isOverridable(node.name)) {
              const scope = getScope(node);
              cache[scope] = node;
              rules.push({
                node,
                scope
              });
            }
          });
          rules.forEach(rule => {
            if (cache[rule.scope] !== rule.node) {
              rule.node.remove();
            }
          });
        }

      };
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 51028:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _decl = _interopRequireDefault(__nccwpck_require__(41697));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-merge-longhand',

    OnceExit(css) {
      css.walkRules(rule => {
        _decl.default.forEach(p => {
          p.explode(rule);
          p.merge(rule);
        });
      });
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 17736:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _isCustomProp = _interopRequireDefault(__nccwpck_require__(88870));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const hasGlobalKeyword = prop => prop && prop.value && ['inherit', 'initial', 'unset', 'revert'].includes(prop.value.toLowerCase());

var _default = (prop, includeCustomProps = true) => {
  if (!prop.value || includeCustomProps && (0, _isCustomProp.default)(prop) || hasGlobalKeyword(prop)) {
    return false;
  }

  return true;
};

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 95496:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _isCustomProp = _interopRequireDefault(__nccwpck_require__(88870));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const important = node => node.important;

const unimportant = node => !node.important;

const hasInherit = node => node.value.toLowerCase() === 'inherit';

const hasInitial = node => node.value.toLowerCase() === 'initial';

const hasUnset = node => node.value.toLowerCase() === 'unset';

var _default = (props, includeCustomProps = true) => {
  if (props.some(hasInherit) && !props.every(hasInherit)) {
    return false;
  }

  if (props.some(hasInitial) && !props.every(hasInitial)) {
    return false;
  }

  if (props.some(hasUnset) && !props.every(hasUnset)) {
    return false;
  }

  if (includeCustomProps && props.some(_isCustomProp.default) && !props.every(_isCustomProp.default)) {
    return false;
  }

  return props.every(unimportant) || props.every(important);
};

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 54181:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcss = __nccwpck_require__(77001);

var _stylehacks = __nccwpck_require__(25884);

var _insertCloned = _interopRequireDefault(__nccwpck_require__(94558));

var _parseTrbl = _interopRequireDefault(__nccwpck_require__(35572));

var _hasAllProps = _interopRequireDefault(__nccwpck_require__(5220));

var _getDecls = _interopRequireDefault(__nccwpck_require__(4386));

var _getRules = _interopRequireDefault(__nccwpck_require__(91860));

var _getValue = _interopRequireDefault(__nccwpck_require__(8063));

var _mergeRules = _interopRequireDefault(__nccwpck_require__(67238));

var _minifyTrbl = _interopRequireDefault(__nccwpck_require__(38243));

var _minifyWsc = _interopRequireDefault(__nccwpck_require__(65318));

var _canMerge = _interopRequireDefault(__nccwpck_require__(95496));

var _remove = _interopRequireDefault(__nccwpck_require__(72490));

var _trbl = _interopRequireDefault(__nccwpck_require__(19740));

var _isCustomProp = _interopRequireDefault(__nccwpck_require__(88870));

var _canExplode = _interopRequireDefault(__nccwpck_require__(17736));

var _getLastNode = _interopRequireDefault(__nccwpck_require__(22226));

var _parseWsc = _interopRequireDefault(__nccwpck_require__(11779));

var _validateWsc = __nccwpck_require__(79900);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const wsc = ['width', 'style', 'color'];
const defaults = ['medium', 'none', 'currentcolor'];

function borderProperty(...parts) {
  return `border-${parts.join('-')}`;
}

function mapBorderProperty(value) {
  return borderProperty(value);
}

const directions = _trbl.default.map(mapBorderProperty);

const properties = wsc.map(mapBorderProperty);
const directionalProperties = directions.reduce((prev, curr) => prev.concat(wsc.map(prop => `${curr}-${prop}`)), []);
const precedence = [['border'], directions.concat(properties), directionalProperties];
const allProperties = precedence.reduce((a, b) => a.concat(b));

function getLevel(prop) {
  for (let i = 0; i < precedence.length; i++) {
    if (~precedence[i].indexOf(prop.toLowerCase())) {
      return i;
    }
  }
}

const isValueCustomProp = value => value && !!~value.search(/var\s*\(\s*--/i);

function canMergeValues(values) {
  return !values.some(isValueCustomProp);
}

function getColorValue(decl) {
  if (decl.prop.substr(-5) === 'color') {
    return decl.value;
  }

  return (0, _parseWsc.default)(decl.value)[2] || defaults[2];
}

function diffingProps(values, nextValues) {
  return wsc.reduce((prev, curr, i) => {
    if (values[i] === nextValues[i]) {
      return prev;
    }

    return [...prev, curr];
  }, []);
}

function mergeRedundant({
  values,
  nextValues,
  decl,
  nextDecl,
  index
}) {
  if (!(0, _canMerge.default)([decl, nextDecl])) {
    return;
  }

  if ((0, _stylehacks.detect)(decl) || (0, _stylehacks.detect)(nextDecl)) {
    return;
  }

  const diff = diffingProps(values, nextValues);

  if (diff.length > 1) {
    return;
  }

  const prop = diff.pop();
  const position = wsc.indexOf(prop);
  const prop1 = `${nextDecl.prop}-${prop}`;
  const prop2 = `border-${prop}`;
  let props = (0, _parseTrbl.default)(values[position]);
  props[index] = nextValues[position];
  const borderValue2 = values.filter((e, i) => i !== position).join(' ');
  const propValue2 = (0, _minifyTrbl.default)(props);
  const origLength = ((0, _minifyWsc.default)(decl.value) + nextDecl.prop + nextDecl.value).length;
  const newLength1 = decl.value.length + prop1.length + (0, _minifyWsc.default)(nextValues[position]).length;
  const newLength2 = borderValue2.length + prop2.length + propValue2.length;

  if (newLength1 < newLength2 && newLength1 < origLength) {
    nextDecl.prop = prop1;
    nextDecl.value = nextValues[position];
  }

  if (newLength2 < newLength1 && newLength2 < origLength) {
    decl.value = borderValue2;
    nextDecl.prop = prop2;
    nextDecl.value = propValue2;
  }
}

function isCloseEnough(mapped) {
  return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];
}

function getDistinctShorthands(mapped) {
  return mapped.reduce((a, b) => {
    a = Array.isArray(a) ? a : [a];

    if (!~a.indexOf(b)) {
      a.push(b);
    }

    return a;
  });
}

function explode(rule) {
  rule.walkDecls(/^border/i, decl => {
    if (!(0, _canExplode.default)(decl, false)) {
      return;
    }

    if ((0, _stylehacks.detect)(decl)) {
      return;
    }

    const prop = decl.prop.toLowerCase(); // border -> border-trbl

    if (prop === 'border') {
      if ((0, _validateWsc.isValidWsc)((0, _parseWsc.default)(decl.value))) {
        directions.forEach(direction => {
          (0, _insertCloned.default)(decl.parent, decl, {
            prop: direction
          });
        });
        return decl.remove();
      }
    } // border-trbl -> border-trbl-wsc


    if (directions.some(direction => prop === direction)) {
      let values = (0, _parseWsc.default)(decl.value);

      if ((0, _validateWsc.isValidWsc)(values)) {
        wsc.forEach((d, i) => {
          (0, _insertCloned.default)(decl.parent, decl, {
            prop: `${prop}-${d}`,
            value: values[i] || defaults[i]
          });
        });
        return decl.remove();
      }
    } // border-wsc -> border-trbl-wsc


    wsc.some(style => {
      if (prop !== borderProperty(style)) {
        return false;
      }

      (0, _parseTrbl.default)(decl.value).forEach((value, i) => {
        (0, _insertCloned.default)(decl.parent, decl, {
          prop: borderProperty(_trbl.default[i], style),
          value
        });
      });
      return decl.remove();
    });
  });
}

function merge(rule) {
  // border-trbl-wsc -> border-trbl
  _trbl.default.forEach(direction => {
    const prop = borderProperty(direction);
    (0, _mergeRules.default)(rule, wsc.map(style => borderProperty(direction, style)), (rules, lastNode) => {
      if ((0, _canMerge.default)(rules, false) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned.default)(lastNode.parent, lastNode, {
          prop,
          value: rules.map(_getValue.default).join(' ')
        });
        rules.forEach(_remove.default);
        return true;
      }
    });
  }); // border-trbl-wsc -> border-wsc


  wsc.forEach(style => {
    const prop = borderProperty(style);
    (0, _mergeRules.default)(rule, _trbl.default.map(direction => borderProperty(direction, style)), (rules, lastNode) => {
      if ((0, _canMerge.default)(rules) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned.default)(lastNode.parent, lastNode, {
          prop,
          value: (0, _minifyTrbl.default)(rules.map(_getValue.default).join(' '))
        });
        rules.forEach(_remove.default);
        return true;
      }
    });
  }); // border-trbl -> border-wsc

  (0, _mergeRules.default)(rule, directions, (rules, lastNode) => {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    const values = rules.map(({
      value
    }) => value);

    if (!canMergeValues(values)) {
      return;
    }

    const parsed = values.map(value => (0, _parseWsc.default)(value));

    if (!parsed.every(_validateWsc.isValidWsc)) {
      return;
    }

    wsc.forEach((d, i) => {
      const value = parsed.map(v => v[i] || defaults[i]);

      if (canMergeValues(value)) {
        (0, _insertCloned.default)(lastNode.parent, lastNode, {
          prop: borderProperty(d),
          value: (0, _minifyTrbl.default)(value)
        });
      } else {
        (0, _insertCloned.default)(lastNode.parent, lastNode);
      }
    });
    rules.forEach(_remove.default);
    return true;
  }); // border-wsc -> border
  // border-wsc -> border + border-color
  // border-wsc -> border + border-dir

  (0, _mergeRules.default)(rule, properties, (rules, lastNode) => {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    const values = rules.map(node => (0, _parseTrbl.default)(node.value));
    const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));

    if (!canMergeValues(mapped)) {
      return;
    }

    const [width, style, color] = rules;
    const reduced = getDistinctShorthands(mapped);

    if (isCloseEnough(mapped) && (0, _canMerge.default)(rules, false)) {
      const first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);
      const border = (0, _insertCloned.default)(lastNode.parent, lastNode, {
        prop: 'border',
        value: first ? reduced[0] : reduced[1]
      });

      if (reduced[1]) {
        const value = first ? reduced[1] : reduced[0];
        const prop = borderProperty(_trbl.default[mapped.indexOf(value)]);
        rule.insertAfter(border, Object.assign(lastNode.clone(), {
          prop,
          value
        }));
      }

      rules.forEach(_remove.default);
      return true;
    } else if (reduced.length === 1) {
      rule.insertBefore(color, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: [width, style].map(_getValue.default).join(' ')
      }));
      rules.filter(node => node.prop.toLowerCase() !== properties[2]).forEach(_remove.default);
      return true;
    }
  }); // border-wsc -> border + border-trbl

  (0, _mergeRules.default)(rule, properties, (rules, lastNode) => {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    const values = rules.map(node => (0, _parseTrbl.default)(node.value));
    const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));
    const reduced = getDistinctShorthands(mapped);
    const none = 'medium none currentcolor';

    if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {
      const filtered = mapped.filter(p => p !== none);
      const mostCommon = reduced.sort((a, b) => mapped.filter(v => v === b).length - mapped.filter(v => v === a).length)[0];
      const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;
      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: borderValue
      }));
      directions.forEach((dir, i) => {
        if (mapped[i] !== borderValue) {
          rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
            prop: dir,
            value: mapped[i]
          }));
        }
      });
      rules.forEach(_remove.default);
      return true;
    }
  }); // border-trbl -> border
  // border-trbl -> border + border-trbl

  (0, _mergeRules.default)(rule, directions, (rules, lastNode) => {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    const values = rules.map(node => {
      const wscValue = (0, _parseWsc.default)(node.value);

      if (!(0, _validateWsc.isValidWsc)(wscValue)) {
        return node.value;
      }

      return wscValue.map((value, i) => value || defaults[i]).join(' ');
    });
    const reduced = getDistinctShorthands(values);

    if (isCloseEnough(values)) {
      const first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);
      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: (0, _minifyWsc.default)(first ? values[0] : values[1])
      }));

      if (reduced[1]) {
        const value = first ? reduced[1] : reduced[0];
        const prop = directions[values.indexOf(value)];
        rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
          prop: prop,
          value: (0, _minifyWsc.default)(value)
        }));
      }

      rules.forEach(_remove.default);
      return true;
    }
  }); // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)

  directions.forEach(direction => {
    wsc.forEach((style, i) => {
      const prop = `${direction}-${style}`;
      (0, _mergeRules.default)(rule, [direction, prop], (rules, lastNode) => {
        if (lastNode.prop !== direction) {
          return;
        }

        const values = (0, _parseWsc.default)(lastNode.value);

        if (!(0, _validateWsc.isValidWsc)(values)) {
          return;
        }

        const wscProp = rules.filter(r => r !== lastNode)[0];

        if (!isValueCustomProp(values[i]) || (0, _isCustomProp.default)(wscProp)) {
          return;
        }

        const wscValue = values[i];
        values[i] = wscProp.value;

        if ((0, _canMerge.default)(rules, false) && !rules.some(_stylehacks.detect)) {
          (0, _insertCloned.default)(lastNode.parent, lastNode, {
            prop,
            value: wscValue
          });
          lastNode.value = (0, _minifyWsc.default)(values);
          wscProp.remove();
          return true;
        }
      });
    });
  }); // border-wsc + border (custom prop) -> border + border-wsc (custom prop)

  wsc.forEach((style, i) => {
    const prop = borderProperty(style);
    (0, _mergeRules.default)(rule, ['border', prop], (rules, lastNode) => {
      if (lastNode.prop !== 'border') {
        return;
      }

      const values = (0, _parseWsc.default)(lastNode.value);

      if (!(0, _validateWsc.isValidWsc)(values)) {
        return;
      }

      const wscProp = rules.filter(r => r !== lastNode)[0];

      if (!isValueCustomProp(values[i]) || (0, _isCustomProp.default)(wscProp)) {
        return;
      }

      const wscValue = values[i];
      values[i] = wscProp.value;

      if ((0, _canMerge.default)(rules, false) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned.default)(lastNode.parent, lastNode, {
          prop,
          value: wscValue
        });
        lastNode.value = (0, _minifyWsc.default)(values);
        wscProp.remove();
        return true;
      }
    });
  }); // optimize border-trbl

  let decls = (0, _getDecls.default)(rule, directions);

  while (decls.length) {
    const lastNode = decls[decls.length - 1];
    wsc.forEach((d, i) => {
      const names = directions.filter(name => name !== lastNode.prop).map(name => `${name}-${d}`);
      let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));
      const border = (0, _getLastNode.default)(nodes, 'border');

      if (border) {
        nodes = nodes.slice(nodes.indexOf(border));
      }

      const props = nodes.filter(node => node.prop && ~names.indexOf(node.prop) && node.important === lastNode.important);
      const rules = (0, _getRules.default)(props, names);

      if ((0, _hasAllProps.default)(rules, ...names) && !rules.some(_stylehacks.detect)) {
        const values = rules.map(node => node ? node.value : null);
        const filteredValues = values.filter(Boolean);

        const lastNodeValue = _postcss.list.space(lastNode.value)[i];

        values[directions.indexOf(lastNode.prop)] = lastNodeValue;
        let value = (0, _minifyTrbl.default)(values.join(' '));

        if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {
          value = filteredValues[0];
        }

        let refNode = props[props.length - 1];

        if (value === lastNodeValue) {
          refNode = lastNode;

          let valueArray = _postcss.list.space(lastNode.value);

          valueArray.splice(i, 1);
          lastNode.value = valueArray.join(' ');
        }

        (0, _insertCloned.default)(refNode.parent, refNode, {
          prop: borderProperty(d),
          value
        });
        decls = decls.filter(node => !~rules.indexOf(node));
        rules.forEach(_remove.default);
      }
    });
    decls = decls.filter(node => node !== lastNode);
  }

  rule.walkDecls('border', decl => {
    const nextDecl = decl.next();

    if (!nextDecl || nextDecl.type !== 'decl') {
      return;
    }

    const index = directions.indexOf(nextDecl.prop);

    if (!~index) {
      return;
    }

    const values = (0, _parseWsc.default)(decl.value);
    const nextValues = (0, _parseWsc.default)(nextDecl.value);

    if (!(0, _validateWsc.isValidWsc)(values) || !(0, _validateWsc.isValidWsc)(nextValues)) {
      return;
    }

    const config = {
      values,
      nextValues,
      decl,
      nextDecl,
      index
    };
    return mergeRedundant(config);
  });
  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {
    let values = (0, _parseWsc.default)(decl.value);

    if (!(0, _validateWsc.isValidWsc)(values)) {
      return;
    }

    const position = directions.indexOf(decl.prop);
    let dirs = [...directions];
    dirs.splice(position, 1);
    wsc.forEach((d, i) => {
      const props = dirs.map(dir => `${dir}-${d}`);
      (0, _mergeRules.default)(rule, [decl.prop, ...props], rules => {
        if (!rules.includes(decl)) {
          return;
        }

        const longhands = rules.filter(p => p !== decl);

        if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && values[i] !== undefined && longhands[0].value.toLowerCase() === values[i].toLowerCase()) {
          longhands.forEach(_remove.default);
          (0, _insertCloned.default)(decl.parent, decl, {
            prop: borderProperty(d),
            value: values[i]
          });
          values[i] = null;
        }
      });
      const newValue = values.join(' ');

      if (newValue) {
        decl.value = newValue;
      } else {
        decl.remove();
      }
    });
  }); // clean-up values

  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {
    decl.value = (0, _minifyWsc.default)(decl.value);
  }); // border-spacing-hv -> border-spacing

  rule.walkDecls(/^border-spacing$/i, decl => {
    const value = _postcss.list.space(decl.value); // merge vertical and horizontal dups


    if (value.length > 1 && value[0] === value[1]) {
      decl.value = value.slice(1).join(' ');
    }
  }); // clean-up rules

  decls = (0, _getDecls.default)(rule, allProperties);

  while (decls.length) {
    const lastNode = decls[decls.length - 1];
    const lastPart = lastNode.prop.split('-').pop(); // remove properties of lower precedence

    const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && !(0, _isCustomProp.default)(lastNode) && node !== lastNode && node.important === lastNode.important && getLevel(node.prop) > getLevel(lastNode.prop) && (!!~node.prop.toLowerCase().indexOf(lastNode.prop) || node.prop.toLowerCase().endsWith(lastPart)));
    lesser.forEach(_remove.default);
    decls = decls.filter(node => !~lesser.indexOf(node)); // get duplicate properties

    let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp.default)(node) && (0, _isCustomProp.default)(lastNode)));

    if (duplicates.length) {
      if (/hsla\(|rgba\(/i.test(getColorValue(lastNode))) {
        const preserve = duplicates.filter(node => !/hsla\(|rgba\(/i.test(getColorValue(node))).pop();
        duplicates = duplicates.filter(node => node !== preserve);
      }

      duplicates.forEach(_remove.default);
    }

    decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));
  }
}

var _default = {
  explode,
  merge
};
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 58986:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _stylehacks = __nccwpck_require__(25884);

var _canMerge = _interopRequireDefault(__nccwpck_require__(95496));

var _getDecls = _interopRequireDefault(__nccwpck_require__(4386));

var _minifyTrbl = _interopRequireDefault(__nccwpck_require__(38243));

var _parseTrbl = _interopRequireDefault(__nccwpck_require__(35572));

var _insertCloned = _interopRequireDefault(__nccwpck_require__(94558));

var _mergeRules = _interopRequireDefault(__nccwpck_require__(67238));

var _mergeValues = _interopRequireDefault(__nccwpck_require__(25017));

var _remove = _interopRequireDefault(__nccwpck_require__(72490));

var _trbl = _interopRequireDefault(__nccwpck_require__(19740));

var _isCustomProp = _interopRequireDefault(__nccwpck_require__(88870));

var _canExplode = _interopRequireDefault(__nccwpck_require__(17736));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = prop => {
  const properties = _trbl.default.map(direction => `${prop}-${direction}`);

  const cleanup = rule => {
    let decls = (0, _getDecls.default)(rule, [prop].concat(properties));

    while (decls.length) {
      const lastNode = decls[decls.length - 1]; // remove properties of lower precedence

      const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === prop && node.prop !== lastNode.prop);
      lesser.forEach(_remove.default);
      decls = decls.filter(node => !~lesser.indexOf(node)); // get duplicate properties

      let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp.default)(node) && (0, _isCustomProp.default)(lastNode)));
      duplicates.forEach(_remove.default);
      decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));
    }
  };

  const processor = {
    explode: rule => {
      rule.walkDecls(new RegExp('^' + prop + '$', 'i'), decl => {
        if (!(0, _canExplode.default)(decl)) {
          return;
        }

        if ((0, _stylehacks.detect)(decl)) {
          return;
        }

        const values = (0, _parseTrbl.default)(decl.value);

        _trbl.default.forEach((direction, index) => {
          (0, _insertCloned.default)(decl.parent, decl, {
            prop: properties[index],
            value: values[index]
          });
        });

        decl.remove();
      });
    },
    merge: rule => {
      (0, _mergeRules.default)(rule, properties, (rules, lastNode) => {
        if ((0, _canMerge.default)(rules) && !rules.some(_stylehacks.detect)) {
          (0, _insertCloned.default)(lastNode.parent, lastNode, {
            prop,
            value: (0, _minifyTrbl.default)((0, _mergeValues.default)(...rules))
          });
          rules.forEach(_remove.default);
          return true;
        }
      });
      cleanup(rule);
    }
  };
  return processor;
};

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 850:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcss = __nccwpck_require__(77001);

var _postcssValueParser = __nccwpck_require__(19285);

var _stylehacks = __nccwpck_require__(25884);

var _canMerge = _interopRequireDefault(__nccwpck_require__(95496));

var _getDecls = _interopRequireDefault(__nccwpck_require__(4386));

var _getValue = _interopRequireDefault(__nccwpck_require__(8063));

var _mergeRules = _interopRequireDefault(__nccwpck_require__(67238));

var _insertCloned = _interopRequireDefault(__nccwpck_require__(94558));

var _remove = _interopRequireDefault(__nccwpck_require__(72490));

var _isCustomProp = _interopRequireDefault(__nccwpck_require__(88870));

var _canExplode = _interopRequireDefault(__nccwpck_require__(17736));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const properties = ['column-width', 'column-count'];
const auto = 'auto';
const inherit = 'inherit';
/**
 * Normalize a columns shorthand definition. Both of the longhand
 * properties' initial values are 'auto', and as per the spec,
 * omitted values are set to their initial values. Thus, we can
 * remove any 'auto' definition when there are two values.
 *
 * Specification link: https://www.w3.org/TR/css3-multicol/
 */

function normalize(values) {
  if (values[0].toLowerCase() === auto) {
    return values[1];
  }

  if (values[1].toLowerCase() === auto) {
    return values[0];
  }

  if (values[0].toLowerCase() === inherit && values[1].toLowerCase() === inherit) {
    return inherit;
  }

  return values.join(' ');
}

function explode(rule) {
  rule.walkDecls(/^columns$/i, decl => {
    if (!(0, _canExplode.default)(decl)) {
      return;
    }

    if ((0, _stylehacks.detect)(decl)) {
      return;
    }

    let values = _postcss.list.space(decl.value);

    if (values.length === 1) {
      values.push(auto);
    }

    values.forEach((value, i) => {
      let prop = properties[1];

      if (value.toLowerCase() === auto) {
        prop = properties[i];
      } else if ((0, _postcssValueParser.unit)(value).unit) {
        prop = properties[0];
      }

      (0, _insertCloned.default)(decl.parent, decl, {
        prop,
        value
      });
    });
    decl.remove();
  });
}

function cleanup(rule) {
  let decls = (0, _getDecls.default)(rule, ['columns'].concat(properties));

  while (decls.length) {
    const lastNode = decls[decls.length - 1]; // remove properties of lower precedence

    const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === 'columns' && node.prop !== lastNode.prop);
    lesser.forEach(_remove.default);
    decls = decls.filter(node => !~lesser.indexOf(node)); // get duplicate properties

    let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp.default)(node) && (0, _isCustomProp.default)(lastNode)));
    duplicates.forEach(_remove.default);
    decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));
  }
}

function merge(rule) {
  (0, _mergeRules.default)(rule, properties, (rules, lastNode) => {
    if ((0, _canMerge.default)(rules) && !rules.some(_stylehacks.detect)) {
      (0, _insertCloned.default)(lastNode.parent, lastNode, {
        prop: 'columns',
        value: normalize(rules.map(_getValue.default))
      });
      rules.forEach(_remove.default);
      return true;
    }
  });
  cleanup(rule);
}

var _default = {
  explode,
  merge
};
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 41697:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _borders = _interopRequireDefault(__nccwpck_require__(54181));

var _columns = _interopRequireDefault(__nccwpck_require__(850));

var _margin = _interopRequireDefault(__nccwpck_require__(58541));

var _padding = _interopRequireDefault(__nccwpck_require__(32008));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = [_borders.default, _columns.default, _margin.default, _padding.default];
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 58541:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _boxBase = _interopRequireDefault(__nccwpck_require__(58986));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _boxBase.default)('margin');

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 32008:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _boxBase = _interopRequireDefault(__nccwpck_require__(58986));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _boxBase.default)('padding');

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 4386:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = getDecls;

function getDecls(rule, properties) {
  return rule.nodes.filter(({
    prop
  }) => prop && ~properties.indexOf(prop.toLowerCase()));
}

module.exports = exports.default;

/***/ }),

/***/ 22226:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _default = (rule, prop) => {
  return rule.filter(n => n.prop && n.prop.toLowerCase() === prop).pop();
};

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 91860:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = getRules;

var _getLastNode = _interopRequireDefault(__nccwpck_require__(22226));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getRules(props, properties) {
  return properties.map(property => {
    return (0, _getLastNode.default)(props, property);
  }).filter(Boolean);
}

module.exports = exports.default;

/***/ }),

/***/ 8063:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = getValue;

function getValue({
  value
}) {
  return value;
}

module.exports = exports.default;

/***/ }),

/***/ 5220:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _default = (rule, ...props) => {
  return props.every(p => rule.some(({
    prop
  }) => prop && ~prop.toLowerCase().indexOf(p)));
};

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 94558:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = insertCloned;

function insertCloned(rule, decl, props) {
  const newNode = Object.assign(decl.clone(), props);
  rule.insertAfter(decl, newNode);
  return newNode;
}

module.exports = exports.default;

/***/ }),

/***/ 88870:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _default = node => ~node.value.search(/var\s*\(\s*--/i);

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 67238:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = mergeRules;

var _hasAllProps = _interopRequireDefault(__nccwpck_require__(5220));

var _getDecls = _interopRequireDefault(__nccwpck_require__(4386));

var _getRules = _interopRequireDefault(__nccwpck_require__(91860));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isConflictingProp(propA, propB) {
  if (!propB.prop || propB.important !== propA.important) {
    return;
  }

  const parts = propA.prop.split('-');
  return parts.some(() => {
    parts.pop();
    return parts.join('-') === propB.prop;
  });
}

function hasConflicts(match, nodes) {
  const firstNode = Math.min.apply(null, match.map(n => nodes.indexOf(n)));
  const lastNode = Math.max.apply(null, match.map(n => nodes.indexOf(n)));
  const between = nodes.slice(firstNode + 1, lastNode);
  return match.some(a => between.some(b => isConflictingProp(a, b)));
}

function mergeRules(rule, properties, callback) {
  let decls = (0, _getDecls.default)(rule, properties);

  while (decls.length) {
    const last = decls[decls.length - 1];
    const props = decls.filter(node => node.important === last.important);
    const rules = (0, _getRules.default)(props, properties);

    if ((0, _hasAllProps.default)(rules, ...properties) && !hasConflicts(rules, rule.nodes)) {
      if (callback(rules, last, props)) {
        decls = decls.filter(node => !~rules.indexOf(node));
      }
    }

    decls = decls.filter(node => node !== last);
  }
}

module.exports = exports.default;

/***/ }),

/***/ 25017:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _getValue = _interopRequireDefault(__nccwpck_require__(8063));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (...rules) => rules.map(_getValue.default).join(' ');

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 38243:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _parseTrbl = _interopRequireDefault(__nccwpck_require__(35572));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = v => {
  const value = (0, _parseTrbl.default)(v);

  if (value[3] === value[1]) {
    value.pop();

    if (value[2] === value[0]) {
      value.pop();

      if (value[0] === value[1]) {
        value.pop();
      }
    }
  }

  return value.join(' ');
};

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 65318:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _parseWsc = _interopRequireDefault(__nccwpck_require__(11779));

var _minifyTrbl = _interopRequireDefault(__nccwpck_require__(38243));

var _validateWsc = __nccwpck_require__(79900);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaults = ['medium', 'none', 'currentcolor'];

var _default = v => {
  const values = (0, _parseWsc.default)(v);

  if (!(0, _validateWsc.isValidWsc)(values)) {
    return (0, _minifyTrbl.default)(v);
  }

  const value = [...values, ''].reduceRight((prev, cur, i, arr) => {
    if (cur === undefined || cur.toLowerCase() === defaults[i] && (!i || (arr[i - 1] || '').toLowerCase() !== cur.toLowerCase())) {
      return prev;
    }

    return cur + ' ' + prev;
  }).trim();
  return (0, _minifyTrbl.default)(value || 'none');
};

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 35572:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcss = __nccwpck_require__(77001);

var _default = v => {
  const s = typeof v === 'string' ? _postcss.list.space(v) : v;
  return [s[0], // top
  s[1] || s[0], // right
  s[2] || s[0], // bottom
  s[3] || s[1] || s[0] // left
  ];
};

exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 11779:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = parseWsc;

var _postcss = __nccwpck_require__(77001);

var _validateWsc = __nccwpck_require__(79900);

const none = /^\s*(none|medium)(\s+none(\s+(none|currentcolor))?)?\s*$/i;
const varRE = /(^.*var)(.*\(.*--.*\))(.*)/i;

const varPreserveCase = p => `${p[1].toLowerCase()}${p[2]}${p[3].toLowerCase()}`;

const toLower = v => {
  const match = varRE.exec(v);
  return match ? varPreserveCase(match) : v.toLowerCase();
};

function parseWsc(value) {
  if (none.test(value)) {
    return ['medium', 'none', 'currentcolor'];
  }

  let width, style, color;

  const values = _postcss.list.space(value);

  if (values.length > 1 && (0, _validateWsc.isStyle)(values[1]) && values[0].toLowerCase() === 'none') {
    values.unshift();
    width = '0';
  }

  const unknown = [];
  values.forEach(v => {
    if ((0, _validateWsc.isStyle)(v)) {
      style = toLower(v);
    } else if ((0, _validateWsc.isWidth)(v)) {
      width = toLower(v);
    } else if ((0, _validateWsc.isColor)(v)) {
      color = toLower(v);
    } else {
      unknown.push(v);
    }
  });

  if (unknown.length) {
    if (!width && style && color) {
      width = unknown.pop();
    }

    if (width && !style && color) {
      style = unknown.pop();
    }

    if (width && style && !color) {
      color = unknown.pop();
    }
  }

  return [width, style, color];
}

module.exports = exports.default;

/***/ }),

/***/ 72490:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = remove;

function remove(node) {
  return node.remove();
}

module.exports = exports.default;

/***/ }),

/***/ 19740:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
var _default = ['top', 'right', 'bottom', 'left'];
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 79900:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isStyle = isStyle;
exports.isWidth = isWidth;
exports.isColor = isColor;
exports.isValidWsc = isValidWsc;

var _cssColorNames = _interopRequireDefault(__nccwpck_require__(80691));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const widths = ['thin', 'medium', 'thick'];
const styles = ['none', 'hidden', 'dotted', 'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset'];
const colors = Object.keys(_cssColorNames.default);

function isStyle(value) {
  return value && !!~styles.indexOf(value.toLowerCase());
}

function isWidth(value) {
  return value && !!~widths.indexOf(value.toLowerCase()) || /^(\d+(\.\d+)?|\.\d+)(\w+)?$/.test(value);
}

function isColor(value) {
  if (!value) {
    return false;
  }

  value = value.toLowerCase();

  if (/rgba?\(/.test(value)) {
    return true;
  }

  if (/hsla?\(/.test(value)) {
    return true;
  }

  if (/#([0-9a-z]{6}|[0-9a-z]{3})/.test(value)) {
    return true;
  }

  if (value === 'transparent') {
    return true;
  }

  if (value === 'currentcolor') {
    return true;
  }

  return !!~colors.indexOf(value);
}

function isValidWsc(wscs) {
  const validWidth = isWidth(wscs[0]);
  const validStyle = isStyle(wscs[1]);
  const validColor = isColor(wscs[2]);
  return validWidth && validStyle || validWidth && validColor || validStyle && validColor;
}

/***/ }),

/***/ 74210:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _browserslist = _interopRequireDefault(__nccwpck_require__(55478));

var _cssnanoUtils = __nccwpck_require__(96947);

var _ensureCompatibility = __nccwpck_require__(16788);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {postcss.Declaration} a
 * @param {postcss.Declaration} b
 * @return {boolean}
 */
function declarationIsEqual(a, b) {
  return a.important === b.important && a.prop === b.prop && a.value === b.value;
}
/**
 * @param {postcss.Declaration[]} array
 * @param {postcss.Declaration} decl
 * @return {number}
 */


function indexOfDeclaration(array, decl) {
  return array.findIndex(d => declarationIsEqual(d, decl));
}
/**
 * Returns filtered array of matched or unmatched declarations
 * @param {postcss.Declaration[]} a
 * @param {postcss.Declaration[]} b
 * @param {boolean} [not=false]
 * @return {postcss.Declaration[]}
 */


function intersect(a, b, not) {
  return a.filter(c => {
    const index = ~indexOfDeclaration(b, c);
    return not ? !index : index;
  });
}
/**
 * @param {postcss.Declaration[]} a
 * @param {postcss.Declaration[]} b
 * @return {boolean}
 */


function sameDeclarationsAndOrder(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  return a.every((d, index) => declarationIsEqual(d, b[index]));
}
/**
 * @param {postcss.Rule} ruleA
 * @param {postcss.Rule} ruleB
 * @param {string[]=} browsers
 * @param {Object.<string, boolean>=} compatibilityCache
 * @return {boolean}
 */


function canMerge(ruleA, ruleB, browsers, compatibilityCache) {
  const a = ruleA.selectors;
  const b = ruleB.selectors;
  const selectors = a.concat(b);

  if (!(0, _ensureCompatibility.ensureCompatibility)(selectors, browsers, compatibilityCache)) {
    return false;
  }

  const parent = (0, _cssnanoUtils.sameParent)(ruleA, ruleB);
  const {
    name
  } = ruleA.parent;

  if (parent && name && ~name.indexOf('keyframes')) {
    return false;
  }

  return parent && (selectors.every(_ensureCompatibility.noVendor) || (0, _ensureCompatibility.sameVendor)(a, b));
}
/**
 * @param {postcss.Rule} rule
 * @return {postcss.Declaration[]}
 */


function getDecls(rule) {
  return rule.nodes.filter(node => node.type === 'decl');
}

const joinSelectors = (...rules) => rules.map(s => s.selector).join();

function ruleLength(...rules) {
  return rules.map(r => r.nodes.length ? String(r) : '').join('').length;
}
/**
 * @param {string} prop
 * @return {{prefix: string, base:string, rest:string[]}}
 */


function splitProp(prop) {
  // Treat vendor prefixed properties as if they were unprefixed;
  // moving them when combined with non-prefixed properties can
  // cause issues. e.g. moving -webkit-background-clip when there
  // is a background shorthand definition.
  const parts = prop.split('-');

  if (prop[0] !== '-') {
    return {
      prefix: '',
      base: parts[0],
      rest: parts.slice(1)
    };
  } // Don't split css variables


  if (prop[1] === '-') {
    return {
      prefix: null,
      base: null,
      rest: [prop]
    };
  } // Found prefix


  return {
    prefix: parts[1],
    base: parts[2],
    rest: parts.slice(3)
  };
}
/**
 * @param {string} propA
 * @param {string} propB
 */


function isConflictingProp(propA, propB) {
  if (propA === propB) {
    // Same specificity
    return true;
  }

  const a = splitProp(propA);
  const b = splitProp(propB); // Don't resort css variables

  if (!a.base && !b.base) {
    return true;
  } // Different base;


  if (a.base !== b.base) {
    return false;
  } // Conflict if rest-count mismatches


  if (a.rest.length !== b.rest.length) {
    return true;
  } // Conflict if rest parameters are equal (same but unprefixed)


  return a.rest.every((s, index) => b.rest[index] === s);
}
/**
 * @param {postcss.Rule} first
 * @param {postcss.Rule} second
 * @return {boolean} merged
 */


function mergeParents(first, second) {
  // Null check for detached rules
  if (!first.parent || !second.parent) {
    return false;
  } // Check if parents share node


  if (first.parent === second.parent) {
    return false;
  } // sameParent() already called by canMerge()


  second.remove();
  first.parent.append(second);
  return true;
}
/**
 * @param {postcss.Rule} first
 * @param {postcss.Rule} second
 * @return {postcss.Rule} mergedRule
 */


function partialMerge(first, second) {
  let intersection = intersect(getDecls(first), getDecls(second));

  if (!intersection.length) {
    return second;
  }

  let nextRule = second.next();

  if (!nextRule) {
    // Grab next cousin
    const parentSibling = second.parent.next();
    nextRule = parentSibling && parentSibling.nodes && parentSibling.nodes[0];
  }

  if (nextRule && nextRule.type === 'rule' && canMerge(second, nextRule)) {
    let nextIntersection = intersect(getDecls(second), getDecls(nextRule));

    if (nextIntersection.length > intersection.length) {
      mergeParents(second, nextRule);
      first = second;
      second = nextRule;
      intersection = nextIntersection;
    }
  }

  const firstDecls = getDecls(first); // Filter out intersections with later conflicts in First

  intersection = intersection.filter((decl, intersectIndex) => {
    const indexOfDecl = indexOfDeclaration(firstDecls, decl);
    const nextConflictInFirst = firstDecls.slice(indexOfDecl + 1).filter(d => isConflictingProp(d.prop, decl.prop));

    if (!nextConflictInFirst.length) {
      return true;
    }

    const nextConflictInIntersection = intersection.slice(intersectIndex + 1).filter(d => isConflictingProp(d.prop, decl.prop));

    if (!nextConflictInIntersection.length) {
      return false;
    }

    if (nextConflictInFirst.length !== nextConflictInIntersection.length) {
      return false;
    }

    return nextConflictInFirst.every((d, index) => declarationIsEqual(d, nextConflictInIntersection[index]));
  }); // Filter out intersections with previous conflicts in Second

  const secondDecls = getDecls(second);
  intersection = intersection.filter(decl => {
    const nextConflictIndex = secondDecls.findIndex(d => isConflictingProp(d.prop, decl.prop));

    if (nextConflictIndex === -1) {
      return false;
    }

    if (!declarationIsEqual(secondDecls[nextConflictIndex], decl)) {
      return false;
    }

    if (decl.prop.toLowerCase() !== 'direction' && decl.prop.toLowerCase() !== 'unicode-bidi' && secondDecls.some(declaration => declaration.prop.toLowerCase() === 'all')) {
      return false;
    }

    secondDecls.splice(nextConflictIndex, 1);
    return true;
  });

  if (!intersection.length) {
    // Nothing to merge
    return second;
  }

  const receivingBlock = second.clone();
  receivingBlock.selector = joinSelectors(first, second);
  receivingBlock.nodes = [];
  second.parent.insertBefore(second, receivingBlock);
  const firstClone = first.clone();
  const secondClone = second.clone();
  /**
   * @param {function(postcss.Declaration):void} callback
   * @return {function(postcss.Declaration)}
   */

  function moveDecl(callback) {
    return decl => {
      if (~indexOfDeclaration(intersection, decl)) {
        callback.call(this, decl);
      }
    };
  }

  firstClone.walkDecls(moveDecl(decl => {
    decl.remove();
    receivingBlock.append(decl);
  }));
  secondClone.walkDecls(moveDecl(decl => decl.remove()));
  const merged = ruleLength(firstClone, receivingBlock, secondClone);
  const original = ruleLength(first, second);

  if (merged < original) {
    first.replaceWith(firstClone);
    second.replaceWith(secondClone);
    [firstClone, receivingBlock, secondClone].forEach(r => {
      if (!r.nodes.length) {
        r.remove();
      }
    });

    if (!secondClone.parent) {
      return receivingBlock;
    }

    return secondClone;
  } else {
    receivingBlock.remove();
    return second;
  }
}
/**
 * @param {string[]} browsers
 * @param {Object.<string, boolean>} compatibilityCache
 * @return {function(postcss.Rule)}
 */


function selectorMerger(browsers, compatibilityCache) {
  /** @type {postcss.Rule} */
  let cache = null;
  return function (rule) {
    // Prime the cache with the first rule, or alternately ensure that it is
    // safe to merge both declarations before continuing
    if (!cache || !canMerge(rule, cache, browsers, compatibilityCache)) {
      cache = rule;
      return;
    } // Ensure that we don't deduplicate the same rule; this is sometimes
    // caused by a partial merge


    if (cache === rule) {
      cache = rule;
      return;
    } // Parents merge: check if the rules have same parents, but not same parent nodes


    mergeParents(cache, rule); // Merge when declarations are exactly equal
    // e.g. h1 { color: red } h2 { color: red }

    if (sameDeclarationsAndOrder(getDecls(rule), getDecls(cache))) {
      rule.selector = joinSelectors(cache, rule);
      cache.remove();
      cache = rule;
      return;
    } // Merge when both selectors are exactly equal
    // e.g. a { color: blue } a { font-weight: bold }


    if (cache.selector === rule.selector) {
      const cached = getDecls(cache);
      rule.walk(decl => {
        if (~indexOfDeclaration(cached, decl)) {
          return decl.remove();
        }

        cache.append(decl);
      });
      rule.remove();
      return;
    } // Partial merge: check if the rule contains a subset of the last; if
    // so create a joined selector with the subset, if smaller.


    cache = partialMerge(cache, rule);
  };
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-merge-rules',

    prepare(result) {
      const resultOpts = result.opts || {};
      const browsers = (0, _browserslist.default)(null, {
        stats: resultOpts.stats,
        path: __dirname,
        env: resultOpts.env
      });
      const compatibilityCache = {};
      return {
        OnceExit(css) {
          css.walkRules(selectorMerger(browsers, compatibilityCache));
        }

      };
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 16788:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.filterPrefixes = filterPrefixes;
exports.sameVendor = sameVendor;
exports.noVendor = noVendor;
exports.ensureCompatibility = ensureCompatibility;
exports.pseudoElements = void 0;

var _caniuseApi = __nccwpck_require__(78390);

var _postcssSelectorParser = _interopRequireDefault(__nccwpck_require__(32997));

var _vendors = _interopRequireDefault(__nccwpck_require__(19001));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const simpleSelectorRe = /^#?[-._a-z0-9 ]+$/i;
const cssSel2 = 'css-sel2';
const cssSel3 = 'css-sel3';
const cssGencontent = 'css-gencontent';
const cssFirstLetter = 'css-first-letter';
const cssFirstLine = 'css-first-line';
const cssInOutOfRange = 'css-in-out-of-range';
const formValidation = 'form-validation';
/** @type {string[]} */

const prefixes = _vendors.default.map(v => `-${v}-`);
/**
 * @param {string} selector
 * @return {string[]}
 */


function filterPrefixes(selector) {
  return prefixes.filter(prefix => selector.indexOf(prefix) !== -1);
} // Internet Explorer use :-ms-input-placeholder.
// Microsoft Edge use ::-ms-input-placeholder.


const findMsInputPlaceholder = selector => ~selector.search(/-ms-input-placeholder/i);

function sameVendor(selectorsA, selectorsB) {
  let same = selectors => selectors.map(filterPrefixes).join();

  let findMsVendor = selectors => selectors.find(findMsInputPlaceholder);

  return same(selectorsA) === same(selectorsB) && !(findMsVendor(selectorsA) && findMsVendor(selectorsB));
}
/**
 * @param {string} selector
 * @return {boolean}
 */


function noVendor(selector) {
  return !filterPrefixes(selector).length;
}

const pseudoElements = {
  ':active': cssSel2,
  ':after': cssGencontent,
  ':any-link': 'css-any-link',
  ':before': cssGencontent,
  ':checked': cssSel3,
  ':default': 'css-default-pseudo',
  ':dir': 'css-dir-pseudo',
  ':disabled': cssSel3,
  ':empty': cssSel3,
  ':enabled': cssSel3,
  ':first-child': cssSel2,
  ':first-letter': cssFirstLetter,
  ':first-line': cssFirstLine,
  ':first-of-type': cssSel3,
  ':focus': cssSel2,
  ':focus-within': 'css-focus-within',
  ':focus-visible': 'css-focus-visible',
  ':has': 'css-has',
  ':hover': cssSel2,
  ':in-range': cssInOutOfRange,
  ':indeterminate': 'css-indeterminate-pseudo',
  ':invalid': formValidation,
  ':is': 'css-matches-pseudo',
  ':lang': cssSel2,
  ':last-child': cssSel3,
  ':last-of-type': cssSel3,
  ':link': cssSel2,
  ':matches': 'css-matches-pseudo',
  ':not': cssSel3,
  ':nth-child': cssSel3,
  ':nth-last-child': cssSel3,
  ':nth-last-of-type': cssSel3,
  ':nth-of-type': cssSel3,
  ':only-child': cssSel3,
  ':only-of-type': cssSel3,
  ':optional': 'css-optional-pseudo',
  ':out-of-range': cssInOutOfRange,
  ':placeholder-shown': 'css-placeholder-shown',
  ':required': formValidation,
  ':root': cssSel3,
  ':target': cssSel3,
  '::after': cssGencontent,
  '::backdrop': 'dialog',
  '::before': cssGencontent,
  '::first-letter': cssFirstLetter,
  '::first-line': cssFirstLine,
  '::marker': 'css-marker-pseudo',
  '::placeholder': 'css-placeholder',
  '::selection': 'css-selection',
  ':valid': formValidation,
  ':visited': cssSel2
};
exports.pseudoElements = pseudoElements;

function isCssMixin(selector) {
  return selector[selector.length - 1] === ':';
}

function isHostPseudoClass(selector) {
  return selector.includes(':host');
}

const isSupportedCache = {}; // Move to util in future

function isSupportedCached(feature, browsers) {
  const key = JSON.stringify({
    feature,
    browsers
  });
  let result = isSupportedCache[key];

  if (!result) {
    result = (0, _caniuseApi.isSupported)(feature, browsers);
    isSupportedCache[key] = result;
  }

  return result;
}

function ensureCompatibility(selectors, browsers, compatibilityCache) {
  // Should not merge mixins
  if (selectors.some(isCssMixin)) {
    return false;
  } // Should not merge :host selector https://github.com/angular/angular-cli/issues/18672


  if (selectors.some(isHostPseudoClass)) {
    return false;
  }

  return selectors.every(selector => {
    if (simpleSelectorRe.test(selector)) {
      return true;
    }

    if (compatibilityCache && selector in compatibilityCache) {
      return compatibilityCache[selector];
    }

    let compatible = true;
    (0, _postcssSelectorParser.default)(ast => {
      ast.walk(node => {
        const {
          type,
          value
        } = node;

        if (type === 'pseudo') {
          const entry = pseudoElements[value];

          if (!entry && noVendor(value)) {
            compatible = false;
          }

          if (entry && compatible) {
            compatible = isSupportedCached(entry, browsers);
          }
        }

        if (type === 'combinator') {
          if (~value.indexOf('~')) {
            compatible = isSupportedCached(cssSel3, browsers);
          }

          if (~value.indexOf('>') || ~value.indexOf('+')) {
            compatible = isSupportedCached(cssSel2, browsers);
          }
        }

        if (type === 'attribute' && node.attribute) {
          // [foo]
          if (!node.operator) {
            compatible = isSupportedCached(cssSel2, browsers);
          }

          if (value) {
            // [foo="bar"], [foo~="bar"], [foo|="bar"]
            if (~['=', '~=', '|='].indexOf(node.operator)) {
              compatible = isSupportedCached(cssSel2, browsers);
            } // [foo^="bar"], [foo$="bar"], [foo*="bar"]


            if (~['^=', '$=', '*='].indexOf(node.operator)) {
              compatible = isSupportedCached(cssSel3, browsers);
            }
          } // [foo="bar" i]


          if (node.insensitive) {
            compatible = isSupportedCached('css-case-insensitive', browsers);
          }
        }

        if (!compatible) {
          // If this node was not compatible,
          // break out early from walking the rest
          return false;
        }
      });
    }).processSync(selector);

    if (compatibilityCache) {
      compatibilityCache[selector] = compatible;
    }

    return compatible;
  });
}

/***/ }),

/***/ 20586:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

var _minifyWeight = _interopRequireDefault(__nccwpck_require__(42888));

var _minifyFamily = _interopRequireDefault(__nccwpck_require__(78161));

var _minifyFont = _interopRequireDefault(__nccwpck_require__(27626));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hasVariableFunction(value) {
  const lowerCasedValue = value.toLowerCase();
  return lowerCasedValue.includes('var(') || lowerCasedValue.includes('env(');
}

function transform(prop, value, opts) {
  let lowerCasedProp = prop.toLowerCase();

  if (lowerCasedProp === 'font-weight' && !hasVariableFunction(value)) {
    return (0, _minifyWeight.default)(value);
  } else if (lowerCasedProp === 'font-family' && !hasVariableFunction(value)) {
    const tree = (0, _postcssValueParser.default)(value);
    tree.nodes = (0, _minifyFamily.default)(tree.nodes, opts);
    return tree.toString();
  } else if (lowerCasedProp === 'font') {
    const tree = (0, _postcssValueParser.default)(value);
    tree.nodes = (0, _minifyFont.default)(tree.nodes, opts);
    return tree.toString();
  }

  return value;
}

function pluginCreator(opts) {
  opts = Object.assign({}, {
    removeAfterKeyword: false,
    removeDuplicates: true,
    removeQuotes: true
  }, opts);
  return {
    postcssPlugin: 'postcss-minify-font-values',

    prepare() {
      const cache = {};
      return {
        OnceExit(css) {
          css.walkDecls(/font/i, decl => {
            const value = decl.value;

            if (!value) {
              return;
            }

            const prop = decl.prop;
            const cacheKey = `${prop}|${value}`;

            if (cache[cacheKey]) {
              decl.value = cache[cacheKey];
              return;
            }

            const newValue = transform(prop, value, opts);
            decl.value = newValue;
            cache[cacheKey] = newValue;
          });
        }

      };
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 69812:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
var _default = {
  style: ['italic', 'oblique'],
  variant: ['small-caps'],
  weight: ['100', '200', '300', '400', '500', '600', '700', '800', '900', 'bold', 'lighter', 'bolder'],
  stretch: ['ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'],
  size: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'larger', 'smaller']
};
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 78161:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;

var _postcssValueParser = __nccwpck_require__(19285);

var _uniqs = _interopRequireDefault(__nccwpck_require__(97347));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const uniqs = (0, _uniqs.default)('monospace');
const globalKeywords = ['inherit', 'initial', 'unset'];
const genericFontFamilykeywords = ['sans-serif', 'serif', 'fantasy', 'cursive', 'monospace', 'system-ui'];

function makeArray(value, length) {
  let array = [];

  while (length--) {
    array[length] = value;
  }

  return array;
} // eslint-disable-next-line no-useless-escape


const regexSimpleEscapeCharacters = /[ !"#$%&'()*+,.\/;<=>?@\[\\\]^`{|}~]/;

function escape(string, escapeForString) {
  let counter = 0;
  let character = null;
  let charCode = null;
  let value = null;
  let output = '';

  while (counter < string.length) {
    character = string.charAt(counter++);
    charCode = character.charCodeAt(); // \r is already tokenized away at this point
    // `:` can be escaped as `\:`, but that fails in IE < 8

    if (!escapeForString && /[\t\n\v\f:]/.test(character)) {
      value = '\\' + charCode.toString(16) + ' ';
    } else if (!escapeForString && regexSimpleEscapeCharacters.test(character)) {
      value = '\\' + character;
    } else {
      value = character;
    }

    output += value;
  }

  if (!escapeForString) {
    if (/^-[-\d]/.test(output)) {
      output = '\\-' + output.slice(1);
    }

    const firstChar = string.charAt(0);

    if (/\d/.test(firstChar)) {
      output = '\\3' + firstChar + ' ' + output.slice(1);
    }
  }

  return output;
}

const regexKeyword = new RegExp(genericFontFamilykeywords.concat(globalKeywords).join('|'), 'i');
const regexInvalidIdentifier = /^(-?\d|--)/;
const regexSpaceAtStart = /^\x20/;
const regexWhitespace = /[\t\n\f\r\x20]/g;
const regexIdentifierCharacter = /^[a-zA-Z\d\xa0-\uffff_-]+$/;
const regexConsecutiveSpaces = /(\\(?:[a-fA-F0-9]{1,6}\x20|\x20))?(\x20{2,})/g;
const regexTrailingEscape = /\\[a-fA-F0-9]{0,6}\x20$/;
const regexTrailingSpace = /\x20$/;

function escapeIdentifierSequence(string) {
  let identifiers = string.split(regexWhitespace);
  let index = 0;
  let result = [];
  let escapeResult;

  while (index < identifiers.length) {
    let subString = identifiers[index++];

    if (subString === '') {
      result.push(subString);
      continue;
    }

    escapeResult = escape(subString, false);

    if (regexIdentifierCharacter.test(subString)) {
      // the font family name part consists of allowed characters exclusively
      if (regexInvalidIdentifier.test(subString)) {
        // the font family name part starts with two hyphens, a digit, or a
        // hyphen followed by a digit
        if (index === 1) {
          // if this is the first item
          result.push(escapeResult);
        } else {
          // if its not the first item, we can simply escape the space
          // between the two identifiers to merge them into a single
          // identifier rather than escaping the start characters of the
          // second identifier
          result[index - 2] += '\\';
          result.push(escape(subString, true));
        }
      } else {
        // the font family name part doesnt start with two hyphens, a digit,
        // or a hyphen followed by a digit
        result.push(escapeResult);
      }
    } else {
      // the font family name part contains invalid identifier characters
      result.push(escapeResult);
    }
  }

  result = result.join(' ').replace(regexConsecutiveSpaces, ($0, $1, $2) => {
    const spaceCount = $2.length;
    const escapesNeeded = Math.floor(spaceCount / 2);
    const array = makeArray('\\ ', escapesNeeded);

    if (spaceCount % 2) {
      array[escapesNeeded - 1] += '\\ ';
    }

    return ($1 || '') + ' ' + array.join(' ');
  }); // Escape trailing spaces unless theyre already part of an escape

  if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {
    result = result.replace(regexTrailingSpace, '\\ ');
  }

  if (regexSpaceAtStart.test(result)) {
    result = '\\ ' + result.slice(1);
  }

  return result;
}

function _default(nodes, opts) {
  let family = [];
  let last = null;
  let i, max;
  nodes.forEach((node, index, arr) => {
    if (node.type === 'string' || node.type === 'function') {
      family.push(node);
    } else if (node.type === 'word') {
      if (!last) {
        last = {
          type: 'word',
          value: ''
        };
        family.push(last);
      }

      last.value += node.value;
    } else if (node.type === 'space') {
      if (last && index !== arr.length - 1) {
        last.value += ' ';
      }
    } else {
      last = null;
    }
  });
  family = family.map(node => {
    if (node.type === 'string') {
      const isKeyword = regexKeyword.test(node.value);

      if (!opts.removeQuotes || isKeyword || /[0-9]/.test(node.value.slice(0, 1))) {
        return (0, _postcssValueParser.stringify)(node);
      }

      let escaped = escapeIdentifierSequence(node.value);

      if (escaped.length < node.value.length + 2) {
        return escaped;
      }
    }

    return (0, _postcssValueParser.stringify)(node);
  });

  if (opts.removeAfterKeyword) {
    for (i = 0, max = family.length; i < max; i += 1) {
      if (~genericFontFamilykeywords.indexOf(family[i].toLowerCase())) {
        family = family.slice(0, i + 1);
        break;
      }
    }
  }

  if (opts.removeDuplicates) {
    family = uniqs(family);
  }

  return [{
    type: 'word',
    value: family.join()
  }];
}

module.exports = exports.default;

/***/ }),

/***/ 27626:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;

var _postcssValueParser = __nccwpck_require__(19285);

var _keywords = _interopRequireDefault(__nccwpck_require__(69812));

var _minifyFamily = _interopRequireDefault(__nccwpck_require__(78161));

var _minifyWeight = _interopRequireDefault(__nccwpck_require__(42888));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(nodes, opts) {
  let i, max, node, familyStart, family;
  let hasSize = false;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];

    if (node.type === 'word') {
      if (hasSize) {
        continue;
      }

      const value = node.value.toLowerCase();

      if (value === 'normal' || value === 'inherit' || value === 'initial' || value === 'unset') {
        familyStart = i;
      } else if (~_keywords.default.style.indexOf(value) || (0, _postcssValueParser.unit)(value)) {
        familyStart = i;
      } else if (~_keywords.default.variant.indexOf(value)) {
        familyStart = i;
      } else if (~_keywords.default.weight.indexOf(value)) {
        node.value = (0, _minifyWeight.default)(value);
        familyStart = i;
      } else if (~_keywords.default.stretch.indexOf(value)) {
        familyStart = i;
      } else if (~_keywords.default.size.indexOf(value) || (0, _postcssValueParser.unit)(value)) {
        familyStart = i;
        hasSize = true;
      }
    } else if (node.type === 'function' && nodes[i + 1] && nodes[i + 1].type === 'space') {
      familyStart = i;
    } else if (node.type === 'div' && node.value === '/') {
      familyStart = i + 1;
      break;
    }
  }

  familyStart += 2;
  family = (0, _minifyFamily.default)(nodes.slice(familyStart), opts);
  return nodes.slice(0, familyStart).concat(family);
}

module.exports = exports.default;

/***/ }),

/***/ 42888:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;

function _default(value) {
  const lowerCasedValue = value.toLowerCase();
  return lowerCasedValue === 'normal' ? '400' : lowerCasedValue === 'bold' ? '700' : value;
}

module.exports = exports.default;

/***/ }),

/***/ 97347:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = uniqueExcept;

function uniqueExcept(exclude) {
  return function unique() {
    const list = Array.prototype.concat.apply([], arguments);
    return list.filter((item, i) => {
      if (item.toLowerCase() === exclude) {
        return true;
      }

      return i === list.indexOf(item);
    });
  };
}

module.exports = exports.default;

/***/ }),

/***/ 33683:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireWildcard(__nccwpck_require__(19285));

var _cssnanoUtils = __nccwpck_require__(96947);

var _isColorStop = _interopRequireDefault(__nccwpck_require__(97971));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const angles = {
  top: '0deg',
  right: '90deg',
  bottom: '180deg',
  left: '270deg'
};

function isLessThan(a, b) {
  return a.unit.toLowerCase() === b.unit.toLowerCase() && parseFloat(a.number) >= parseFloat(b.number);
}

function optimise(decl) {
  const value = decl.value;

  if (!value) {
    return;
  }

  const normalizedValue = value.toLowerCase();

  if (normalizedValue.includes('var(') || normalizedValue.includes('env(')) {
    return;
  }

  if (!normalizedValue.includes('gradient')) {
    return;
  }

  decl.value = (0, _postcssValueParser.default)(value).walk(node => {
    if (node.type !== 'function' || !node.nodes.length) {
      return false;
    }

    const lowerCasedValue = node.value.toLowerCase();

    if (lowerCasedValue === 'linear-gradient' || lowerCasedValue === 'repeating-linear-gradient' || lowerCasedValue === '-webkit-linear-gradient' || lowerCasedValue === '-webkit-repeating-linear-gradient') {
      let args = (0, _cssnanoUtils.getArguments)(node);

      if (node.nodes[0].value.toLowerCase() === 'to' && args[0].length === 3) {
        node.nodes = node.nodes.slice(2);
        node.nodes[0].value = angles[node.nodes[0].value.toLowerCase()];
      }

      let lastStop = null;
      args.forEach((arg, index) => {
        if (!arg[2]) {
          return;
        }

        let isFinalStop = index === args.length - 1;
        let thisStop = (0, _postcssValueParser.unit)(arg[2].value);

        if (lastStop === null) {
          lastStop = thisStop;

          if (!isFinalStop && lastStop && lastStop.number === '0' && lastStop.unit.toLowerCase() !== 'deg') {
            arg[1].value = arg[2].value = '';
          }

          return;
        }

        if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
          arg[2].value = 0;
        }

        lastStop = thisStop;

        if (isFinalStop && arg[2].value === '100%') {
          arg[1].value = arg[2].value = '';
        }
      });
      return false;
    }

    if (lowerCasedValue === 'radial-gradient' || lowerCasedValue === 'repeating-radial-gradient') {
      let args = (0, _cssnanoUtils.getArguments)(node);
      let lastStop;
      const hasAt = args[0].find(n => n.value.toLowerCase() === 'at');
      args.forEach((arg, index) => {
        if (!arg[2] || !index && hasAt) {
          return;
        }

        let thisStop = (0, _postcssValueParser.unit)(arg[2].value);

        if (!lastStop) {
          lastStop = thisStop;
          return;
        }

        if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
          arg[2].value = 0;
        }

        lastStop = thisStop;
      });
      return false;
    }

    if (lowerCasedValue === '-webkit-radial-gradient' || lowerCasedValue === '-webkit-repeating-radial-gradient') {
      let args = (0, _cssnanoUtils.getArguments)(node);
      let lastStop;
      args.forEach(arg => {
        let color;
        let stop;

        if (arg[2] !== undefined) {
          if (arg[0].type === 'function') {
            color = `${arg[0].value}(${(0, _postcssValueParser.stringify)(arg[0].nodes)})`;
          } else {
            color = arg[0].value;
          }

          if (arg[2].type === 'function') {
            stop = `${arg[2].value}(${(0, _postcssValueParser.stringify)(arg[2].nodes)})`;
          } else {
            stop = arg[2].value;
          }
        } else {
          if (arg[0].type === 'function') {
            color = `${arg[0].value}(${(0, _postcssValueParser.stringify)(arg[0].nodes)})`;
          }

          color = arg[0].value;
        }

        color = color.toLowerCase();
        const colorStop = stop || stop === 0 ? (0, _isColorStop.default)(color, stop.toLowerCase()) : (0, _isColorStop.default)(color);

        if (!colorStop || !arg[2]) {
          return;
        }

        let thisStop = (0, _postcssValueParser.unit)(arg[2].value);

        if (!lastStop) {
          lastStop = thisStop;
          return;
        }

        if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
          arg[2].value = 0;
        }

        lastStop = thisStop;
      });
      return false;
    }
  }).toString();
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-minify-gradients',

    OnceExit(css) {
      css.walkDecls(optimise);
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 97971:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isColorStop;

var _postcssValueParser = __nccwpck_require__(19285);

var _colord = __nccwpck_require__(43);

var _names = _interopRequireDefault(__nccwpck_require__(44517));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _colord.extend)([_names.default]);
/* Code derived from https://github.com/pigcan/is-color-stop */

const lengthArray = ['PX', 'IN', 'CM', 'MM', 'EM', 'REM', 'POINTS', 'PC', 'EX', 'CH', 'VW', 'VH', 'VMIN', 'VMAX', '%'];

function isCSSLengthUnit(input) {
  return lengthArray.includes(input.toUpperCase());
}

function isStop(str) {
  let stop = !str;

  if (!stop) {
    const node = (0, _postcssValueParser.unit)(str);

    if (node) {
      if (node.number === 0 || !isNaN(node.number) && isCSSLengthUnit(node.unit)) {
        stop = true;
      }
    } else {
      stop = /^calc\(\S+\)$/g.test(str);
    }
  }

  return stop;
}

function isColorStop(color, stop) {
  return (0, _colord.colord)(color).isValid() && isStop(stop);
}

module.exports = exports.default;

/***/ }),

/***/ 87496:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _browserslist = _interopRequireDefault(__nccwpck_require__(55478));

var _postcssValueParser = _interopRequireWildcard(__nccwpck_require__(19285));

var _alphanumSort = _interopRequireDefault(__nccwpck_require__(37910));

var _uniqs = _interopRequireDefault(__nccwpck_require__(53260));

var _cssnanoUtils = __nccwpck_require__(96947);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Return the greatest common divisor
 * of two numbers.
 */
function gcd(a, b) {
  return b ? gcd(b, a % b) : a;
}

function aspectRatio(a, b) {
  const divisor = gcd(a, b);
  return [a / divisor, b / divisor];
}

function split(args) {
  return args.map(arg => (0, _postcssValueParser.stringify)(arg)).join('');
}

function removeNode(node) {
  node.value = '';
  node.type = 'word';
}

function transform(legacy, rule) {
  const ruleName = rule.name.toLowerCase(); // We should re-arrange parameters only for `@media` and `@supports` at-rules

  if (!rule.params || !['media', 'supports'].includes(ruleName)) {
    return;
  }

  const params = (0, _postcssValueParser.default)(rule.params);
  params.walk((node, index) => {
    if (node.type === 'div' || node.type === 'function') {
      node.before = node.after = '';

      if (node.type === 'function' && node.nodes[4] && node.nodes[0].value.toLowerCase().indexOf('-aspect-ratio') === 3) {
        const [a, b] = aspectRatio(node.nodes[2].value, node.nodes[4].value);
        node.nodes[2].value = a;
        node.nodes[4].value = b;
      }
    } else if (node.type === 'space') {
      node.value = ' ';
    } else {
      const prevWord = params.nodes[index - 2];

      if (node.value.toLowerCase() === 'all' && rule.name.toLowerCase() === 'media' && !prevWord) {
        const nextWord = params.nodes[index + 2];

        if (!legacy || nextWord) {
          removeNode(node);
        }

        if (nextWord && nextWord.value.toLowerCase() === 'and') {
          const nextSpace = params.nodes[index + 1];
          const secondSpace = params.nodes[index + 3];
          removeNode(nextWord);
          removeNode(nextSpace);
          removeNode(secondSpace);
        }
      }
    }
  }, true);
  rule.params = (0, _alphanumSort.default)((0, _uniqs.default)((0, _cssnanoUtils.getArguments)(params).map(split)), {
    insensitive: true
  }).join();

  if (!rule.params.length) {
    rule.raws.afterName = '';
  }
}

function hasAllBug(browser) {
  return ~['ie 10', 'ie 11'].indexOf(browser);
}

function pluginCreator(options = {}) {
  const browsers = (0, _browserslist.default)(null, {
    stats: options.stats,
    path: __dirname,
    env: options.env
  });
  return {
    postcssPlugin: 'postcss-minify-params',

    OnceExit(css) {
      css.walkAtRules(transform.bind(null, browsers.some(hasAllBug)));
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 86506:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _alphanumSort = _interopRequireDefault(__nccwpck_require__(37910));

var _postcssSelectorParser = _interopRequireDefault(__nccwpck_require__(32997));

var _canUnquote = _interopRequireDefault(__nccwpck_require__(64815));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pseudoElements = ['::before', '::after', '::first-letter', '::first-line'];

function attribute(selector) {
  if (selector.value) {
    if (selector.raws.value) {
      // Join selectors that are split over new lines
      selector.raws.value = selector.raws.value.replace(/\\\n/g, '').trim();
    }

    if ((0, _canUnquote.default)(selector.value)) {
      selector.quoteMark = null;
    }

    if (selector.operator) {
      selector.operator = selector.operator.trim();
    }
  }

  selector.rawSpaceBefore = '';
  selector.rawSpaceAfter = '';
  selector.spaces.attribute = {
    before: '',
    after: ''
  };
  selector.spaces.operator = {
    before: '',
    after: ''
  };
  selector.spaces.value = {
    before: '',
    after: selector.insensitive ? ' ' : ''
  };
  selector.raws.spaces.attribute = {
    before: '',
    after: ''
  };
  selector.raws.spaces.operator = {
    before: '',
    after: ''
  };
  selector.raws.spaces.value = {
    before: '',
    after: selector.insensitive ? ' ' : ''
  };

  if (selector.insensitive) {
    selector.raws.spaces.insensitive = {
      before: '',
      after: ''
    };
  }

  selector.attribute = selector.attribute.trim();
}

function combinator(selector) {
  const value = selector.value.trim();
  selector.spaces.before = '';
  selector.spaces.after = '';
  selector.rawSpaceBefore = '';
  selector.rawsSpaceAfter = '';
  selector.value = value.length ? value : ' ';
}

const pseudoReplacements = {
  ':nth-child': ':first-child',
  ':nth-of-type': ':first-of-type',
  ':nth-last-child': ':last-child',
  ':nth-last-of-type': ':last-of-type'
};

function pseudo(selector) {
  const value = selector.value.toLowerCase();

  if (selector.nodes.length === 1 && pseudoReplacements[value]) {
    const first = selector.at(0);
    const one = first.at(0);

    if (first.length === 1) {
      if (one.value === '1') {
        selector.replaceWith(_postcssSelectorParser.default.pseudo({
          value: pseudoReplacements[value]
        }));
      }

      if (one.value.toLowerCase() === 'even') {
        one.value = '2n';
      }
    }

    if (first.length === 3) {
      const two = first.at(1);
      const three = first.at(2);

      if (one.value.toLowerCase() === '2n' && two.value === '+' && three.value === '1') {
        one.value = 'odd';
        two.remove();
        three.remove();
      }
    }

    return;
  }

  const uniques = [];
  selector.walk(child => {
    if (child.type === 'selector') {
      const childStr = String(child);

      if (!~uniques.indexOf(childStr)) {
        uniques.push(childStr);
      } else {
        child.remove();
      }
    }
  });

  if (~pseudoElements.indexOf(value)) {
    selector.value = selector.value.slice(1);
  }
}

const tagReplacements = {
  from: '0%',
  '100%': 'to'
};

function tag(selector) {
  const value = selector.value.toLowerCase();

  if (Object.prototype.hasOwnProperty.call(tagReplacements, value)) {
    selector.value = tagReplacements[value];
  }
}

function universal(selector) {
  const next = selector.next();

  if (next && next.type !== 'combinator') {
    selector.remove();
  }
}

const reducers = {
  attribute,
  combinator,
  pseudo,
  tag,
  universal
};

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-minify-selectors',

    OnceExit(css) {
      const cache = {};
      const processor = (0, _postcssSelectorParser.default)(selectors => {
        selectors.nodes = (0, _alphanumSort.default)(selectors.nodes, {
          insensitive: true
        });
        const uniqueSelectors = [];
        selectors.walk(sel => {
          const {
            type
          } = sel; // Trim whitespace around the value

          sel.spaces.before = sel.spaces.after = '';

          if (Object.prototype.hasOwnProperty.call(reducers, type)) {
            reducers[type](sel);
            return;
          }

          const toString = String(sel);

          if (type === 'selector' && sel.parent.type !== 'pseudo') {
            if (!~uniqueSelectors.indexOf(toString)) {
              uniqueSelectors.push(toString);
            } else {
              sel.remove();
            }
          }
        });
      });
      css.walkRules(rule => {
        const selector = rule.raws.selector && rule.raws.selector.value === rule.selector ? rule.raws.selector.raw : rule.selector; // If the selector ends with a ':' it is likely a part of a custom mixin,
        // so just pass through.

        if (selector[selector.length - 1] === ':') {
          return;
        }

        if (cache[selector]) {
          rule.selector = cache[selector];
          return;
        }

        const optimizedSelector = processor.processSync(selector);
        rule.selector = optimizedSelector;
        cache[selector] = optimizedSelector;
      });
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 64815:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = canUnquote;

/**
 * Can unquote attribute detection from mothereff.in
 * Copyright Mathias Bynens <https://mathiasbynens.be/>
 * https://github.com/mathiasbynens/mothereff.in
 */
const escapes = /\\([0-9A-Fa-f]{1,6})[ \t\n\f\r]?/g; // eslint-disable-next-line no-control-regex

const range = /[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

function canUnquote(value) {
  if (value === '-' || value === '') {
    return false;
  }

  value = value.replace(escapes, 'a').replace(/\\./g, 'a');
  return !(range.test(value) || /^(?:-?\d|--)/.test(value));
}

module.exports = exports.default;

/***/ }),

/***/ 36738:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
const charset = 'charset'; // eslint-disable-next-line no-control-regex

const nonAscii = /[^\x00-\x7F]/;

function pluginCreator(opts = {}) {
  return {
    postcssPlugin: 'postcss-normalize-' + charset,

    OnceExit(css, {
      AtRule
    }) {
      let charsetRule;
      let nonAsciiNode;
      css.walk(node => {
        if (node.type === 'atrule' && node.name === charset) {
          if (!charsetRule) {
            charsetRule = node;
          }

          node.remove();
        } else if (!nonAsciiNode && node.parent === css && nonAscii.test(node.toString())) {
          nonAsciiNode = node;
        }
      });

      if (nonAsciiNode) {
        if (!charsetRule && opts.add !== false) {
          charsetRule = new AtRule({
            name: charset,
            params: '"utf-8"'
          });
        }

        if (charsetRule) {
          charsetRule.source = nonAsciiNode.source;
          css.prepend(charsetRule);
        }
      }
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 65125:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

var _cssnanoUtils = __nccwpck_require__(96947);

var _map = _interopRequireDefault(__nccwpck_require__(95345));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function transform(value) {
  const {
    nodes
  } = (0, _postcssValueParser.default)(value);

  if (nodes.length === 1) {
    return value;
  }

  const values = nodes.filter((list, index) => index % 2 === 0).filter(node => node.type === 'word').map(n => n.value.toLowerCase());

  if (values.length === 0) {
    return value;
  }

  const match = (0, _cssnanoUtils.getMatch)(_map.default)(values);

  if (!match) {
    return value;
  }

  return match;
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-normalize-display-values',

    prepare() {
      const cache = {};
      return {
        OnceExit(css) {
          css.walkDecls(/^display$/i, decl => {
            const value = decl.value;

            if (!value) {
              return;
            }

            if (cache[value]) {
              decl.value = cache[value];
              return;
            }

            const result = transform(value);
            decl.value = result;
            cache[value] = result;
          });
        }

      };
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 95345:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
const block = 'block';
const flex = 'flex';
const flow = 'flow';
const flowRoot = 'flow-root';
const grid = 'grid';
const inline = 'inline';
const inlineBlock = 'inline-block';
const inlineFlex = 'inline-flex';
const inlineGrid = 'inline-grid';
const inlineTable = 'inline-table';
const listItem = 'list-item';
const ruby = 'ruby';
const rubyBase = 'ruby-base';
const rubyText = 'ruby-text';
const runIn = 'run-in';
const table = 'table';
const tableCell = 'table-cell';
const tableCaption = 'table-caption';
/**
 * Specification: https://drafts.csswg.org/css-display/#the-display-properties
 */

var _default = [[block, [block, flow]], [flowRoot, [block, flowRoot]], [inline, [inline, flow]], [inlineBlock, [inline, flowRoot]], [runIn, [runIn, flow]], [listItem, [listItem, block, flow]], [inline + ' ' + listItem, [inline, flow, listItem]], [flex, [block, flex]], [inlineFlex, [inline, flex]], [grid, [block, grid]], [inlineGrid, [inline, grid]], [ruby, [inline, ruby]], // `block ruby` is same
[table, [block, table]], [inlineTable, [inline, table]], [tableCell, [tableCell, flow]], [tableCaption, [tableCaption, flow]], [rubyBase, [rubyBase, flow]], [rubyText, [rubyText, flow]]];
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 40260:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireWildcard(__nccwpck_require__(19285));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const directionKeywords = ['top', 'right', 'bottom', 'left', 'center'];
const center = '50%';
const horizontal = {
  right: '100%',
  left: '0'
};
const verticalValue = {
  bottom: '100%',
  top: '0'
};

function isCommaNode(node) {
  return node.type === 'div' && node.value === ',';
}

function isVariableFunctionNode(node) {
  if (node.type !== 'function') {
    return false;
  }

  return ['var', 'env'].includes(node.value.toLowerCase());
}

function isMathFunctionNode(node) {
  if (node.type !== 'function') {
    return false;
  }

  return ['calc', 'min', 'max', 'clamp'].includes(node.value.toLowerCase());
}

function isNumberNode(node) {
  if (node.type !== 'word') {
    return false;
  }

  const value = parseFloat(node.value);
  return !isNaN(value);
}

function isDimensionNode(node) {
  if (node.type !== 'word') {
    return false;
  }

  const parsed = (0, _postcssValueParser.unit)(node.value);

  if (!parsed) {
    return false;
  }

  return parsed.unit !== '';
}

function transform(value) {
  const parsed = (0, _postcssValueParser.default)(value);
  const ranges = [];
  let rangeIndex = 0;
  let shouldContinue = true;
  parsed.nodes.forEach((node, index) => {
    // After comma (`,`) follows next background
    if (isCommaNode(node)) {
      rangeIndex += 1;
      shouldContinue = true;
      return;
    }

    if (!shouldContinue) {
      return;
    } // After separator (`/`) follows `background-size` values
    // Avoid them


    if (node.type === 'div' && node.value === '/') {
      shouldContinue = false;
      return;
    }

    if (!ranges[rangeIndex]) {
      ranges[rangeIndex] = {
        start: null,
        end: null
      };
    } // Do not try to be processed `var and `env` function inside background


    if (isVariableFunctionNode(node)) {
      shouldContinue = false;
      ranges[rangeIndex].start = null;
      ranges[rangeIndex].end = null;
      return;
    }

    const isPositionKeyword = node.type === 'word' && directionKeywords.includes(node.value.toLowerCase()) || isDimensionNode(node) || isNumberNode(node) || isMathFunctionNode(node);

    if (ranges[rangeIndex].start === null && isPositionKeyword) {
      ranges[rangeIndex].start = index;
      ranges[rangeIndex].end = index;
      return;
    }

    if (ranges[rangeIndex].start !== null) {
      if (node.type === 'space') {
        return;
      } else if (isPositionKeyword) {
        ranges[rangeIndex].end = index;
        return;
      }

      return;
    }
  });
  ranges.forEach(range => {
    if (range.start === null) {
      return;
    }

    const nodes = parsed.nodes.slice(range.start, range.end + 1);

    if (nodes.length > 3) {
      return;
    }

    const firstNode = nodes[0].value.toLowerCase();
    const secondNode = nodes[2] && nodes[2].value ? nodes[2].value.toLowerCase() : null;

    if (nodes.length === 1 || secondNode === 'center') {
      if (secondNode) {
        nodes[2].value = nodes[1].value = '';
      }

      const map = Object.assign({}, horizontal, {
        center
      });

      if (Object.prototype.hasOwnProperty.call(map, firstNode)) {
        nodes[0].value = map[firstNode];
      }

      return;
    }

    if (firstNode === 'center' && directionKeywords.includes(secondNode)) {
      nodes[0].value = nodes[1].value = '';

      if (Object.prototype.hasOwnProperty.call(horizontal, secondNode)) {
        nodes[2].value = horizontal[secondNode];
      }

      return;
    }

    if (Object.prototype.hasOwnProperty.call(horizontal, firstNode) && Object.prototype.hasOwnProperty.call(verticalValue, secondNode)) {
      nodes[0].value = horizontal[firstNode];
      nodes[2].value = verticalValue[secondNode];
      return;
    } else if (Object.prototype.hasOwnProperty.call(verticalValue, firstNode) && Object.prototype.hasOwnProperty.call(horizontal, secondNode)) {
      nodes[0].value = horizontal[secondNode];
      nodes[2].value = verticalValue[firstNode];
      return;
    }
  });
  return parsed.toString();
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-normalize-positions',

    OnceExit(css) {
      const cache = {};
      css.walkDecls(/^(background(-position)?|(-\w+-)?perspective-origin)$/i, decl => {
        const value = decl.value;

        if (!value) {
          return;
        }

        if (cache[value]) {
          decl.value = cache[value];
          return;
        }

        const result = transform(value);
        decl.value = result;
        cache[value] = result;
      });
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 18073:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

var _cssnanoUtils = __nccwpck_require__(96947);

var _map = _interopRequireDefault(__nccwpck_require__(23952));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function evenValues(list, index) {
  return index % 2 === 0;
}

const repeatKeywords = _map.default.map(mapping => mapping[0]);

const getMatch = (0, _cssnanoUtils.getMatch)(_map.default);

function isCommaNode(node) {
  return node.type === 'div' && node.value === ',';
}

function isVariableFunctionNode(node) {
  if (node.type !== 'function') {
    return false;
  }

  return ['var', 'env'].includes(node.value.toLowerCase());
}

function transform(value) {
  const parsed = (0, _postcssValueParser.default)(value);

  if (parsed.nodes.length === 1) {
    return value;
  }

  const ranges = [];
  let rangeIndex = 0;
  let shouldContinue = true;
  parsed.nodes.forEach((node, index) => {
    // After comma (`,`) follows next background
    if (isCommaNode(node)) {
      rangeIndex += 1;
      shouldContinue = true;
      return;
    }

    if (!shouldContinue) {
      return;
    } // After separator (`/`) follows `background-size` values
    // Avoid them


    if (node.type === 'div' && node.value === '/') {
      shouldContinue = false;
      return;
    }

    if (!ranges[rangeIndex]) {
      ranges[rangeIndex] = {
        start: null,
        end: null
      };
    } // Do not try to be processed `var and `env` function inside background


    if (isVariableFunctionNode(node)) {
      shouldContinue = false;
      ranges[rangeIndex].start = null;
      ranges[rangeIndex].end = null;
      return;
    }

    const isRepeatKeyword = node.type === 'word' && repeatKeywords.includes(node.value.toLowerCase());

    if (ranges[rangeIndex].start === null && isRepeatKeyword) {
      ranges[rangeIndex].start = index;
      ranges[rangeIndex].end = index;
      return;
    }

    if (ranges[rangeIndex].start !== null) {
      if (node.type === 'space') {
        return;
      } else if (isRepeatKeyword) {
        ranges[rangeIndex].end = index;
        return;
      }

      return;
    }
  });
  ranges.forEach(range => {
    if (range.start === null) {
      return;
    }

    const nodes = parsed.nodes.slice(range.start, range.end + 1);

    if (nodes.length !== 3) {
      return;
    }

    const match = getMatch(nodes.filter(evenValues).map(n => n.value.toLowerCase()));

    if (match) {
      nodes[0].value = match;
      nodes[1].value = nodes[2].value = '';
    }
  });
  return parsed.toString();
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-normalize-repeat-style',

    prepare() {
      const cache = {};
      return {
        OnceExit(css) {
          css.walkDecls(/^(background(-repeat)?|(-\w+-)?mask-repeat)$/i, decl => {
            const value = decl.value;

            if (!value) {
              return;
            }

            if (cache[value]) {
              decl.value = cache[value];
              return;
            }

            const result = transform(value);
            decl.value = result;
            cache[value] = result;
          });
        }

      };
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 23952:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;
var _default = [['repeat-x', ['repeat', 'no-repeat']], ['repeat-y', ['no-repeat', 'repeat']], ['repeat', ['repeat', 'repeat']], ['space', ['space', 'space']], ['round', ['round', 'round']], ['no-repeat', ['no-repeat', 'no-repeat']]];
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 56031:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Constants (parser usage)
 */
const SINGLE_QUOTE = "'".charCodeAt(0);
const DOUBLE_QUOTE = '"'.charCodeAt(0);
const BACKSLASH = '\\'.charCodeAt(0);
const NEWLINE = '\n'.charCodeAt(0);
const SPACE = ' '.charCodeAt(0);
const FEED = '\f'.charCodeAt(0);
const TAB = '\t'.charCodeAt(0);
const CR = '\r'.charCodeAt(0);
const WORD_END = /[ \n\t\r\f'"\\]/g;
/*
 * Constants (node type strings)
 */

const C_STRING = 'string';
const C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';
const C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';
const C_SINGLE_QUOTE = 'singleQuote';
const C_DOUBLE_QUOTE = 'doubleQuote';
const C_NEWLINE = 'newline';
const C_SINGLE = 'single';
/*
 * Literals
 */

const L_SINGLE_QUOTE = `'`;
const L_DOUBLE_QUOTE = `"`;
const L_NEWLINE = `\\\n`;
/*
 * Parser nodes
 */

const T_ESCAPED_SINGLE_QUOTE = {
  type: C_ESCAPED_SINGLE_QUOTE,
  value: `\\'`
};
const T_ESCAPED_DOUBLE_QUOTE = {
  type: C_ESCAPED_DOUBLE_QUOTE,
  value: `\\"`
};
const T_SINGLE_QUOTE = {
  type: C_SINGLE_QUOTE,
  value: L_SINGLE_QUOTE
};
const T_DOUBLE_QUOTE = {
  type: C_DOUBLE_QUOTE,
  value: L_DOUBLE_QUOTE
};
const T_NEWLINE = {
  type: C_NEWLINE,
  value: L_NEWLINE
};

function stringify(ast) {
  return ast.nodes.reduce((str, {
    value
  }) => {
    // Collapse multiple line strings automatically
    if (value === L_NEWLINE) {
      return str;
    }

    return str + value;
  }, '');
}

function parse(str) {
  let code, next, value;
  let pos = 0;
  let len = str.length;
  const ast = {
    nodes: [],
    types: {
      escapedSingleQuote: 0,
      escapedDoubleQuote: 0,
      singleQuote: 0,
      doubleQuote: 0
    },
    quotes: false
  };

  while (pos < len) {
    code = str.charCodeAt(pos);

    switch (code) {
      case SPACE:
      case TAB:
      case CR:
      case FEED:
        next = pos;

        do {
          next += 1;
          code = str.charCodeAt(next);
        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);

        ast.nodes.push({
          type: 'space',
          value: str.slice(pos, next)
        });
        pos = next - 1;
        break;

      case SINGLE_QUOTE:
        ast.nodes.push(T_SINGLE_QUOTE);
        ast.types[C_SINGLE_QUOTE]++;
        ast.quotes = true;
        break;

      case DOUBLE_QUOTE:
        ast.nodes.push(T_DOUBLE_QUOTE);
        ast.types[C_DOUBLE_QUOTE]++;
        ast.quotes = true;
        break;

      case BACKSLASH:
        next = pos + 1;

        if (str.charCodeAt(next) === SINGLE_QUOTE) {
          ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);
          ast.types[C_ESCAPED_SINGLE_QUOTE]++;
          ast.quotes = true;
          pos = next;
          break;
        } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {
          ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);
          ast.types[C_ESCAPED_DOUBLE_QUOTE]++;
          ast.quotes = true;
          pos = next;
          break;
        } else if (str.charCodeAt(next) === NEWLINE) {
          ast.nodes.push(T_NEWLINE);
          pos = next;
          break;
        }

      /*
       * We need to fall through here to handle the token as
       * a whole word. The missing 'break' is intentional.
       */

      default:
        WORD_END.lastIndex = pos + 1;
        WORD_END.test(str);

        if (WORD_END.lastIndex === 0) {
          next = len - 1;
        } else {
          next = WORD_END.lastIndex - 2;
        }

        value = str.slice(pos, next + 1);
        ast.nodes.push({
          type: C_STRING,
          value
        });
        pos = next;
    }

    pos++;
  }

  return ast;
}

function changeWrappingQuotes(node, ast) {
  const {
    types
  } = ast;

  if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {
    return;
  }

  if (node.quote === L_SINGLE_QUOTE && types[C_ESCAPED_SINGLE_QUOTE] > 0 && !types[C_ESCAPED_DOUBLE_QUOTE]) {
    node.quote = L_DOUBLE_QUOTE;
  }

  if (node.quote === L_DOUBLE_QUOTE && types[C_ESCAPED_DOUBLE_QUOTE] > 0 && !types[C_ESCAPED_SINGLE_QUOTE]) {
    node.quote = L_SINGLE_QUOTE;
  }

  ast.nodes = ast.nodes.reduce((newAst, child) => {
    if (child.type === C_ESCAPED_DOUBLE_QUOTE && node.quote === L_SINGLE_QUOTE) {
      return [...newAst, T_DOUBLE_QUOTE];
    }

    if (child.type === C_ESCAPED_SINGLE_QUOTE && node.quote === L_DOUBLE_QUOTE) {
      return [...newAst, T_SINGLE_QUOTE];
    }

    return [...newAst, child];
  }, []);
}

function normalize(value, preferredQuote) {
  if (!value || !value.length) {
    return value;
  }

  return (0, _postcssValueParser.default)(value).walk(child => {
    if (child.type !== C_STRING) {
      return;
    }

    const ast = parse(child.value);

    if (ast.quotes) {
      changeWrappingQuotes(child, ast);
    } else if (preferredQuote === C_SINGLE) {
      child.quote = L_SINGLE_QUOTE;
    } else {
      child.quote = L_DOUBLE_QUOTE;
    }

    child.value = stringify(ast);
  }).toString();
}

const params = {
  rule: 'selector',
  decl: 'value',
  atrule: 'params'
};

function pluginCreator(opts) {
  const {
    preferredQuote
  } = Object.assign({}, {
    preferredQuote: 'double'
  }, opts);
  return {
    postcssPlugin: 'postcss-normalize-string',

    OnceExit(css) {
      const cache = {};
      css.walk(node => {
        const {
          type
        } = node;

        if (Object.prototype.hasOwnProperty.call(params, type)) {
          const param = params[type];
          const key = node[param] + '|' + preferredQuote;

          if (cache[key]) {
            node[param] = cache[key];
            return;
          }

          const newValue = normalize(node[param], preferredQuote);
          node[param] = newValue;
          cache[key] = newValue;
        }
      });
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 72513:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

var _cssnanoUtils = __nccwpck_require__(96947);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getValue = node => parseFloat(node.value);

function reduce(node) {
  if (node.type !== 'function') {
    return false;
  }

  if (!node.value) {
    return;
  }

  const lowerCasedValue = node.value.toLowerCase();

  if (lowerCasedValue === 'steps') {
    // Don't bother checking the step-end case as it has the same length
    // as steps(1)
    if (node.nodes[0].type === 'word' && getValue(node.nodes[0]) === 1 && node.nodes[2] && node.nodes[2].type === 'word' && (node.nodes[2].value.toLowerCase() === 'start' || node.nodes[2].value.toLowerCase() === 'jump-start')) {
      node.type = 'word';
      node.value = 'step-start';
      delete node.nodes;
      return;
    }

    if (node.nodes[0].type === 'word' && getValue(node.nodes[0]) === 1 && node.nodes[2] && node.nodes[2].type === 'word' && (node.nodes[2].value.toLowerCase() === 'end' || node.nodes[2].value.toLowerCase() === 'jump-end')) {
      node.type = 'word';
      node.value = 'step-end';
      delete node.nodes;
      return;
    } // The end case is actually the browser default, so it isn't required.


    if (node.nodes[2] && node.nodes[2].type === 'word' && (node.nodes[2].value.toLowerCase() === 'end' || node.nodes[2].value.toLowerCase() === 'jump-end')) {
      node.nodes = [node.nodes[0]];
      return;
    }

    return false;
  }

  if (lowerCasedValue === 'cubic-bezier') {
    const values = node.nodes.filter((list, index) => {
      return index % 2 === 0;
    }).map(getValue);

    if (values.length !== 4) {
      return;
    }

    const match = (0, _cssnanoUtils.getMatch)([['ease', [0.25, 0.1, 0.25, 1]], ['linear', [0, 0, 1, 1]], ['ease-in', [0.42, 0, 1, 1]], ['ease-out', [0, 0, 0.58, 1]], ['ease-in-out', [0.42, 0, 0.58, 1]]])(values);

    if (match) {
      node.type = 'word';
      node.value = match;
      delete node.nodes;
      return;
    }
  }
}

function transform(value) {
  return (0, _postcssValueParser.default)(value).walk(reduce).toString();
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-normalize-timing-functions',

    OnceExit(css) {
      const cache = {};
      css.walkDecls(/^(-\w+-)?(animation|transition)(-timing-function)?$/i, decl => {
        const value = decl.value;

        if (cache[value]) {
          decl.value = cache[value];
          return;
        }

        const result = transform(value);
        decl.value = result;
        cache[value] = result;
      });
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 88249:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _browserslist = _interopRequireDefault(__nccwpck_require__(55478));

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const regexLowerCaseUPrefix = /^u(?=\+)/;

function unicode(range) {
  const values = range.slice(2).split('-');

  if (values.length < 2) {
    return range;
  }

  const left = values[0].split('');
  const right = values[1].split('');

  if (left.length !== right.length) {
    return range;
  }

  let questionCounter = 0;
  const merged = left.reduce((group, value, index) => {
    if (group === false) {
      return false;
    }

    if (value === right[index] && !questionCounter) {
      return group + value;
    }

    if (value === '0' && right[index] === 'f') {
      questionCounter++;
      return group + '?';
    }

    return false;
  }, 'u+'); // The maximum number of wildcard characters (?) for ranges is 5.

  if (merged && questionCounter < 6) {
    return merged;
  }

  return range;
}
/*
 * IE and Edge before 16 version ignore the unicode-range if the 'U' is lowercase
 *
 * https://caniuse.com/#search=unicode-range
 */


function hasLowerCaseUPrefixBug(browser) {
  return ~(0, _browserslist.default)('ie <=11, edge <= 15').indexOf(browser);
}

function transform(value, isLegacy = false) {
  return (0, _postcssValueParser.default)(value).walk(child => {
    if (child.type === 'unicode-range') {
      const transformed = unicode(child.value.toLowerCase());
      child.value = isLegacy ? transformed.replace(regexLowerCaseUPrefix, 'U') : transformed;
    }

    return false;
  }).toString();
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-normalize-unicode',

    prepare(result) {
      const cache = {};
      const resultOpts = result.opts || {};
      const browsers = (0, _browserslist.default)(null, {
        stats: resultOpts.stats,
        path: __dirname,
        env: resultOpts.env
      });
      const isLegacy = browsers.some(hasLowerCaseUPrefixBug);
      return {
        OnceExit(css) {
          css.walkDecls(/^unicode-range$/i, decl => {
            const value = decl.value;

            if (cache[value]) {
              decl.value = cache[value];
              return;
            }

            const newValue = transform(value, isLegacy);
            decl.value = newValue;
            cache[value] = newValue;
          });
        }

      };
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 5791:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _path = _interopRequireDefault(__nccwpck_require__(85622));

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

var _normalizeUrl = _interopRequireDefault(__nccwpck_require__(17952));

var _isAbsoluteUrl = _interopRequireDefault(__nccwpck_require__(34064));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const multiline = /\\[\r\n]/; // eslint-disable-next-line no-useless-escape

const escapeChars = /([\s\(\)"'])/g;

function convert(url, options) {
  if ((0, _isAbsoluteUrl.default)(url) || url.startsWith('//')) {
    let normalizedURL = null;

    try {
      normalizedURL = (0, _normalizeUrl.default)(url, options);
    } catch (e) {
      normalizedURL = url;
    }

    return normalizedURL;
  } // `path.normalize` always returns backslashes on Windows, need replace in `/`


  return _path.default.normalize(url).replace(new RegExp('\\' + _path.default.sep, 'g'), '/');
}

function transformNamespace(rule) {
  rule.params = (0, _postcssValueParser.default)(rule.params).walk(node => {
    if (node.type === 'function' && node.value.toLowerCase() === 'url' && node.nodes.length) {
      node.type = 'string';
      node.quote = node.nodes[0].quote || '"';
      node.value = node.nodes[0].value;
    }

    if (node.type === 'string') {
      node.value = node.value.trim();
    }

    return false;
  }).toString();
}

function transformDecl(decl, opts) {
  decl.value = (0, _postcssValueParser.default)(decl.value).walk(node => {
    if (node.type !== 'function' || node.value.toLowerCase() !== 'url') {
      return false;
    }

    node.before = node.after = '';

    if (!node.nodes.length) {
      return false;
    }

    let url = node.nodes[0];
    let escaped;
    url.value = url.value.trim().replace(multiline, ''); // Skip empty URLs
    // Empty URL function equals request to current stylesheet where it is declared

    if (url.value.length === 0) {
      url.quote = '';
      return false;
    }

    if (/^data:(.*)?,/i.test(url.value)) {
      return false;
    }

    if (!/^.+-extension:\//i.test(url.value)) {
      url.value = convert(url.value, opts);
    }

    if (escapeChars.test(url.value) && url.type === 'string') {
      escaped = url.value.replace(escapeChars, '\\$1');

      if (escaped.length < url.value.length + 2) {
        url.value = escaped;
        url.type = 'word';
      }
    } else {
      url.type = 'word';
    }

    return false;
  }).toString();
}

function pluginCreator(opts) {
  opts = Object.assign({}, {
    normalizeProtocol: false,
    stripHash: false,
    stripWWW: false,
    stripTextFragment: false
  }, opts);
  return {
    postcssPlugin: 'postcss-normalize-url',

    OnceExit(css) {
      css.walk(node => {
        if (node.type === 'decl') {
          return transformDecl(node, opts);
        } else if (node.type === 'atrule' && node.name.toLowerCase() === 'namespace') {
          return transformNamespace(node);
        }
      });
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 82053:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const atrule = 'atrule';
const decl = 'decl';
const rule = 'rule';

function reduceCalcWhitespaces(node) {
  if (node.type === 'space') {
    node.value = ' ';
  } else if (node.type === 'function') {
    if (!['var', 'env', 'constant'].includes(node.value.toLowerCase())) {
      node.before = node.after = '';
    }
  }
}

function reduceWhitespaces(node) {
  if (node.type === 'space') {
    node.value = ' ';
  } else if (node.type === 'div') {
    node.before = node.after = '';
  } else if (node.type === 'function') {
    if (!['var', 'env', 'constant'].includes(node.value.toLowerCase())) {
      node.before = node.after = '';
    }

    if (node.value.toLowerCase() === 'calc') {
      _postcssValueParser.default.walk(node.nodes, reduceCalcWhitespaces);

      return false;
    }
  }
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-normalize-whitespace',

    OnceExit(css) {
      const cache = {};
      css.walk(node => {
        const {
          type
        } = node;

        if (~[decl, rule, atrule].indexOf(type) && node.raws.before) {
          node.raws.before = node.raws.before.replace(/\s/g, '');
        }

        if (type === decl) {
          // Ensure that !important values do not have any excess whitespace
          if (node.important) {
            node.raws.important = '!important';
          } // Remove whitespaces around ie 9 hack


          node.value = node.value.replace(/\s*(\\9)\s*/, '$1');
          const value = node.value;

          if (cache[value]) {
            node.value = cache[value];
          } else {
            const parsed = (0, _postcssValueParser.default)(node.value);
            const result = parsed.walk(reduceWhitespaces).toString(); // Trim whitespace inside functions & dividers

            node.value = result;
            cache[value] = result;
          } // Remove extra semicolons and whitespace before the declaration


          if (node.raws.before) {
            const prev = node.prev();

            if (prev && prev.type !== rule) {
              node.raws.before = node.raws.before.replace(/;/g, '');
            }
          }

          node.raws.between = ':';
          node.raws.semicolon = false;
        } else if (type === rule || type === atrule) {
          node.raws.between = node.raws.after = '';
          node.raws.semicolon = false;
        }
      }); // Remove final newline

      css.raws.after = '';
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 40933:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

var _animation = _interopRequireDefault(__nccwpck_require__(18489));

var _border = _interopRequireDefault(__nccwpck_require__(28282));

var _boxShadow = _interopRequireDefault(__nccwpck_require__(23861));

var _flexFlow = _interopRequireDefault(__nccwpck_require__(67690));

var _transition = _interopRequireDefault(__nccwpck_require__(92439));

var _grid = __nccwpck_require__(10740);

var _listStyle = _interopRequireDefault(__nccwpck_require__(92693));

var _columns = __nccwpck_require__(83010);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// rules
const borderRules = {
  border: _border.default,
  'border-block': _border.default,
  'border-inline': _border.default,
  'border-block-end': _border.default,
  'border-block-start': _border.default,
  'border-inline-end': _border.default,
  'border-inline-start': _border.default,
  'border-top': _border.default,
  'border-right': _border.default,
  'border-bottom': _border.default,
  'border-left': _border.default
};
const grid = {
  'grid-auto-flow': _grid.normalizeGridAutoFlow,
  'grid-column-gap': _grid.normalizeGridColumnRowGap,
  // normal | <length-percentage>
  'grid-row-gap': _grid.normalizeGridColumnRowGap,
  // normal | <length-percentage>
  'grid-column': _grid.normalizeGridColumnRow,
  // <grid-line>+
  'grid-row': _grid.normalizeGridColumnRow,
  // <grid-line>+
  'grid-row-start': _grid.normalizeGridColumnRow,
  // <grid-line>
  'grid-row-end': _grid.normalizeGridColumnRow,
  // <grid-line>
  'grid-column-start': _grid.normalizeGridColumnRow,
  // <grid-line>
  'grid-column-end': _grid.normalizeGridColumnRow // <grid-line>

};
const columnRules = {
  'column-rule': _columns.columnsRule,
  columns: _columns.column
};
const rules = {
  animation: _animation.default,
  outline: _border.default,
  'box-shadow': _boxShadow.default,
  'flex-flow': _flexFlow.default,
  'list-style': _listStyle.default,
  transition: _transition.default,
  ...borderRules,
  ...grid,
  ...columnRules
};

function vendorUnprefixed(prop) {
  return prop.replace(/^-\w+-/, '');
}

function isVariableFunctionNode(node) {
  if (node.type !== 'function') {
    return false;
  }

  return ['var', 'env'].includes(node.value.toLowerCase());
}

function shouldAbort(parsed) {
  let abort = false;
  parsed.walk(node => {
    if (node.type === 'comment' || isVariableFunctionNode(node) || node.type === 'word' && ~node.value.indexOf(`___CSS_LOADER_IMPORT___`)) {
      abort = true;
      return false;
    }
  });
  return abort;
}

function getValue(decl) {
  let {
    value,
    raws
  } = decl;

  if (raws && raws.value && raws.value.raw) {
    value = raws.value.raw;
  }

  return value;
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-ordered-values',

    prepare() {
      const cache = {};
      return {
        OnceExit(css) {
          css.walkDecls(decl => {
            const lowerCasedProp = decl.prop.toLowerCase();
            const normalizedProp = vendorUnprefixed(lowerCasedProp);
            const processor = rules[normalizedProp];

            if (!processor) {
              return;
            }

            const value = getValue(decl);

            if (cache[value]) {
              decl.value = cache[value];
              return;
            }

            const parsed = (0, _postcssValueParser.default)(value);

            if (parsed.nodes.length < 2 || shouldAbort(parsed)) {
              cache[value] = value;
              return;
            }

            const result = processor(parsed);
            decl.value = result.toString();
            cache[value] = result.toString();
          });
        }

      };
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 37541:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = addSpace;

function addSpace() {
  return {
    type: 'space',
    value: ' '
  };
}

module.exports = exports.default;

/***/ }),

/***/ 23117:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = getValue;

var _postcssValueParser = __nccwpck_require__(19285);

function getValue(values) {
  return (0, _postcssValueParser.stringify)({
    nodes: values.reduce((nodes, arg, index) => {
      arg.forEach((val, idx) => {
        if (idx === arg.length - 1 && index === values.length - 1 && val.type === 'space') {
          return;
        }

        nodes.push(val);
      });

      if (index !== values.length - 1) {
        nodes[nodes.length - 1].type = 'div';
        nodes[nodes.length - 1].value = ',';
      }

      return nodes;
    }, [])
  });
}

module.exports = exports.default;

/***/ }),

/***/ 99819:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = joinGridVal;

function joinGridVal(grid) {
  return grid.join(' / ').trim();
}

module.exports = exports.default;

/***/ }),

/***/ 18489:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = normalizeAnimation;

var _postcssValueParser = __nccwpck_require__(19285);

var _cssnanoUtils = __nccwpck_require__(96947);

var _addSpace = _interopRequireDefault(__nccwpck_require__(37541));

var _getValue = _interopRequireDefault(__nccwpck_require__(23117));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// animation: [ none | <keyframes-name> ] || <time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state>
const isTimingFunction = (value, type) => {
  const functions = ['steps', 'cubic-bezier', 'frames'];
  const keywords = ['ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-end', 'step-start'];
  return type === 'function' && functions.includes(value) || keywords.includes(value);
};

const isDirection = value => {
  return ['normal', 'reverse', 'alternate', 'alternate-reverse'].includes(value);
};

const isFillMode = value => {
  return ['none', 'forwards', 'backwards', 'both'].includes(value);
};

const isPlayState = value => {
  return ['running', 'paused'].includes(value);
};

const isTime = value => {
  const quantity = (0, _postcssValueParser.unit)(value);
  return quantity && ['ms', 's'].includes(quantity.unit);
};

const isIterationCount = value => {
  const quantity = (0, _postcssValueParser.unit)(value);
  return value === 'infinite' || quantity && !quantity.unit;
};

function normalizeAnimation(parsed) {
  const args = (0, _cssnanoUtils.getArguments)(parsed);
  const values = args.reduce((list, arg) => {
    const state = {
      name: [],
      duration: [],
      timingFunction: [],
      delay: [],
      iterationCount: [],
      direction: [],
      fillMode: [],
      playState: []
    };
    const stateConditions = [{
      property: 'duration',
      delegate: isTime
    }, {
      property: 'timingFunction',
      delegate: isTimingFunction
    }, {
      property: 'delay',
      delegate: isTime
    }, {
      property: 'iterationCount',
      delegate: isIterationCount
    }, {
      property: 'direction',
      delegate: isDirection
    }, {
      property: 'fillMode',
      delegate: isFillMode
    }, {
      property: 'playState',
      delegate: isPlayState
    }];
    arg.forEach(node => {
      let {
        type,
        value
      } = node;

      if (type === 'space') {
        return;
      }

      value = value.toLowerCase();
      const hasMatch = stateConditions.some(({
        property,
        delegate
      }) => {
        if (delegate(value, type) && !state[property].length) {
          state[property] = [node, (0, _addSpace.default)()];
          return true;
        }
      });

      if (!hasMatch) {
        state.name = [...state.name, node, (0, _addSpace.default)()];
      }
    });
    return [...list, [...state.name, ...state.duration, ...state.timingFunction, ...state.delay, ...state.iterationCount, ...state.direction, ...state.fillMode, ...state.playState]];
  }, []);
  return (0, _getValue.default)(values);
}

module.exports = exports.default;

/***/ }),

/***/ 28282:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = normalizeBorder;

var _postcssValueParser = __nccwpck_require__(19285);

// border: <line-width> || <line-style> || <color>
// outline: <outline-color> || <outline-style> || <outline-width>
const borderWidths = ['thin', 'medium', 'thick'];
const borderStyles = ['none', 'auto', // only in outline-style
'hidden', 'dotted', 'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset'];

function normalizeBorder(border) {
  const order = {
    width: '',
    style: '',
    color: ''
  };
  border.walk(node => {
    const {
      type,
      value
    } = node;

    if (type === 'word') {
      if (~borderStyles.indexOf(value.toLowerCase())) {
        order.style = value;
        return false;
      }

      if (~borderWidths.indexOf(value.toLowerCase()) || (0, _postcssValueParser.unit)(value.toLowerCase())) {
        if (order.width !== '') {
          order.width = `${order.width} ${value}`;
          return false;
        }

        order.width = value;
        return false;
      }

      order.color = value;
      return false;
    }

    if (type === 'function') {
      if (value.toLowerCase() === 'calc') {
        order.width = (0, _postcssValueParser.stringify)(node);
      } else {
        order.color = (0, _postcssValueParser.stringify)(node);
      }

      return false;
    }
  });
  return `${order.width} ${order.style} ${order.color}`.trim();
}

module.exports = exports.default;

/***/ }),

/***/ 23861:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = normalizeBoxShadow;

var _postcssValueParser = __nccwpck_require__(19285);

var _cssnanoUtils = __nccwpck_require__(96947);

var _addSpace = _interopRequireDefault(__nccwpck_require__(37541));

var _getValue = _interopRequireDefault(__nccwpck_require__(23117));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// box-shadow: inset? && <length>{2,4} && <color>?
function normalizeBoxShadow(parsed) {
  let args = (0, _cssnanoUtils.getArguments)(parsed);
  let abort = false;
  let values = args.reduce((list, arg) => {
    let val = [];
    let state = {
      inset: [],
      color: []
    };
    arg.forEach(node => {
      const {
        type,
        value
      } = node;

      if (type === 'function' && ~value.toLowerCase().indexOf('calc')) {
        abort = true;
        return;
      }

      if (type === 'space') {
        return;
      }

      if ((0, _postcssValueParser.unit)(value)) {
        val = [...val, node, (0, _addSpace.default)()];
      } else if (value.toLowerCase() === 'inset') {
        state.inset = [...state.inset, node, (0, _addSpace.default)()];
      } else {
        state.color = [...state.color, node, (0, _addSpace.default)()];
      }
    });
    return [...list, [...state.inset, ...val, ...state.color]];
  }, []);

  if (abort) {
    return parsed.toString();
  }

  return (0, _getValue.default)(values);
}

module.exports = exports.default;

/***/ }),

/***/ 83010:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.columnsRule = exports.column = void 0;

var _postcssValueParser = __nccwpck_require__(19285);

var _border = _interopRequireDefault(__nccwpck_require__(28282));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hasUnit(value) {
  const parsedVal = (0, _postcssValueParser.unit)(value);
  return parsedVal && parsedVal.unit !== '';
}

const column = columns => {
  const widths = [];
  const other = [];
  columns.walk(node => {
    const {
      type,
      value
    } = node;

    if (type === 'word') {
      if (hasUnit(value)) {
        widths.push(value);
      } else {
        other.push(value);
      }
    }
  }); // only transform if declaration is not invalid or a single value

  if (other.length === 1 && widths.length === 1) {
    return `${widths[0].trimStart()} ${other[0].trimStart()}`;
  }

  return columns;
};

exports.column = column;
const columnsRule = _border.default;
exports.columnsRule = columnsRule;

/***/ }),

/***/ 67690:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = normalizeFlexFlow;
// flex-flow: <flex-direction> || <flex-wrap>
const flexDirection = ['row', 'row-reverse', 'column', 'column-reverse'];
const flexWrap = ['nowrap', 'wrap', 'wrap-reverse'];

function normalizeFlexFlow(flexFlow) {
  let order = {
    direction: '',
    wrap: ''
  };
  flexFlow.walk(({
    value
  }) => {
    if (~flexDirection.indexOf(value.toLowerCase())) {
      order.direction = value;
      return;
    }

    if (~flexWrap.indexOf(value.toLowerCase())) {
      order.wrap = value;
      return;
    }
  });
  return `${order.direction} ${order.wrap}`.trim();
}

module.exports = exports.default;

/***/ }),

/***/ 10740:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.normalizeGridColumnRow = exports.normalizeGridColumnRowGap = exports.normalizeGridAutoFlow = void 0;

var _joinGridValue = _interopRequireDefault(__nccwpck_require__(99819));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const normalizeGridAutoFlow = gridAutoFlow => {
  let newValue = {
    front: '',
    back: ''
  };
  let shouldNormalize = false;
  gridAutoFlow.walk(node => {
    if (node.value === 'dense') {
      shouldNormalize = true;
      newValue.back = node.value;
    } else if (['row', 'column'].includes(node.value.trim().toLowerCase())) {
      shouldNormalize = true;
      newValue.front = node.value;
    } else {
      shouldNormalize = false;
    }
  });

  if (shouldNormalize) {
    return `${newValue.front.trim()} ${newValue.back.trim()}`;
  }

  return gridAutoFlow;
};

exports.normalizeGridAutoFlow = normalizeGridAutoFlow;

const normalizeGridColumnRowGap = gridGap => {
  let newValue = {
    front: '',
    back: ''
  };
  let shouldNormalize = false;
  gridGap.walk(node => {
    // console.log(node);
    if (node.value === 'normal') {
      shouldNormalize = true;
      newValue.front = node.value;
    } else {
      newValue.back = `${newValue.back} ${node.value}`;
    }
  });

  if (shouldNormalize) {
    return `${newValue.front.trim()} ${newValue.back.trim()}`;
  }

  return gridGap;
};

exports.normalizeGridColumnRowGap = normalizeGridColumnRowGap;

const normalizeGridColumnRow = grid => {
  // cant do normalization here using node, so copy it as a string
  let gridValue = grid.toString().split('/'); // node -> string value, split ->  " 2 / 3 span " ->  [' 2','3 span ']

  if (gridValue.length > 1) {
    return (0, _joinGridValue.default)(gridValue.map(gridLine => {
      let normalizeValue = {
        front: '',
        back: ''
      };
      gridLine = gridLine.trim(); // '3 span ' -> '3 span'

      gridLine.split(' ').forEach(node => {
        // ['3','span']
        if (node === 'span') {
          normalizeValue.front = node; // span _
        } else {
          normalizeValue.back = `${normalizeValue.back} ${node}`; // _ 3
        }
      });
      return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`; // span 3
    }) // returns "2 / span 3"
    );
  } // doing this separating if `/` is not present as while joining('/') , it will add `/` at the end


  return gridValue.map(gridLine => {
    let normalizeValue = {
      front: '',
      back: ''
    };
    gridLine = gridLine.trim();
    gridLine.split(' ').forEach(node => {
      if (node === 'span') {
        normalizeValue.front = node;
      } else {
        normalizeValue.back = `${normalizeValue.back} ${node}`;
      }
    });
    return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`;
  });
};

exports.normalizeGridColumnRow = normalizeGridColumnRow;

/***/ }),

/***/ 92693:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = listStyleNormalizer;

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

var _listStyleTypes = _interopRequireDefault(__nccwpck_require__(1185));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const definedTypes = _listStyleTypes.default['list-style-type'];
const definedPosition = ['inside', 'outside'];

function listStyleNormalizer(listStyle) {
  const order = {
    type: '',
    position: '',
    image: ''
  };
  listStyle.walk(decl => {
    if (decl.type === 'word') {
      if (definedTypes.includes(decl.value)) {
        // its a type field
        order.type = `${order.type} ${decl.value}`;
      } else if (definedPosition.includes(decl.value)) {
        order.position = `${order.position} ${decl.value}`;
      } else if (decl.value === 'none') {
        if (order.type.split(' ').filter(e => e !== '' && e !== ' ').includes('none')) {
          order.image = `${order.image} ${decl.value}`;
        } else {
          order.type = `${order.type} ${decl.value}`;
        }
      } else {
        order.type = `${order.type} ${decl.value}`;
      }
    }

    if (decl.type === 'function') {
      order.image = `${order.image} ${_postcssValueParser.default.stringify(decl)}`;
    }
  });
  return `${order.type.trim()} ${order.position.trim()} ${order.image.trim()}`.trim();
}

module.exports = exports.default;

/***/ }),

/***/ 92439:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = normalizeTransition;

var _postcssValueParser = __nccwpck_require__(19285);

var _cssnanoUtils = __nccwpck_require__(96947);

var _addSpace = _interopRequireDefault(__nccwpck_require__(37541));

var _getValue = _interopRequireDefault(__nccwpck_require__(23117));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// transition: [ none | <single-transition-property> ] || <time> || <single-transition-timing-function> || <time>
const timingFunctions = ['ease', 'linear', 'ease-in', 'ease-out', 'ease-in-out', 'step-start', 'step-end'];

function normalizeTransition(parsed) {
  let args = (0, _cssnanoUtils.getArguments)(parsed);
  let values = args.reduce((list, arg) => {
    let state = {
      timingFunction: [],
      property: [],
      time1: [],
      time2: []
    };
    arg.forEach(node => {
      const {
        type,
        value
      } = node;

      if (type === 'space') {
        return;
      }

      if (type === 'function' && ~['steps', 'cubic-bezier'].indexOf(value.toLowerCase())) {
        state.timingFunction = [...state.timingFunction, node, (0, _addSpace.default)()];
      } else if ((0, _postcssValueParser.unit)(value)) {
        if (!state.time1.length) {
          state.time1 = [...state.time1, node, (0, _addSpace.default)()];
        } else {
          state.time2 = [...state.time2, node, (0, _addSpace.default)()];
        }
      } else if (~timingFunctions.indexOf(value.toLowerCase())) {
        state.timingFunction = [...state.timingFunction, node, (0, _addSpace.default)()];
      } else {
        state.property = [...state.property, node, (0, _addSpace.default)()];
      }
    });
    return [...list, [...state.property, ...state.time1, ...state.timingFunction, ...state.time2]];
  }, []);
  return (0, _getValue.default)(values);
}

module.exports = exports.default;

/***/ }),

/***/ 85512:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _browserslist = _interopRequireDefault(__nccwpck_require__(55478));

var _caniuseApi = __nccwpck_require__(78390);

var _fromInitial = _interopRequireDefault(__nccwpck_require__(37995));

var _toInitial = _interopRequireDefault(__nccwpck_require__(46080));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const initial = 'initial'; // In most of the browser including chrome the initial for `writing-mode` is not `horizontal-tb`. Ref https://github.com/cssnano/cssnano/pull/905

const defaultIgnoreProps = ['writing-mode'];

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-reduce-initial',

    prepare(result) {
      const resultOpts = result.opts || {};
      const browsers = (0, _browserslist.default)(null, {
        stats: resultOpts.stats,
        path: __dirname,
        env: resultOpts.env
      });
      const initialSupport = (0, _caniuseApi.isSupported)('css-initial-value', browsers);
      return {
        OnceExit(css) {
          css.walkDecls(decl => {
            const lowerCasedProp = decl.prop.toLowerCase();
            const ignoreProp = defaultIgnoreProps.concat(resultOpts.ignore || []);

            if (ignoreProp.includes(lowerCasedProp)) {
              return;
            }

            if (initialSupport && Object.prototype.hasOwnProperty.call(_toInitial.default, lowerCasedProp) && decl.value.toLowerCase() === _toInitial.default[lowerCasedProp]) {
              decl.value = initial;
              return;
            }

            if (decl.value.toLowerCase() !== initial || !_fromInitial.default[lowerCasedProp]) {
              return;
            }

            decl.value = _fromInitial.default[lowerCasedProp];
          });
        }

      };
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 76245:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireWildcard(__nccwpck_require__(19285));

var _cssnanoUtils = __nccwpck_require__(96947);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function getValues(list, node, index) {
  if (index % 2 === 0) {
    let value = NaN;

    if (node.type === 'function' && (node.value === 'var' || node.value === 'env') && node.nodes.length === 1) {
      value = (0, _postcssValueParser.stringify)(node.nodes);
    } else if (node.type === 'word') {
      value = parseFloat(node.value);
    }

    return [...list, value];
  }

  return list;
}

function matrix3d(node, values) {
  if (values.length !== 16) {
    return;
  } // matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) => matrix(a, b, c, d, tx, ty)


  if (values[15] && values[2] === 0 && values[3] === 0 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[14] === 0 && values[15] === 1) {
    const {
      nodes
    } = node;
    node.value = 'matrix';
    node.nodes = [nodes[0], // a
    nodes[1], // ,
    nodes[2], // b
    nodes[3], // ,
    nodes[8], // c
    nodes[9], // ,
    nodes[10], // d
    nodes[11], // ,
    nodes[24], // tx
    nodes[25], // ,
    nodes[26] // ty
    ];
  }
}

const rotate3dMappings = [['rotateX', [1, 0, 0]], // rotate3d(1, 0, 0, a) => rotateX(a)
['rotateY', [0, 1, 0]], // rotate3d(0, 1, 0, a) => rotateY(a)
['rotate', [0, 0, 1]] // rotate3d(0, 0, 1, a) => rotate(a)
];
const rotate3dMatch = (0, _cssnanoUtils.getMatch)(rotate3dMappings);

function rotate3d(node, values) {
  if (values.length !== 4) {
    return;
  }

  const {
    nodes
  } = node;
  const match = rotate3dMatch(values.slice(0, 3));

  if (match.length) {
    node.value = match;
    node.nodes = [nodes[6]];
  }
}

function rotateZ(node, values) {
  if (values.length !== 1) {
    return;
  } // rotateZ(rz) => rotate(rz)


  node.value = 'rotate';
}

function scale(node, values) {
  if (values.length !== 2) {
    return;
  }

  const {
    nodes
  } = node;
  const [first, second] = values; // scale(sx, sy) => scale(sx)

  if (first === second) {
    node.nodes = [nodes[0]];
    return;
  } // scale(sx, 1) => scaleX(sx)


  if (second === 1) {
    node.value = 'scaleX';
    node.nodes = [nodes[0]];
    return;
  } // scale(1, sy) => scaleY(sy)


  if (first === 1) {
    node.value = 'scaleY';
    node.nodes = [nodes[2]];
    return;
  }
}

function scale3d(node, values) {
  if (values.length !== 3) {
    return;
  }

  const {
    nodes
  } = node;
  const [first, second, third] = values; // scale3d(sx, 1, 1) => scaleX(sx)

  if (second === 1 && third === 1) {
    node.value = 'scaleX';
    node.nodes = [nodes[0]];
    return;
  } // scale3d(1, sy, 1) => scaleY(sy)


  if (first === 1 && third === 1) {
    node.value = 'scaleY';
    node.nodes = [nodes[2]];
    return;
  } // scale3d(1, 1, sz) => scaleZ(sz)


  if (first === 1 && second === 1) {
    node.value = 'scaleZ';
    node.nodes = [nodes[4]];
    return;
  }
}

function translate(node, values) {
  if (values.length !== 2) {
    return;
  }

  const {
    nodes
  } = node; // translate(tx, 0) => translate(tx)

  if (values[1] === 0) {
    node.nodes = [nodes[0]];
    return;
  } // translate(0, ty) => translateY(ty)


  if (values[0] === 0) {
    node.value = 'translateY';
    node.nodes = [nodes[2]];
    return;
  }
}

function translate3d(node, values) {
  if (values.length !== 3) {
    return;
  }

  const {
    nodes
  } = node; // translate3d(0, 0, tz) => translateZ(tz)

  if (values[0] === 0 && values[1] === 0) {
    node.value = 'translateZ';
    node.nodes = [nodes[4]];
  }
}

const reducers = {
  matrix3d,
  rotate3d,
  rotateZ,
  scale,
  scale3d,
  translate,
  translate3d
};

function normalizeReducerName(name) {
  const lowerCasedName = name.toLowerCase();

  if (lowerCasedName === 'rotatez') {
    return 'rotateZ';
  }

  return lowerCasedName;
}

function reduce(node) {
  const {
    nodes,
    type,
    value
  } = node;
  const normalizedReducerName = normalizeReducerName(value);

  if (type === 'function' && Object.prototype.hasOwnProperty.call(reducers, normalizedReducerName)) {
    reducers[normalizedReducerName](node, nodes.reduce(getValues, []));
  }

  return false;
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-reduce-transforms',

    prepare() {
      const cache = {};
      return {
        OnceExit(css) {
          css.walkDecls(/transform$/i, decl => {
            const value = decl.value;

            if (!value) {
              return;
            }

            if (cache[value]) {
              decl.value = cache[value];
              return;
            }

            const result = (0, _postcssValueParser.default)(value).walk(reduce).toString();
            decl.value = result;
            cache[value] = result;
          });
        }

      };
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 32997:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _processor = _interopRequireDefault(__nccwpck_require__(10390));

var selectors = _interopRequireWildcard(__nccwpck_require__(31483));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var parser = function parser(processor) {
  return new _processor["default"](processor);
};

Object.assign(parser, selectors);
delete parser.__esModule;
var _default = parser;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 68526:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _root = _interopRequireDefault(__nccwpck_require__(74804));

var _selector = _interopRequireDefault(__nccwpck_require__(97370));

var _className = _interopRequireDefault(__nccwpck_require__(9780));

var _comment = _interopRequireDefault(__nccwpck_require__(90974));

var _id = _interopRequireDefault(__nccwpck_require__(12050));

var _tag = _interopRequireDefault(__nccwpck_require__(99646));

var _string = _interopRequireDefault(__nccwpck_require__(62391));

var _pseudo = _interopRequireDefault(__nccwpck_require__(28681));

var _attribute = _interopRequireWildcard(__nccwpck_require__(49914));

var _universal = _interopRequireDefault(__nccwpck_require__(14843));

var _combinator = _interopRequireDefault(__nccwpck_require__(8765));

var _nesting = _interopRequireDefault(__nccwpck_require__(52821));

var _sortAscending = _interopRequireDefault(__nccwpck_require__(18520));

var _tokenize = _interopRequireWildcard(__nccwpck_require__(53370));

var tokens = _interopRequireWildcard(__nccwpck_require__(26684));

var types = _interopRequireWildcard(__nccwpck_require__(86895));

var _util = __nccwpck_require__(73621);

var _WHITESPACE_TOKENS, _Object$assign;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));

function tokenStart(token) {
  return {
    line: token[_tokenize.FIELDS.START_LINE],
    column: token[_tokenize.FIELDS.START_COL]
  };
}

function tokenEnd(token) {
  return {
    line: token[_tokenize.FIELDS.END_LINE],
    column: token[_tokenize.FIELDS.END_COL]
  };
}

function getSource(startLine, startColumn, endLine, endColumn) {
  return {
    start: {
      line: startLine,
      column: startColumn
    },
    end: {
      line: endLine,
      column: endColumn
    }
  };
}

function getTokenSource(token) {
  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
}

function getTokenSourceSpan(startToken, endToken) {
  if (!startToken) {
    return undefined;
  }

  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
}

function unescapeProp(node, prop) {
  var value = node[prop];

  if (typeof value !== "string") {
    return;
  }

  if (value.indexOf("\\") !== -1) {
    (0, _util.ensureObject)(node, 'raws');
    node[prop] = (0, _util.unesc)(value);

    if (node.raws[prop] === undefined) {
      node.raws[prop] = value;
    }
  }

  return node;
}

function indexesOf(array, item) {
  var i = -1;
  var indexes = [];

  while ((i = array.indexOf(item, i + 1)) !== -1) {
    indexes.push(i);
  }

  return indexes;
}

function uniqs() {
  var list = Array.prototype.concat.apply([], arguments);
  return list.filter(function (item, i) {
    return i === list.indexOf(item);
  });
}

var Parser = /*#__PURE__*/function () {
  function Parser(rule, options) {
    if (options === void 0) {
      options = {};
    }

    this.rule = rule;
    this.options = Object.assign({
      lossy: false,
      safe: false
    }, options);
    this.position = 0;
    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
    this.tokens = (0, _tokenize["default"])({
      css: this.css,
      error: this._errorGenerator(),
      safe: this.options.safe
    });
    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
    this.root = new _root["default"]({
      source: rootSource
    });
    this.root.errorGenerator = this._errorGenerator();
    var selector = new _selector["default"]({
      source: {
        start: {
          line: 1,
          column: 1
        }
      }
    });
    this.root.append(selector);
    this.current = selector;
    this.loop();
  }

  var _proto = Parser.prototype;

  _proto._errorGenerator = function _errorGenerator() {
    var _this = this;

    return function (message, errorOptions) {
      if (typeof _this.rule === 'string') {
        return new Error(message);
      }

      return _this.rule.error(message, errorOptions);
    };
  };

  _proto.attribute = function attribute() {
    var attr = [];
    var startingToken = this.currToken;
    this.position++;

    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      attr.push(this.currToken);
      this.position++;
    }

    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
    }

    var len = attr.length;
    var node = {
      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
    };

    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
    }

    var pos = 0;
    var spaceBefore = '';
    var commentBefore = '';
    var lastAdded = null;
    var spaceAfterMeaningfulToken = false;

    while (pos < len) {
      var token = attr[pos];
      var content = this.content(token);
      var next = attr[pos + 1];

      switch (token[_tokenize.FIELDS.TYPE]) {
        case tokens.space:
          // if (
          //     len === 1 ||
          //     pos === 0 && this.content(next) === '|'
          // ) {
          //     return this.expected('attribute', token[TOKEN.START_POS], content);
          // }
          spaceAfterMeaningfulToken = true;

          if (this.options.lossy) {
            break;
          }

          if (lastAdded) {
            (0, _util.ensureObject)(node, 'spaces', lastAdded);
            var prevContent = node.spaces[lastAdded].after || '';
            node.spaces[lastAdded].after = prevContent + content;
            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;

            if (existingComment) {
              node.raws.spaces[lastAdded].after = existingComment + content;
            }
          } else {
            spaceBefore = spaceBefore + content;
            commentBefore = commentBefore + content;
          }

          break;

        case tokens.asterisk:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }

            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = spaceBefore;
              commentBefore = '';
            }

            node.namespace = (node.namespace || "") + content;
            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;

            if (rawValue) {
              node.raws.namespace += content;
            }

            lastAdded = 'namespace';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.dollar:
          if (lastAdded === "value") {
            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
            node.value += "$";

            if (oldRawValue) {
              node.raws.value = oldRawValue + "$";
            }

            break;
          }

        // Falls through

        case tokens.caret:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.combinator:
          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          if (content !== '|') {
            spaceAfterMeaningfulToken = false;
            break;
          }

          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if (!node.namespace && !node.attribute) {
            node.namespace = true;
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.word:
          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
          !node.operator && !node.namespace) {
            node.namespace = content;
            lastAdded = 'namespace';
          } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }

            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = commentBefore;
              commentBefore = '';
            }

            node.attribute = (node.attribute || "") + content;

            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;

            if (_rawValue) {
              node.raws.attribute += content;
            }

            lastAdded = 'attribute';
          } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
            var _unescaped = (0, _util.unesc)(content);

            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';

            var oldValue = node.value || '';
            node.value = oldValue + _unescaped;
            node.quoteMark = null;

            if (_unescaped !== content || _oldRawValue) {
              (0, _util.ensureObject)(node, 'raws');
              node.raws.value = (_oldRawValue || oldValue) + content;
            }

            lastAdded = 'value';
          } else {
            var insensitive = content === 'i' || content === "I";

            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
              node.insensitive = insensitive;

              if (!insensitive || content === "I") {
                (0, _util.ensureObject)(node, 'raws');
                node.raws.insensitiveFlag = content;
              }

              lastAdded = 'insensitive';

              if (spaceBefore) {
                (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                node.spaces.insensitive.before = spaceBefore;
                spaceBefore = '';
              }

              if (commentBefore) {
                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                node.raws.spaces.insensitive.before = commentBefore;
                commentBefore = '';
              }
            } else if (node.value || node.value === '') {
              lastAdded = 'value';
              node.value += content;

              if (node.raws.value) {
                node.raws.value += content;
              }
            }
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.str:
          if (!node.attribute || !node.operator) {
            return this.error("Expected an attribute followed by an operator preceding the string.", {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }

          var _unescapeValue = (0, _attribute.unescapeValue)(content),
              unescaped = _unescapeValue.unescaped,
              quoteMark = _unescapeValue.quoteMark;

          node.value = unescaped;
          node.quoteMark = quoteMark;
          lastAdded = 'value';
          (0, _util.ensureObject)(node, 'raws');
          node.raws.value = content;
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.equals:
          if (!node.attribute) {
            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
          }

          if (node.value) {
            return this.error('Unexpected "=" found; an operator was already defined.', {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }

          node.operator = node.operator ? node.operator + content : content;
          lastAdded = 'operator';
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.comment:
          if (lastAdded) {
            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
              node.raws.spaces[lastAdded].after = rawLastComment + content;
            } else {
              var lastValue = node[lastAdded] || '';
              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
              (0, _util.ensureObject)(node, 'raws');
              node.raws[lastAdded] = rawLastValue + content;
            }
          } else {
            commentBefore = commentBefore + content;
          }

          break;

        default:
          return this.error("Unexpected \"" + content + "\" found.", {
            index: token[_tokenize.FIELDS.START_POS]
          });
      }

      pos++;
    }

    unescapeProp(node, "attribute");
    unescapeProp(node, "namespace");
    this.newNode(new _attribute["default"](node));
    this.position++;
  }
  /**
   * return a node containing meaningless garbage up to (but not including) the specified token position.
   * if the token position is negative, all remaining tokens are consumed.
   *
   * This returns an array containing a single string node if all whitespace,
   * otherwise an array of comment nodes with space before and after.
   *
   * These tokens are not added to the current selector, the caller can add them or use them to amend
   * a previous node's space metadata.
   *
   * In lossy mode, this returns only comments.
   */
  ;

  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
    if (stopPosition < 0) {
      stopPosition = this.tokens.length;
    }

    var startPosition = this.position;
    var nodes = [];
    var space = "";
    var lastComment = undefined;

    do {
      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        if (!this.options.lossy) {
          space += this.content();
        }
      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
        var spaces = {};

        if (space) {
          spaces.before = space;
          space = "";
        }

        lastComment = new _comment["default"]({
          value: this.content(),
          source: getTokenSource(this.currToken),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
          spaces: spaces
        });
        nodes.push(lastComment);
      }
    } while (++this.position < stopPosition);

    if (space) {
      if (lastComment) {
        lastComment.spaces.after = space;
      } else if (!this.options.lossy) {
        var firstToken = this.tokens[startPosition];
        var lastToken = this.tokens[this.position - 1];
        nodes.push(new _string["default"]({
          value: '',
          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
          spaces: {
            before: space,
            after: ''
          }
        }));
      }
    }

    return nodes;
  }
  /**
   * 
   * @param {*} nodes 
   */
  ;

  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
    var _this2 = this;

    if (requiredSpace === void 0) {
      requiredSpace = false;
    }

    var space = "";
    var rawSpace = "";
    nodes.forEach(function (n) {
      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);

      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);

      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
    });

    if (rawSpace === space) {
      rawSpace = undefined;
    }

    var result = {
      space: space,
      rawSpace: rawSpace
    };
    return result;
  };

  _proto.isNamedCombinator = function isNamedCombinator(position) {
    if (position === void 0) {
      position = this.position;
    }

    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
  };

  _proto.namedCombinator = function namedCombinator() {
    if (this.isNamedCombinator()) {
      var nameRaw = this.content(this.tokens[this.position + 1]);
      var name = (0, _util.unesc)(nameRaw).toLowerCase();
      var raws = {};

      if (name !== nameRaw) {
        raws.value = "/" + nameRaw + "/";
      }

      var node = new _combinator["default"]({
        value: "/" + name + "/",
        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
        raws: raws
      });
      this.position = this.position + 3;
      return node;
    } else {
      this.unexpected();
    }
  };

  _proto.combinator = function combinator() {
    var _this3 = this;

    if (this.content() === '|') {
      return this.namespace();
    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.


    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);

    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);

      if (nodes.length > 0) {
        var last = this.current.last;

        if (last) {
          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
              space = _this$convertWhitespa.space,
              rawSpace = _this$convertWhitespa.rawSpace;

          if (rawSpace !== undefined) {
            last.rawSpaceAfter += rawSpace;
          }

          last.spaces.after += space;
        } else {
          nodes.forEach(function (n) {
            return _this3.newNode(n);
          });
        }
      }

      return;
    }

    var firstToken = this.currToken;
    var spaceOrDescendantSelectorNodes = undefined;

    if (nextSigTokenPos > this.position) {
      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
    }

    var node;

    if (this.isNamedCombinator()) {
      node = this.namedCombinator();
    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
      node = new _combinator["default"]({
        value: this.content(),
        source: getTokenSource(this.currToken),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
      });
      this.position++;
    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass
    } else if (!spaceOrDescendantSelectorNodes) {
      this.unexpected();
    }

    if (node) {
      if (spaceOrDescendantSelectorNodes) {
        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
            _space = _this$convertWhitespa2.space,
            _rawSpace = _this$convertWhitespa2.rawSpace;

        node.spaces.before = _space;
        node.rawSpaceBefore = _rawSpace;
      }
    } else {
      // descendant combinator
      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
          _space2 = _this$convertWhitespa3.space,
          _rawSpace2 = _this$convertWhitespa3.rawSpace;

      if (!_rawSpace2) {
        _rawSpace2 = _space2;
      }

      var spaces = {};
      var raws = {
        spaces: {}
      };

      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
        spaces.before = _space2.slice(0, _space2.length - 1);
        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
        spaces.after = _space2.slice(1);
        raws.spaces.after = _rawSpace2.slice(1);
      } else {
        raws.value = _rawSpace2;
      }

      node = new _combinator["default"]({
        value: ' ',
        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
        spaces: spaces,
        raws: raws
      });
    }

    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
      node.spaces.after = this.optionalSpace(this.content());
      this.position++;
    }

    return this.newNode(node);
  };

  _proto.comma = function comma() {
    if (this.position === this.tokens.length - 1) {
      this.root.trailingComma = true;
      this.position++;
      return;
    }

    this.current._inferEndPosition();

    var selector = new _selector["default"]({
      source: {
        start: tokenStart(this.tokens[this.position + 1])
      }
    });
    this.current.parent.append(selector);
    this.current = selector;
    this.position++;
  };

  _proto.comment = function comment() {
    var current = this.currToken;
    this.newNode(new _comment["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.error = function error(message, opts) {
    throw this.root.error(message, opts);
  };

  _proto.missingBackslash = function missingBackslash() {
    return this.error('Expected a backslash preceding the semicolon.', {
      index: this.currToken[_tokenize.FIELDS.START_POS]
    });
  };

  _proto.missingParenthesis = function missingParenthesis() {
    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.missingSquareBracket = function missingSquareBracket() {
    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.unexpected = function unexpected() {
    return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.namespace = function namespace() {
    var before = this.prevToken && this.content(this.prevToken) || true;

    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.position++;
      return this.word(before);
    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
      this.position++;
      return this.universal(before);
    }
  };

  _proto.nesting = function nesting() {
    if (this.nextToken) {
      var nextContent = this.content(this.nextToken);

      if (nextContent === "|") {
        this.position++;
        return;
      }
    }

    var current = this.currToken;
    this.newNode(new _nesting["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.parentheses = function parentheses() {
    var last = this.current.last;
    var unbalanced = 1;
    this.position++;

    if (last && last.type === types.PSEUDO) {
      var selector = new _selector["default"]({
        source: {
          start: tokenStart(this.tokens[this.position - 1])
        }
      });
      var cache = this.current;
      last.append(selector);
      this.current = selector;

      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }

        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }

        if (unbalanced) {
          this.parse();
        } else {
          this.current.source.end = tokenEnd(this.currToken);
          this.current.parent.source.end = tokenEnd(this.currToken);
          this.position++;
        }
      }

      this.current = cache;
    } else {
      // I think this case should be an error. It's used to implement a basic parse of media queries
      // but I don't think it's a good idea.
      var parenStart = this.currToken;
      var parenValue = "(";
      var parenEnd;

      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }

        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }

        parenEnd = this.currToken;
        parenValue += this.parseParenthesisToken(this.currToken);
        this.position++;
      }

      if (last) {
        last.appendToPropertyAndEscape("value", parenValue, parenValue);
      } else {
        this.newNode(new _string["default"]({
          value: parenValue,
          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
        }));
      }
    }

    if (unbalanced) {
      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };

  _proto.pseudo = function pseudo() {
    var _this4 = this;

    var pseudoStr = '';
    var startingToken = this.currToken;

    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
      pseudoStr += this.content();
      this.position++;
    }

    if (!this.currToken) {
      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
    }

    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.splitWord(false, function (first, length) {
        pseudoStr += first;

        _this4.newNode(new _pseudo["default"]({
          value: pseudoStr,
          source: getTokenSourceSpan(startingToken, _this4.currToken),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        }));

        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          _this4.error('Misplaced parenthesis.', {
            index: _this4.nextToken[_tokenize.FIELDS.START_POS]
          });
        }
      });
    } else {
      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };

  _proto.space = function space() {
    var content = this.content(); // Handle space before and after the selector

    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
      return node.type === 'comment';
    })) {
      this.spaces = this.optionalSpace(content);
      this.position++;
    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
      this.current.last.spaces.after = this.optionalSpace(content);
      this.position++;
    } else {
      this.combinator();
    }
  };

  _proto.string = function string() {
    var current = this.currToken;
    this.newNode(new _string["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.universal = function universal(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    var current = this.currToken;
    this.newNode(new _universal["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }), namespace);
    this.position++;
  };

  _proto.splitWord = function splitWord(namespace, firstCallback) {
    var _this5 = this;

    var nextToken = this.nextToken;
    var word = this.content();

    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
      this.position++;
      var current = this.content();
      word += current;

      if (current.lastIndexOf('\\') === current.length - 1) {
        var next = this.nextToken;

        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
          word += this.requiredSpace(this.content(next));
          this.position++;
        }
      }

      nextToken = this.nextToken;
    }

    var hasClass = indexesOf(word, '.').filter(function (i) {
      return word[i - 1] !== '\\';
    });
    var hasId = indexesOf(word, '#').filter(function (i) {
      return word[i - 1] !== '\\';
    }); // Eliminate Sass interpolations from the list of id indexes

    var interpolations = indexesOf(word, '#{');

    if (interpolations.length) {
      hasId = hasId.filter(function (hashIndex) {
        return !~interpolations.indexOf(hashIndex);
      });
    }

    var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
    indices.forEach(function (ind, i) {
      var index = indices[i + 1] || word.length;
      var value = word.slice(ind, index);

      if (i === 0 && firstCallback) {
        return firstCallback.call(_this5, value, indices.length);
      }

      var node;
      var current = _this5.currToken;
      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));

      if (~hasClass.indexOf(ind)) {
        var classNameOpts = {
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        };
        node = new _className["default"](unescapeProp(classNameOpts, "value"));
      } else if (~hasId.indexOf(ind)) {
        var idOpts = {
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        };
        node = new _id["default"](unescapeProp(idOpts, "value"));
      } else {
        var tagOpts = {
          value: value,
          source: source,
          sourceIndex: sourceIndex
        };
        unescapeProp(tagOpts, "value");
        node = new _tag["default"](tagOpts);
      }

      _this5.newNode(node, namespace); // Ensure that the namespace is used only once


      namespace = null;
    });
    this.position++;
  };

  _proto.word = function word(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    return this.splitWord(namespace);
  };

  _proto.loop = function loop() {
    while (this.position < this.tokens.length) {
      this.parse(true);
    }

    this.current._inferEndPosition();

    return this.root;
  };

  _proto.parse = function parse(throwOnParenthesis) {
    switch (this.currToken[_tokenize.FIELDS.TYPE]) {
      case tokens.space:
        this.space();
        break;

      case tokens.comment:
        this.comment();
        break;

      case tokens.openParenthesis:
        this.parentheses();
        break;

      case tokens.closeParenthesis:
        if (throwOnParenthesis) {
          this.missingParenthesis();
        }

        break;

      case tokens.openSquare:
        this.attribute();
        break;

      case tokens.dollar:
      case tokens.caret:
      case tokens.equals:
      case tokens.word:
        this.word();
        break;

      case tokens.colon:
        this.pseudo();
        break;

      case tokens.comma:
        this.comma();
        break;

      case tokens.asterisk:
        this.universal();
        break;

      case tokens.ampersand:
        this.nesting();
        break;

      case tokens.slash:
      case tokens.combinator:
        this.combinator();
        break;

      case tokens.str:
        this.string();
        break;
      // These cases throw; no break needed.

      case tokens.closeSquare:
        this.missingSquareBracket();

      case tokens.semicolon:
        this.missingBackslash();

      default:
        this.unexpected();
    }
  }
  /**
   * Helpers
   */
  ;

  _proto.expected = function expected(description, index, found) {
    if (Array.isArray(description)) {
      var last = description.pop();
      description = description.join(', ') + " or " + last;
    }

    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';

    if (!found) {
      return this.error("Expected " + an + " " + description + ".", {
        index: index
      });
    }

    return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
      index: index
    });
  };

  _proto.requiredSpace = function requiredSpace(space) {
    return this.options.lossy ? ' ' : space;
  };

  _proto.optionalSpace = function optionalSpace(space) {
    return this.options.lossy ? '' : space;
  };

  _proto.lossySpace = function lossySpace(space, required) {
    if (this.options.lossy) {
      return required ? ' ' : '';
    } else {
      return space;
    }
  };

  _proto.parseParenthesisToken = function parseParenthesisToken(token) {
    var content = this.content(token);

    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
      return this.requiredSpace(content);
    } else {
      return content;
    }
  };

  _proto.newNode = function newNode(node, namespace) {
    if (namespace) {
      if (/^ +$/.test(namespace)) {
        if (!this.options.lossy) {
          this.spaces = (this.spaces || '') + namespace;
        }

        namespace = true;
      }

      node.namespace = namespace;
      unescapeProp(node, "namespace");
    }

    if (this.spaces) {
      node.spaces.before = this.spaces;
      this.spaces = '';
    }

    return this.current.append(node);
  };

  _proto.content = function content(token) {
    if (token === void 0) {
      token = this.currToken;
    }

    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
  };

  /**
   * returns the index of the next non-whitespace, non-comment token.
   * returns -1 if no meaningful token is found.
   */
  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
    if (startPosition === void 0) {
      startPosition = this.position + 1;
    }

    var searchPosition = startPosition;

    while (searchPosition < this.tokens.length) {
      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
        searchPosition++;
        continue;
      } else {
        return searchPosition;
      }
    }

    return -1;
  };

  _createClass(Parser, [{
    key: "currToken",
    get: function get() {
      return this.tokens[this.position];
    }
  }, {
    key: "nextToken",
    get: function get() {
      return this.tokens[this.position + 1];
    }
  }, {
    key: "prevToken",
    get: function get() {
      return this.tokens[this.position - 1];
    }
  }]);

  return Parser;
}();

exports.default = Parser;
module.exports = exports.default;

/***/ }),

/***/ 10390:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _parser = _interopRequireDefault(__nccwpck_require__(68526));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Processor = /*#__PURE__*/function () {
  function Processor(func, options) {
    this.func = func || function noop() {};

    this.funcRes = null;
    this.options = options;
  }

  var _proto = Processor.prototype;

  _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var merged = Object.assign({}, this.options, options);

    if (merged.updateSelector === false) {
      return false;
    } else {
      return typeof rule !== "string";
    }
  };

  _proto._isLossy = function _isLossy(options) {
    if (options === void 0) {
      options = {};
    }

    var merged = Object.assign({}, this.options, options);

    if (merged.lossless === false) {
      return true;
    } else {
      return false;
    }
  };

  _proto._root = function _root(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var parser = new _parser["default"](rule, this._parseOptions(options));
    return parser.root;
  };

  _proto._parseOptions = function _parseOptions(options) {
    return {
      lossy: this._isLossy(options)
    };
  };

  _proto._run = function _run(rule, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    return new Promise(function (resolve, reject) {
      try {
        var root = _this._root(rule, options);

        Promise.resolve(_this.func(root)).then(function (transform) {
          var string = undefined;

          if (_this._shouldUpdateSelector(rule, options)) {
            string = root.toString();
            rule.selector = string;
          }

          return {
            transform: transform,
            root: root,
            string: string
          };
        }).then(resolve, reject);
      } catch (e) {
        reject(e);
        return;
      }
    });
  };

  _proto._runSync = function _runSync(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var root = this._root(rule, options);

    var transform = this.func(root);

    if (transform && typeof transform.then === "function") {
      throw new Error("Selector processor returned a promise to a synchronous call.");
    }

    var string = undefined;

    if (options.updateSelector && typeof rule !== "string") {
      string = root.toString();
      rule.selector = string;
    }

    return {
      transform: transform,
      root: root,
      string: string
    };
  }
  /**
   * Process rule into a selector AST.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<parser.Root>} The AST of the selector after processing it.
   */
  ;

  _proto.ast = function ast(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.root;
    });
  }
  /**
   * Process rule into a selector AST synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {parser.Root} The AST of the selector after processing it.
   */
  ;

  _proto.astSync = function astSync(rule, options) {
    return this._runSync(rule, options).root;
  }
  /**
   * Process a selector into a transformed value asynchronously
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<any>} The value returned by the processor.
   */
  ;

  _proto.transform = function transform(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.transform;
    });
  }
  /**
   * Process a selector into a transformed value synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {any} The value returned by the processor.
   */
  ;

  _proto.transformSync = function transformSync(rule, options) {
    return this._runSync(rule, options).transform;
  }
  /**
   * Process a selector into a new selector string asynchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */
  ;

  _proto.process = function process(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.string || result.root.toString();
    });
  }
  /**
   * Process a selector into a new selector string synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */
  ;

  _proto.processSync = function processSync(rule, options) {
    var result = this._runSync(rule, options);

    return result.string || result.root.toString();
  };

  return Processor;
}();

exports.default = Processor;
module.exports = exports.default;

/***/ }),

/***/ 49914:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.unescapeValue = unescapeValue;
exports.default = void 0;

var _cssesc = _interopRequireDefault(__nccwpck_require__(63120));

var _unesc = _interopRequireDefault(__nccwpck_require__(2897));

var _namespace = _interopRequireDefault(__nccwpck_require__(65669));

var _types = __nccwpck_require__(86895);

var _CSSESC_QUOTE_OPTIONS;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var deprecate = __nccwpck_require__(65278);

var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

function unescapeValue(value) {
  var deprecatedUsage = false;
  var quoteMark = null;
  var unescaped = value;
  var m = unescaped.match(WRAPPED_IN_QUOTES);

  if (m) {
    quoteMark = m[1];
    unescaped = m[2];
  }

  unescaped = (0, _unesc["default"])(unescaped);

  if (unescaped !== value) {
    deprecatedUsage = true;
  }

  return {
    deprecatedUsage: deprecatedUsage,
    unescaped: unescaped,
    quoteMark: quoteMark
  };
}

function handleDeprecatedContructorOpts(opts) {
  if (opts.quoteMark !== undefined) {
    return opts;
  }

  if (opts.value === undefined) {
    return opts;
  }

  warnOfDeprecatedConstructor();

  var _unescapeValue = unescapeValue(opts.value),
      quoteMark = _unescapeValue.quoteMark,
      unescaped = _unescapeValue.unescaped;

  if (!opts.raws) {
    opts.raws = {};
  }

  if (opts.raws.value === undefined) {
    opts.raws.value = opts.value;
  }

  opts.value = unescaped;
  opts.quoteMark = quoteMark;
  return opts;
}

var Attribute = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Attribute, _Namespace);

  function Attribute(opts) {
    var _this;

    if (opts === void 0) {
      opts = {};
    }

    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
    _this.type = _types.ATTRIBUTE;
    _this.raws = _this.raws || {};
    Object.defineProperty(_this.raws, 'unquoted', {
      get: deprecate(function () {
        return _this.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
      set: deprecate(function () {
        return _this.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
    });
    _this._constructed = true;
    return _this;
  }
  /**
   * Returns the Attribute's value quoted such that it would be legal to use
   * in the value of a css file. The original value's quotation setting
   * used for stringification is left unchanged. See `setValue(value, options)`
   * if you want to control the quote settings of a new value for the attribute.
   *
   * You can also change the quotation used for the current value by setting quoteMark.
   *
   * Options:
   *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
   *     option is not set, the original value for quoteMark will be used. If
   *     indeterminate, a double quote is used. The legal values are:
   *     * `null` - the value will be unquoted and characters will be escaped as necessary.
   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
   *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
   *     over the quoteMark option value.
   *   * smart {boolean} - if true, will select a quote mark based on the value
   *     and the other options specified here. See the `smartQuoteMark()`
   *     method.
   **/


  var _proto = Attribute.prototype;

  _proto.getQuotedValue = function getQuotedValue(options) {
    if (options === void 0) {
      options = {};
    }

    var quoteMark = this._determineQuoteMark(options);

    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
    var escaped = (0, _cssesc["default"])(this._value, cssescopts);
    return escaped;
  };

  _proto._determineQuoteMark = function _determineQuoteMark(options) {
    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
  }
  /**
   * Set the unescaped value with the specified quotation options. The value
   * provided must not include any wrapping quote marks -- those quotes will
   * be interpreted as part of the value and escaped accordingly.
   */
  ;

  _proto.setValue = function setValue(value, options) {
    if (options === void 0) {
      options = {};
    }

    this._value = value;
    this._quoteMark = this._determineQuoteMark(options);

    this._syncRawValue();
  }
  /**
   * Intelligently select a quoteMark value based on the value's contents. If
   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
   * mark will be picked that minimizes the number of escapes.
   *
   * If there's no clear winner, the quote mark from these options is used,
   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
   * true). If the quoteMark is unspecified, a double quote is used.
   *
   * @param options This takes the quoteMark and preferCurrentQuoteMark options
   * from the quoteValue method.
   */
  ;

  _proto.smartQuoteMark = function smartQuoteMark(options) {
    var v = this.value;
    var numSingleQuotes = v.replace(/[^']/g, '').length;
    var numDoubleQuotes = v.replace(/[^"]/g, '').length;

    if (numSingleQuotes + numDoubleQuotes === 0) {
      var escaped = (0, _cssesc["default"])(v, {
        isIdentifier: true
      });

      if (escaped === v) {
        return Attribute.NO_QUOTE;
      } else {
        var pref = this.preferredQuoteMark(options);

        if (pref === Attribute.NO_QUOTE) {
          // pick a quote mark that isn't none and see if it's smaller
          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
          var opts = CSSESC_QUOTE_OPTIONS[quote];
          var quoteValue = (0, _cssesc["default"])(v, opts);

          if (quoteValue.length < escaped.length) {
            return quote;
          }
        }

        return pref;
      }
    } else if (numDoubleQuotes === numSingleQuotes) {
      return this.preferredQuoteMark(options);
    } else if (numDoubleQuotes < numSingleQuotes) {
      return Attribute.DOUBLE_QUOTE;
    } else {
      return Attribute.SINGLE_QUOTE;
    }
  }
  /**
   * Selects the preferred quote mark based on the options and the current quote mark value.
   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
   * instead.
   */
  ;

  _proto.preferredQuoteMark = function preferredQuoteMark(options) {
    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

    if (quoteMark === undefined) {
      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
    }

    if (quoteMark === undefined) {
      quoteMark = Attribute.DOUBLE_QUOTE;
    }

    return quoteMark;
  };

  _proto._syncRawValue = function _syncRawValue() {
    var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);

    if (rawValue === this._value) {
      if (this.raws) {
        delete this.raws.value;
      }
    } else {
      this.raws.value = rawValue;
    }
  };

  _proto._handleEscapes = function _handleEscapes(prop, value) {
    if (this._constructed) {
      var escaped = (0, _cssesc["default"])(value, {
        isIdentifier: true
      });

      if (escaped !== value) {
        this.raws[prop] = escaped;
      } else {
        delete this.raws[prop];
      }
    }
  };

  _proto._spacesFor = function _spacesFor(name) {
    var attrSpaces = {
      before: '',
      after: ''
    };
    var spaces = this.spaces[name] || {};
    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
    return Object.assign(attrSpaces, spaces, rawSpaces);
  };

  _proto._stringFor = function _stringFor(name, spaceName, concat) {
    if (spaceName === void 0) {
      spaceName = name;
    }

    if (concat === void 0) {
      concat = defaultAttrConcat;
    }

    var attrSpaces = this._spacesFor(spaceName);

    return concat(this.stringifyProperty(name), attrSpaces);
  }
  /**
   * returns the offset of the attribute part specified relative to the
   * start of the node of the output string.
   *
   * * "ns" - alias for "namespace"
   * * "namespace" - the namespace if it exists.
   * * "attribute" - the attribute name
   * * "attributeNS" - the start of the attribute or its namespace
   * * "operator" - the match operator of the attribute
   * * "value" - The value (string or identifier)
   * * "insensitive" - the case insensitivity flag;
   * @param part One of the possible values inside an attribute.
   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
   */
  ;

  _proto.offsetOf = function offsetOf(name) {
    var count = 1;

    var attributeSpaces = this._spacesFor("attribute");

    count += attributeSpaces.before.length;

    if (name === "namespace" || name === "ns") {
      return this.namespace ? count : -1;
    }

    if (name === "attributeNS") {
      return count;
    }

    count += this.namespaceString.length;

    if (this.namespace) {
      count += 1;
    }

    if (name === "attribute") {
      return count;
    }

    count += this.stringifyProperty("attribute").length;
    count += attributeSpaces.after.length;

    var operatorSpaces = this._spacesFor("operator");

    count += operatorSpaces.before.length;
    var operator = this.stringifyProperty("operator");

    if (name === "operator") {
      return operator ? count : -1;
    }

    count += operator.length;
    count += operatorSpaces.after.length;

    var valueSpaces = this._spacesFor("value");

    count += valueSpaces.before.length;
    var value = this.stringifyProperty("value");

    if (name === "value") {
      return value ? count : -1;
    }

    count += value.length;
    count += valueSpaces.after.length;

    var insensitiveSpaces = this._spacesFor("insensitive");

    count += insensitiveSpaces.before.length;

    if (name === "insensitive") {
      return this.insensitive ? count : -1;
    }

    return -1;
  };

  _proto.toString = function toString() {
    var _this2 = this;

    var selector = [this.rawSpaceBefore, '['];
    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

    if (this.operator && (this.value || this.value === '')) {
      selector.push(this._stringFor('operator'));
      selector.push(this._stringFor('value'));
      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
          attrSpaces.before = " ";
        }

        return defaultAttrConcat(attrValue, attrSpaces);
      }));
    }

    selector.push(']');
    selector.push(this.rawSpaceAfter);
    return selector.join('');
  };

  _createClass(Attribute, [{
    key: "quoted",
    get: function get() {
      var qm = this.quoteMark;
      return qm === "'" || qm === '"';
    },
    set: function set(value) {
      warnOfDeprecatedQuotedAssignment();
    }
    /**
     * returns a single (`'`) or double (`"`) quote character if the value is quoted.
     * returns `null` if the value is not quoted.
     * returns `undefined` if the quotation state is unknown (this can happen when
     * the attribute is constructed without specifying a quote mark.)
     */

  }, {
    key: "quoteMark",
    get: function get() {
      return this._quoteMark;
    }
    /**
     * Set the quote mark to be used by this attribute's value.
     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
     * value is updated accordingly.
     *
     * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
     */
    ,
    set: function set(quoteMark) {
      if (!this._constructed) {
        this._quoteMark = quoteMark;
        return;
      }

      if (this._quoteMark !== quoteMark) {
        this._quoteMark = quoteMark;

        this._syncRawValue();
      }
    }
  }, {
    key: "qualifiedAttribute",
    get: function get() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    }
  }, {
    key: "insensitiveFlag",
    get: function get() {
      return this.insensitive ? 'i' : '';
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Before 3.0, the value had to be set to an escaped value including any wrapped
     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
     * is unescaped during parsing and any quote marks are removed.
     *
     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
     * a deprecation warning is raised when the new value contains any characters that would
     * require escaping (including if it contains wrapped quotes).
     *
     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
     * how the new value is quoted.
     */
    ,
    set: function set(v) {
      if (this._constructed) {
        var _unescapeValue2 = unescapeValue(v),
            deprecatedUsage = _unescapeValue2.deprecatedUsage,
            unescaped = _unescapeValue2.unescaped,
            quoteMark = _unescapeValue2.quoteMark;

        if (deprecatedUsage) {
          warnOfDeprecatedValueAssignment();
        }

        if (unescaped === this._value && quoteMark === this._quoteMark) {
          return;
        }

        this._value = unescaped;
        this._quoteMark = quoteMark;

        this._syncRawValue();
      } else {
        this._value = v;
      }
    }
  }, {
    key: "attribute",
    get: function get() {
      return this._attribute;
    },
    set: function set(name) {
      this._handleEscapes("attribute", name);

      this._attribute = name;
    }
  }]);

  return Attribute;
}(_namespace["default"]);

exports.default = Attribute;
Attribute.NO_QUOTE = null;
Attribute.SINGLE_QUOTE = "'";
Attribute.DOUBLE_QUOTE = '"';
var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
  "'": {
    quotes: 'single',
    wrap: true
  },
  '"': {
    quotes: 'double',
    wrap: true
  }
}, _CSSESC_QUOTE_OPTIONS[null] = {
  isIdentifier: true
}, _CSSESC_QUOTE_OPTIONS);

function defaultAttrConcat(attrValue, attrSpaces) {
  return "" + attrSpaces.before + attrValue + attrSpaces.after;
}

/***/ }),

/***/ 9780:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _cssesc = _interopRequireDefault(__nccwpck_require__(63120));

var _util = __nccwpck_require__(73621);

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ClassName = /*#__PURE__*/function (_Node) {
  _inheritsLoose(ClassName, _Node);

  function ClassName(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.CLASS;
    _this._constructed = true;
    return _this;
  }

  var _proto = ClassName.prototype;

  _proto.valueToString = function valueToString() {
    return '.' + _Node.prototype.valueToString.call(this);
  };

  _createClass(ClassName, [{
    key: "value",
    get: function get() {
      return this._value;
    },
    set: function set(v) {
      if (this._constructed) {
        var escaped = (0, _cssesc["default"])(v, {
          isIdentifier: true
        });

        if (escaped !== v) {
          (0, _util.ensureObject)(this, "raws");
          this.raws.value = escaped;
        } else if (this.raws) {
          delete this.raws.value;
        }
      }

      this._value = v;
    }
  }]);

  return ClassName;
}(_node["default"]);

exports.default = ClassName;
module.exports = exports.default;

/***/ }),

/***/ 8765:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Combinator = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Combinator, _Node);

  function Combinator(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.COMBINATOR;
    return _this;
  }

  return Combinator;
}(_node["default"]);

exports.default = Combinator;
module.exports = exports.default;

/***/ }),

/***/ 90974:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Comment = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Comment, _Node);

  function Comment(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.COMMENT;
    return _this;
  }

  return Comment;
}(_node["default"]);

exports.default = Comment;
module.exports = exports.default;

/***/ }),

/***/ 55850:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;

var _attribute = _interopRequireDefault(__nccwpck_require__(49914));

var _className = _interopRequireDefault(__nccwpck_require__(9780));

var _combinator = _interopRequireDefault(__nccwpck_require__(8765));

var _comment = _interopRequireDefault(__nccwpck_require__(90974));

var _id = _interopRequireDefault(__nccwpck_require__(12050));

var _nesting = _interopRequireDefault(__nccwpck_require__(52821));

var _pseudo = _interopRequireDefault(__nccwpck_require__(28681));

var _root = _interopRequireDefault(__nccwpck_require__(74804));

var _selector = _interopRequireDefault(__nccwpck_require__(97370));

var _string = _interopRequireDefault(__nccwpck_require__(62391));

var _tag = _interopRequireDefault(__nccwpck_require__(99646));

var _universal = _interopRequireDefault(__nccwpck_require__(14843));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var attribute = function attribute(opts) {
  return new _attribute["default"](opts);
};

exports.attribute = attribute;

var className = function className(opts) {
  return new _className["default"](opts);
};

exports.className = className;

var combinator = function combinator(opts) {
  return new _combinator["default"](opts);
};

exports.combinator = combinator;

var comment = function comment(opts) {
  return new _comment["default"](opts);
};

exports.comment = comment;

var id = function id(opts) {
  return new _id["default"](opts);
};

exports.id = id;

var nesting = function nesting(opts) {
  return new _nesting["default"](opts);
};

exports.nesting = nesting;

var pseudo = function pseudo(opts) {
  return new _pseudo["default"](opts);
};

exports.pseudo = pseudo;

var root = function root(opts) {
  return new _root["default"](opts);
};

exports.root = root;

var selector = function selector(opts) {
  return new _selector["default"](opts);
};

exports.selector = selector;

var string = function string(opts) {
  return new _string["default"](opts);
};

exports.string = string;

var tag = function tag(opts) {
  return new _tag["default"](opts);
};

exports.tag = tag;

var universal = function universal(opts) {
  return new _universal["default"](opts);
};

exports.universal = universal;

/***/ }),

/***/ 37240:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var types = _interopRequireWildcard(__nccwpck_require__(86895));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Container = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Container, _Node);

  function Container(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;

    if (!_this.nodes) {
      _this.nodes = [];
    }

    return _this;
  }

  var _proto = Container.prototype;

  _proto.append = function append(selector) {
    selector.parent = this;
    this.nodes.push(selector);
    return this;
  };

  _proto.prepend = function prepend(selector) {
    selector.parent = this;
    this.nodes.unshift(selector);
    return this;
  };

  _proto.at = function at(index) {
    return this.nodes[index];
  };

  _proto.index = function index(child) {
    if (typeof child === 'number') {
      return child;
    }

    return this.nodes.indexOf(child);
  };

  _proto.removeChild = function removeChild(child) {
    child = this.index(child);
    this.at(child).parent = undefined;
    this.nodes.splice(child, 1);
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }

    return this;
  };

  _proto.removeAll = function removeAll() {
    for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {
      var node = _step.value;
      node.parent = undefined;
    }

    this.nodes = [];
    return this;
  };

  _proto.empty = function empty() {
    return this.removeAll();
  };

  _proto.insertAfter = function insertAfter(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex + 1, 0, newNode);
    newNode.parent = this;
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (oldIndex <= index) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  _proto.insertBefore = function insertBefore(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex, 0, newNode);
    newNode.parent = this;
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index <= oldIndex) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
    var found = undefined;
    this.each(function (node) {
      if (node.atPosition) {
        var foundChild = node.atPosition(line, col);

        if (foundChild) {
          found = foundChild;
          return false;
        }
      } else if (node.isAtPosition(line, col)) {
        found = node;
        return false;
      }
    });
    return found;
  }
  /**
   * Return the most specific node at the line and column number given.
   * The source location is based on the original parsed location, locations aren't
   * updated as selector nodes are mutated.
   * 
   * Note that this location is relative to the location of the first character
   * of the selector, and not the location of the selector in the overall document
   * when used in conjunction with postcss.
   *
   * If not found, returns undefined.
   * @param {number} line The line number of the node to find. (1-based index)
   * @param {number} col  The column number of the node to find. (1-based index)
   */
  ;

  _proto.atPosition = function atPosition(line, col) {
    if (this.isAtPosition(line, col)) {
      return this._findChildAtPosition(line, col) || this;
    } else {
      return undefined;
    }
  };

  _proto._inferEndPosition = function _inferEndPosition() {
    if (this.last && this.last.source && this.last.source.end) {
      this.source = this.source || {};
      this.source.end = this.source.end || {};
      Object.assign(this.source.end, this.last.source.end);
    }
  };

  _proto.each = function each(callback) {
    if (!this.lastEach) {
      this.lastEach = 0;
    }

    if (!this.indexes) {
      this.indexes = {};
    }

    this.lastEach++;
    var id = this.lastEach;
    this.indexes[id] = 0;

    if (!this.length) {
      return undefined;
    }

    var index, result;

    while (this.indexes[id] < this.length) {
      index = this.indexes[id];
      result = callback(this.at(index), index);

      if (result === false) {
        break;
      }

      this.indexes[id] += 1;
    }

    delete this.indexes[id];

    if (result === false) {
      return false;
    }
  };

  _proto.walk = function walk(callback) {
    return this.each(function (node, i) {
      var result = callback(node, i);

      if (result !== false && node.length) {
        result = node.walk(callback);
      }

      if (result === false) {
        return false;
      }
    });
  };

  _proto.walkAttributes = function walkAttributes(callback) {
    var _this2 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ATTRIBUTE) {
        return callback.call(_this2, selector);
      }
    });
  };

  _proto.walkClasses = function walkClasses(callback) {
    var _this3 = this;

    return this.walk(function (selector) {
      if (selector.type === types.CLASS) {
        return callback.call(_this3, selector);
      }
    });
  };

  _proto.walkCombinators = function walkCombinators(callback) {
    var _this4 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMBINATOR) {
        return callback.call(_this4, selector);
      }
    });
  };

  _proto.walkComments = function walkComments(callback) {
    var _this5 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMMENT) {
        return callback.call(_this5, selector);
      }
    });
  };

  _proto.walkIds = function walkIds(callback) {
    var _this6 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ID) {
        return callback.call(_this6, selector);
      }
    });
  };

  _proto.walkNesting = function walkNesting(callback) {
    var _this7 = this;

    return this.walk(function (selector) {
      if (selector.type === types.NESTING) {
        return callback.call(_this7, selector);
      }
    });
  };

  _proto.walkPseudos = function walkPseudos(callback) {
    var _this8 = this;

    return this.walk(function (selector) {
      if (selector.type === types.PSEUDO) {
        return callback.call(_this8, selector);
      }
    });
  };

  _proto.walkTags = function walkTags(callback) {
    var _this9 = this;

    return this.walk(function (selector) {
      if (selector.type === types.TAG) {
        return callback.call(_this9, selector);
      }
    });
  };

  _proto.walkUniversals = function walkUniversals(callback) {
    var _this10 = this;

    return this.walk(function (selector) {
      if (selector.type === types.UNIVERSAL) {
        return callback.call(_this10, selector);
      }
    });
  };

  _proto.split = function split(callback) {
    var _this11 = this;

    var current = [];
    return this.reduce(function (memo, node, index) {
      var split = callback.call(_this11, node);
      current.push(node);

      if (split) {
        memo.push(current);
        current = [];
      } else if (index === _this11.length - 1) {
        memo.push(current);
      }

      return memo;
    }, []);
  };

  _proto.map = function map(callback) {
    return this.nodes.map(callback);
  };

  _proto.reduce = function reduce(callback, memo) {
    return this.nodes.reduce(callback, memo);
  };

  _proto.every = function every(callback) {
    return this.nodes.every(callback);
  };

  _proto.some = function some(callback) {
    return this.nodes.some(callback);
  };

  _proto.filter = function filter(callback) {
    return this.nodes.filter(callback);
  };

  _proto.sort = function sort(callback) {
    return this.nodes.sort(callback);
  };

  _proto.toString = function toString() {
    return this.map(String).join('');
  };

  _createClass(Container, [{
    key: "first",
    get: function get() {
      return this.at(0);
    }
  }, {
    key: "last",
    get: function get() {
      return this.at(this.length - 1);
    }
  }, {
    key: "length",
    get: function get() {
      return this.nodes.length;
    }
  }]);

  return Container;
}(_node["default"]);

exports.default = Container;
module.exports = exports.default;

/***/ }),

/***/ 5873:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.isNode = isNode;
exports.isPseudoElement = isPseudoElement;
exports.isPseudoClass = isPseudoClass;
exports.isContainer = isContainer;
exports.isNamespace = isNamespace;
exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;

var _types = __nccwpck_require__(86895);

var _IS_TYPE;

var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

function isNode(node) {
  return typeof node === "object" && IS_TYPE[node.type];
}

function isNodeType(type, node) {
  return isNode(node) && node.type === type;
}

var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
exports.isAttribute = isAttribute;
var isClassName = isNodeType.bind(null, _types.CLASS);
exports.isClassName = isClassName;
var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
exports.isCombinator = isCombinator;
var isComment = isNodeType.bind(null, _types.COMMENT);
exports.isComment = isComment;
var isIdentifier = isNodeType.bind(null, _types.ID);
exports.isIdentifier = isIdentifier;
var isNesting = isNodeType.bind(null, _types.NESTING);
exports.isNesting = isNesting;
var isPseudo = isNodeType.bind(null, _types.PSEUDO);
exports.isPseudo = isPseudo;
var isRoot = isNodeType.bind(null, _types.ROOT);
exports.isRoot = isRoot;
var isSelector = isNodeType.bind(null, _types.SELECTOR);
exports.isSelector = isSelector;
var isString = isNodeType.bind(null, _types.STRING);
exports.isString = isString;
var isTag = isNodeType.bind(null, _types.TAG);
exports.isTag = isTag;
var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
exports.isUniversal = isUniversal;

function isPseudoElement(node) {
  return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after");
}

function isPseudoClass(node) {
  return isPseudo(node) && !isPseudoElement(node);
}

function isContainer(node) {
  return !!(isNode(node) && node.walk);
}

function isNamespace(node) {
  return isAttribute(node) || isTag(node);
}

/***/ }),

/***/ 12050:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ID = /*#__PURE__*/function (_Node) {
  _inheritsLoose(ID, _Node);

  function ID(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.ID;
    return _this;
  }

  var _proto = ID.prototype;

  _proto.valueToString = function valueToString() {
    return '#' + _Node.prototype.valueToString.call(this);
  };

  return ID;
}(_node["default"]);

exports.default = ID;
module.exports = exports.default;

/***/ }),

/***/ 31483:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;

var _types = __nccwpck_require__(86895);

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _types[key]) return;
  exports[key] = _types[key];
});

var _constructors = __nccwpck_require__(55850);

Object.keys(_constructors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constructors[key]) return;
  exports[key] = _constructors[key];
});

var _guards = __nccwpck_require__(5873);

Object.keys(_guards).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _guards[key]) return;
  exports[key] = _guards[key];
});

/***/ }),

/***/ 65669:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _cssesc = _interopRequireDefault(__nccwpck_require__(63120));

var _util = __nccwpck_require__(73621);

var _node = _interopRequireDefault(__nccwpck_require__(83206));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Namespace = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Namespace, _Node);

  function Namespace() {
    return _Node.apply(this, arguments) || this;
  }

  var _proto = Namespace.prototype;

  _proto.qualifiedName = function qualifiedName(value) {
    if (this.namespace) {
      return this.namespaceString + "|" + value;
    } else {
      return value;
    }
  };

  _proto.valueToString = function valueToString() {
    return this.qualifiedName(_Node.prototype.valueToString.call(this));
  };

  _createClass(Namespace, [{
    key: "namespace",
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      if (namespace === true || namespace === "*" || namespace === "&") {
        this._namespace = namespace;

        if (this.raws) {
          delete this.raws.namespace;
        }

        return;
      }

      var escaped = (0, _cssesc["default"])(namespace, {
        isIdentifier: true
      });
      this._namespace = namespace;

      if (escaped !== namespace) {
        (0, _util.ensureObject)(this, "raws");
        this.raws.namespace = escaped;
      } else if (this.raws) {
        delete this.raws.namespace;
      }
    }
  }, {
    key: "ns",
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      this.namespace = namespace;
    }
  }, {
    key: "namespaceString",
    get: function get() {
      if (this.namespace) {
        var ns = this.stringifyProperty("namespace");

        if (ns === true) {
          return '';
        } else {
          return ns;
        }
      } else {
        return '';
      }
    }
  }]);

  return Namespace;
}(_node["default"]);

exports.default = Namespace;
;
module.exports = exports.default;

/***/ }),

/***/ 52821:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Nesting = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Nesting, _Node);

  function Nesting(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.NESTING;
    _this.value = '&';
    return _this;
  }

  return Nesting;
}(_node["default"]);

exports.default = Nesting;
module.exports = exports.default;

/***/ }),

/***/ 83206:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _util = __nccwpck_require__(73621);

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var cloneNode = function cloneNode(obj, parent) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!obj.hasOwnProperty(i)) {
      continue;
    }

    var value = obj[i];
    var type = typeof value;

    if (i === 'parent' && type === 'object') {
      if (parent) {
        cloned[i] = parent;
      }
    } else if (value instanceof Array) {
      cloned[i] = value.map(function (j) {
        return cloneNode(j, cloned);
      });
    } else {
      cloned[i] = cloneNode(value, cloned);
    }
  }

  return cloned;
};

var Node = /*#__PURE__*/function () {
  function Node(opts) {
    if (opts === void 0) {
      opts = {};
    }

    Object.assign(this, opts);
    this.spaces = this.spaces || {};
    this.spaces.before = this.spaces.before || '';
    this.spaces.after = this.spaces.after || '';
  }

  var _proto = Node.prototype;

  _proto.remove = function remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }

    this.parent = undefined;
    return this;
  };

  _proto.replaceWith = function replaceWith() {
    if (this.parent) {
      for (var index in arguments) {
        this.parent.insertBefore(this, arguments[index]);
      }

      this.remove();
    }

    return this;
  };

  _proto.next = function next() {
    return this.parent.at(this.parent.index(this) + 1);
  };

  _proto.prev = function prev() {
    return this.parent.at(this.parent.index(this) - 1);
  };

  _proto.clone = function clone(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = cloneNode(this);

    for (var name in overrides) {
      cloned[name] = overrides[name];
    }

    return cloned;
  }
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows non standard syntax to be appended to an existing property
   * by specifying the escaped value. By specifying the escaped value,
   * illegal characters are allowed to be directly inserted into css output.
   * @param {string} name the property to set
   * @param {any} value the unescaped value of the property
   * @param {string} valueEscaped optional. the escaped value of the property.
   */
  ;

  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
    if (!this.raws) {
      this.raws = {};
    }

    var originalValue = this[name];
    var originalEscaped = this.raws[name];
    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

    if (originalEscaped || valueEscaped !== value) {
      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
    } else {
      delete this.raws[name]; // delete any escaped value that was created by the setter.
    }
  }
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows the escaped value to be specified directly, allowing illegal
   * characters to be directly inserted into css output.
   * @param {string} name the property to set
   * @param {any} value the unescaped value of the property
   * @param {string} valueEscaped the escaped value of the property.
   */
  ;

  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
    if (!this.raws) {
      this.raws = {};
    }

    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    this.raws[name] = valueEscaped;
  }
  /**
   * When you want a value to passed through to CSS directly. This method
   * deletes the corresponding raw value causing the stringifier to fallback
   * to the unescaped value.
   * @param {string} name the property to set.
   * @param {any} value The value that is both escaped and unescaped.
   */
  ;

  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    if (this.raws) {
      delete this.raws[name];
    }
  }
  /**
   *
   * @param {number} line The number (starting with 1)
   * @param {number} column The column number (starting with 1)
   */
  ;

  _proto.isAtPosition = function isAtPosition(line, column) {
    if (this.source && this.source.start && this.source.end) {
      if (this.source.start.line > line) {
        return false;
      }

      if (this.source.end.line < line) {
        return false;
      }

      if (this.source.start.line === line && this.source.start.column > column) {
        return false;
      }

      if (this.source.end.line === line && this.source.end.column < column) {
        return false;
      }

      return true;
    }

    return undefined;
  };

  _proto.stringifyProperty = function stringifyProperty(name) {
    return this.raws && this.raws[name] || this[name];
  };

  _proto.valueToString = function valueToString() {
    return String(this.stringifyProperty("value"));
  };

  _proto.toString = function toString() {
    return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
  };

  _createClass(Node, [{
    key: "rawSpaceBefore",
    get: function get() {
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

      if (rawSpace === undefined) {
        rawSpace = this.spaces && this.spaces.before;
      }

      return rawSpace || "";
    },
    set: function set(raw) {
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.before = raw;
    }
  }, {
    key: "rawSpaceAfter",
    get: function get() {
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

      if (rawSpace === undefined) {
        rawSpace = this.spaces.after;
      }

      return rawSpace || "";
    },
    set: function set(raw) {
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.after = raw;
    }
  }]);

  return Node;
}();

exports.default = Node;
module.exports = exports.default;

/***/ }),

/***/ 28681:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(__nccwpck_require__(37240));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Pseudo = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Pseudo, _Container);

  function Pseudo(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.PSEUDO;
    return _this;
  }

  var _proto = Pseudo.prototype;

  _proto.toString = function toString() {
    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
    return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
  };

  return Pseudo;
}(_container["default"]);

exports.default = Pseudo;
module.exports = exports.default;

/***/ }),

/***/ 74804:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(__nccwpck_require__(37240));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Root = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Root, _Container);

  function Root(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.ROOT;
    return _this;
  }

  var _proto = Root.prototype;

  _proto.toString = function toString() {
    var str = this.reduce(function (memo, selector) {
      memo.push(String(selector));
      return memo;
    }, []).join(',');
    return this.trailingComma ? str + ',' : str;
  };

  _proto.error = function error(message, options) {
    if (this._error) {
      return this._error(message, options);
    } else {
      return new Error(message);
    }
  };

  _createClass(Root, [{
    key: "errorGenerator",
    set: function set(handler) {
      this._error = handler;
    }
  }]);

  return Root;
}(_container["default"]);

exports.default = Root;
module.exports = exports.default;

/***/ }),

/***/ 97370:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(__nccwpck_require__(37240));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Selector = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Selector, _Container);

  function Selector(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.SELECTOR;
    return _this;
  }

  return Selector;
}(_container["default"]);

exports.default = Selector;
module.exports = exports.default;

/***/ }),

/***/ 62391:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var String = /*#__PURE__*/function (_Node) {
  _inheritsLoose(String, _Node);

  function String(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.STRING;
    return _this;
  }

  return String;
}(_node["default"]);

exports.default = String;
module.exports = exports.default;

/***/ }),

/***/ 99646:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _namespace = _interopRequireDefault(__nccwpck_require__(65669));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Tag = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Tag, _Namespace);

  function Tag(opts) {
    var _this;

    _this = _Namespace.call(this, opts) || this;
    _this.type = _types.TAG;
    return _this;
  }

  return Tag;
}(_namespace["default"]);

exports.default = Tag;
module.exports = exports.default;

/***/ }),

/***/ 86895:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
var TAG = 'tag';
exports.TAG = TAG;
var STRING = 'string';
exports.STRING = STRING;
var SELECTOR = 'selector';
exports.SELECTOR = SELECTOR;
var ROOT = 'root';
exports.ROOT = ROOT;
var PSEUDO = 'pseudo';
exports.PSEUDO = PSEUDO;
var NESTING = 'nesting';
exports.NESTING = NESTING;
var ID = 'id';
exports.ID = ID;
var COMMENT = 'comment';
exports.COMMENT = COMMENT;
var COMBINATOR = 'combinator';
exports.COMBINATOR = COMBINATOR;
var CLASS = 'class';
exports.CLASS = CLASS;
var ATTRIBUTE = 'attribute';
exports.ATTRIBUTE = ATTRIBUTE;
var UNIVERSAL = 'universal';
exports.UNIVERSAL = UNIVERSAL;

/***/ }),

/***/ 14843:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _namespace = _interopRequireDefault(__nccwpck_require__(65669));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Universal = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Universal, _Namespace);

  function Universal(opts) {
    var _this;

    _this = _Namespace.call(this, opts) || this;
    _this.type = _types.UNIVERSAL;
    _this.value = '*';
    return _this;
  }

  return Universal;
}(_namespace["default"]);

exports.default = Universal;
module.exports = exports.default;

/***/ }),

/***/ 18520:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = sortAscending;

function sortAscending(list) {
  return list.sort(function (a, b) {
    return a - b;
  });
}

;
module.exports = exports.default;

/***/ }),

/***/ 26684:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
var ampersand = 38; // `&`.charCodeAt(0);

exports.ampersand = ampersand;
var asterisk = 42; // `*`.charCodeAt(0);

exports.asterisk = asterisk;
var at = 64; // `@`.charCodeAt(0);

exports.at = at;
var comma = 44; // `,`.charCodeAt(0);

exports.comma = comma;
var colon = 58; // `:`.charCodeAt(0);

exports.colon = colon;
var semicolon = 59; // `;`.charCodeAt(0);

exports.semicolon = semicolon;
var openParenthesis = 40; // `(`.charCodeAt(0);

exports.openParenthesis = openParenthesis;
var closeParenthesis = 41; // `)`.charCodeAt(0);

exports.closeParenthesis = closeParenthesis;
var openSquare = 91; // `[`.charCodeAt(0);

exports.openSquare = openSquare;
var closeSquare = 93; // `]`.charCodeAt(0);

exports.closeSquare = closeSquare;
var dollar = 36; // `$`.charCodeAt(0);

exports.dollar = dollar;
var tilde = 126; // `~`.charCodeAt(0);

exports.tilde = tilde;
var caret = 94; // `^`.charCodeAt(0);

exports.caret = caret;
var plus = 43; // `+`.charCodeAt(0);

exports.plus = plus;
var equals = 61; // `=`.charCodeAt(0);

exports.equals = equals;
var pipe = 124; // `|`.charCodeAt(0);

exports.pipe = pipe;
var greaterThan = 62; // `>`.charCodeAt(0);

exports.greaterThan = greaterThan;
var space = 32; // ` `.charCodeAt(0);

exports.space = space;
var singleQuote = 39; // `'`.charCodeAt(0);

exports.singleQuote = singleQuote;
var doubleQuote = 34; // `"`.charCodeAt(0);

exports.doubleQuote = doubleQuote;
var slash = 47; // `/`.charCodeAt(0);

exports.slash = slash;
var bang = 33; // `!`.charCodeAt(0);

exports.bang = bang;
var backslash = 92; // '\\'.charCodeAt(0);

exports.backslash = backslash;
var cr = 13; // '\r'.charCodeAt(0);

exports.cr = cr;
var feed = 12; // '\f'.charCodeAt(0);

exports.feed = feed;
var newline = 10; // '\n'.charCodeAt(0);

exports.newline = newline;
var tab = 9; // '\t'.charCodeAt(0);
// Expose aliases primarily for readability.

exports.tab = tab;
var str = singleQuote; // No good single character representation!

exports.str = str;
var comment = -1;
exports.comment = comment;
var word = -2;
exports.word = word;
var combinator = -3;
exports.combinator = combinator;

/***/ }),

/***/ 53370:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.default = tokenize;
exports.FIELDS = void 0;

var t = _interopRequireWildcard(__nccwpck_require__(26684));

var _unescapable, _wordDelimiters;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
var hex = {};
var hexChars = "0123456789abcdefABCDEF";

for (var i = 0; i < hexChars.length; i++) {
  hex[hexChars.charCodeAt(i)] = true;
}
/**
 *  Returns the last index of the bar css word
 * @param {string} css The string in which the word begins
 * @param {number} start The index into the string where word's first letter occurs
 */


function consumeWord(css, start) {
  var next = start;
  var code;

  do {
    code = css.charCodeAt(next);

    if (wordDelimiters[code]) {
      return next - 1;
    } else if (code === t.backslash) {
      next = consumeEscape(css, next) + 1;
    } else {
      // All other characters are part of the word
      next++;
    }
  } while (next < css.length);

  return next - 1;
}
/**
 *  Returns the last index of the escape sequence
 * @param {string} css The string in which the sequence begins
 * @param {number} start The index into the string where escape character (`\`) occurs.
 */


function consumeEscape(css, start) {
  var next = start;
  var code = css.charCodeAt(next + 1);

  if (unescapable[code]) {// just consume the escape char
  } else if (hex[code]) {
    var hexDigits = 0; // consume up to 6 hex chars

    do {
      next++;
      hexDigits++;
      code = css.charCodeAt(next + 1);
    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape


    if (hexDigits < 6 && code === t.space) {
      next++;
    }
  } else {
    // the next char is part of the current word
    next++;
  }

  return next;
}

var FIELDS = {
  TYPE: 0,
  START_LINE: 1,
  START_COL: 2,
  END_LINE: 3,
  END_COL: 4,
  START_POS: 5,
  END_POS: 6
};
exports.FIELDS = FIELDS;

function tokenize(input) {
  var tokens = [];
  var css = input.css.valueOf();
  var _css = css,
      length = _css.length;
  var offset = -1;
  var line = 1;
  var start = 0;
  var end = 0;
  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;

  function unclosed(what, fix) {
    if (input.safe) {
      // fyi: this is never set to true.
      css += fix;
      next = css.length - 1;
    } else {
      throw input.error('Unclosed ' + what, line, start - offset, start);
    }
  }

  while (start < length) {
    code = css.charCodeAt(start);

    if (code === t.newline) {
      offset = start;
      line += 1;
    }

    switch (code) {
      case t.space:
      case t.tab:
      case t.newline:
      case t.cr:
      case t.feed:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);

          if (code === t.newline) {
            offset = next;
            line += 1;
          }
        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

        tokenType = t.space;
        endLine = line;
        endColumn = next - offset - 1;
        end = next;
        break;

      case t.plus:
      case t.greaterThan:
      case t.tilde:
      case t.pipe:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

        tokenType = t.combinator;
        endLine = line;
        endColumn = start - offset;
        end = next;
        break;
      // Consume these characters as single tokens.

      case t.asterisk:
      case t.ampersand:
      case t.bang:
      case t.comma:
      case t.equals:
      case t.dollar:
      case t.caret:
      case t.openSquare:
      case t.closeSquare:
      case t.colon:
      case t.semicolon:
      case t.openParenthesis:
      case t.closeParenthesis:
        next = start;
        tokenType = code;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      case t.singleQuote:
      case t.doubleQuote:
        quote = code === t.singleQuote ? "'" : '"';
        next = start;

        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);

          if (next === -1) {
            unclosed('quote', quote);
          }

          escapePos = next;

          while (css.charCodeAt(escapePos - 1) === t.backslash) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);

        tokenType = t.str;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      default:
        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
          next = css.indexOf('*/', start + 2) + 1;

          if (next === 0) {
            unclosed('comment', '*/');
          }

          content = css.slice(start, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) {
            nextLine = line + last;
            nextOffset = next - lines[last].length;
          } else {
            nextLine = line;
            nextOffset = offset;
          }

          tokenType = t.comment;
          line = nextLine;
          endLine = nextLine;
          endColumn = next - nextOffset;
        } else if (code === t.slash) {
          next = start;
          tokenType = code;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
        } else {
          next = consumeWord(css, start);
          tokenType = t.word;
          endLine = line;
          endColumn = next - offset;
        }

        end = next + 1;
        break;
    } // Ensure that the token structure remains consistent


    tokens.push([tokenType, // [0] Token type
    line, // [1] Starting line
    start - offset, // [2] Starting column
    endLine, // [3] Ending line
    endColumn, // [4] Ending column
    start, // [5] Start position / Source index
    end // [6] End position
    ]); // Reset offset for the next token

    if (nextOffset) {
      offset = nextOffset;
      nextOffset = null;
    }

    start = end;
  }

  return tokens;
}

/***/ }),

/***/ 23573:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = ensureObject;

function ensureObject(obj) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  while (props.length > 0) {
    var prop = props.shift();

    if (!obj[prop]) {
      obj[prop] = {};
    }

    obj = obj[prop];
  }
}

module.exports = exports.default;

/***/ }),

/***/ 83514:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = getProp;

function getProp(obj) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  while (props.length > 0) {
    var prop = props.shift();

    if (!obj[prop]) {
      return undefined;
    }

    obj = obj[prop];
  }

  return obj;
}

module.exports = exports.default;

/***/ }),

/***/ 73621:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;

var _unesc = _interopRequireDefault(__nccwpck_require__(2897));

exports.unesc = _unesc["default"];

var _getProp = _interopRequireDefault(__nccwpck_require__(83514));

exports.getProp = _getProp["default"];

var _ensureObject = _interopRequireDefault(__nccwpck_require__(23573));

exports.ensureObject = _ensureObject["default"];

var _stripComments = _interopRequireDefault(__nccwpck_require__(37142));

exports.stripComments = _stripComments["default"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/***/ }),

/***/ 37142:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = stripComments;

function stripComments(str) {
  var s = "";
  var commentStart = str.indexOf("/*");
  var lastEnd = 0;

  while (commentStart >= 0) {
    s = s + str.slice(lastEnd, commentStart);
    var commentEnd = str.indexOf("*/", commentStart + 2);

    if (commentEnd < 0) {
      return s;
    }

    lastEnd = commentEnd + 2;
    commentStart = str.indexOf("/*", lastEnd);
  }

  s = s + str.slice(lastEnd);
  return s;
}

module.exports = exports.default;

/***/ }),

/***/ 2897:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = unesc;

// Many thanks for this post which made this migration much easier.
// https://mathiasbynens.be/notes/css-escapes

/**
 * 
 * @param {string} str 
 * @returns {[string, number]|undefined}
 */
function gobbleHex(str) {
  var lower = str.toLowerCase();
  var hex = '';
  var spaceTerminated = false;

  for (var i = 0; i < 6 && lower[i] !== undefined; i++) {
    var code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]

    var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point

    spaceTerminated = code === 32;

    if (!valid) {
      break;
    }

    hex += lower[i];
  }

  if (hex.length === 0) {
    return undefined;
  }

  var codePoint = parseInt(hex, 16);
  var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF; // Add special case for
  // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
  // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point

  if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {
    return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
  }

  return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
}

var CONTAINS_ESCAPE = /\\/;

function unesc(str) {
  var needToProcess = CONTAINS_ESCAPE.test(str);

  if (!needToProcess) {
    return str;
  }

  var ret = "";

  for (var i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      var gobbled = gobbleHex(str.slice(i + 1, i + 7));

      if (gobbled !== undefined) {
        ret += gobbled[0];
        i += gobbled[1];
        continue;
      } // Retain a pair of \\ if double escaped `\\\\`
      // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e


      if (str[i + 1] === "\\") {
        ret += "\\";
        i++;
        continue;
      } // if \\ is at the end of the string retain it
      // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb


      if (str.length === i + 1) {
        ret += str[i];
      }

      continue;
    }

    ret += str[i];
  }

  return ret;
}

module.exports = exports.default;

/***/ }),

/***/ 8762:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _postcssValueParser = _interopRequireDefault(__nccwpck_require__(19285));

var _svgo = __nccwpck_require__(3921);

var _url = __nccwpck_require__(26370);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PLUGIN = 'postcss-svgo';
const dataURI = /data:image\/svg\+xml(;((charset=)?utf-8|base64))?,/i;
const dataURIBase64 = /data:image\/svg\+xml;base64,/i;
/**
 * @param {string} input the SVG string
 * @param {boolean} encode whether to encode the result
 * @return {object} the minification result
 */

function minifySVG(input, opts) {
  let svg = input;
  let decodedUri, isUriEncoded;

  try {
    decodedUri = (0, _url.decode)(input);
    isUriEncoded = decodedUri !== input;
  } catch (e) {
    // Swallow exception if we cannot decode the value
    isUriEncoded = false;
  }

  if (isUriEncoded) {
    svg = decodedUri;
  }

  if (opts.encode !== undefined) {
    isUriEncoded = opts.encode;
  }

  const result = (0, _svgo.optimize)(svg, opts);

  if (result.error) {
    throw new Error(result.error);
  }

  return {
    result: result.data,
    isUriEncoded
  };
}

function minify(decl, opts, postcssResult) {
  const parsed = (0, _postcssValueParser.default)(decl.value);
  decl.value = parsed.walk(node => {
    if (node.type !== 'function' || node.value.toLowerCase() !== 'url' || !node.nodes.length) {
      return;
    }

    let {
      value,
      quote
    } = node.nodes[0];
    let optimizedValue;

    try {
      if (dataURIBase64.test(value)) {
        const url = new URL(value);
        const base64String = `${url.protocol}${url.pathname}`.replace(dataURI, '');
        const svg = Buffer.from(base64String, 'base64').toString('utf8');
        const {
          result
        } = minifySVG(svg, opts);
        const data = Buffer.from(result).toString('base64');
        optimizedValue = 'data:image/svg+xml;base64,' + data + url.hash;
      } else if (dataURI.test(value)) {
        const svg = value.replace(dataURI, '');
        const {
          result,
          isUriEncoded
        } = minifySVG(svg, opts);
        let data = isUriEncoded ? (0, _url.encode)(result) : result; // Should always encode # otherwise we yield a broken SVG
        // in Firefox (works in Chrome however). See this issue:
        // https://github.com/cssnano/cssnano/issues/245

        data = data.replace(/#/g, '%23');
        optimizedValue = 'data:image/svg+xml;charset=utf-8,' + data;
        quote = isUriEncoded ? '"' : "'";
      } else {
        return;
      }
    } catch (error) {
      decl.warn(postcssResult, `${error}`);
      return;
    }

    node.nodes[0] = Object.assign({}, node.nodes[0], {
      value: optimizedValue,
      quote: quote,
      type: 'string',
      before: '',
      after: ''
    });
    return false;
  });
  decl.value = decl.value.toString();
}

function pluginCreator(opts = {}) {
  return {
    postcssPlugin: PLUGIN,

    OnceExit(css, {
      result
    }) {
      css.walkDecls(decl => {
        if (!dataURI.test(decl.value)) {
          return;
        }

        minify(decl, opts, result);
      });
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 26370:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.encode = encode;
exports.decode = void 0;

function encode(data) {
  return data.replace(/"/g, "'").replace(/%/g, '%25').replace(/</g, '%3C').replace(/>/g, '%3E').replace(/&/g, '%26').replace(/#/g, '%23').replace(/\s+/g, ' ');
}

const decode = decodeURIComponent;
exports.decode = decode;

/***/ }),

/***/ 17998:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _alphanumSort = _interopRequireDefault(__nccwpck_require__(37910));

var _uniqs = _interopRequireDefault(__nccwpck_require__(53260));

var _postcssSelectorParser = _interopRequireDefault(__nccwpck_require__(32997));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parseSelectors(selectors, callback) {
  return (0, _postcssSelectorParser.default)(callback).processSync(selectors);
}

function unique(rule) {
  rule.selector = (0, _alphanumSort.default)((0, _uniqs.default)(rule.selectors), {
    insensitive: true
  }).join();
}

function pluginCreator() {
  return {
    postcssPlugin: 'postcss-unique-selectors',

    OnceExit(css) {
      css.walkRules(nodes => {
        let comments = [];
        nodes.selector = parseSelectors(nodes.selector, selNode => {
          selNode.walk(sel => {
            if (sel.type === 'comment') {
              comments.push(sel.value);
              sel.remove();
              return;
            } else {
              return sel;
            }
          });
        });
        unique(nodes);
        nodes.selectors = nodes.selectors.concat(comments);
      });
    }

  };
}

pluginCreator.postcss = true;
var _default = pluginCreator;
exports.default = _default;
module.exports = exports.default;

/***/ }),

/***/ 19285:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var parse = __nccwpck_require__(75920);
var walk = __nccwpck_require__(69987);
var stringify = __nccwpck_require__(27952);

function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse(value);
    return this;
  }
  return new ValueParser(value);
}

ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};

ValueParser.prototype.walk = function(cb, bubble) {
  walk(this.nodes, cb, bubble);
  return this;
};

ValueParser.unit = __nccwpck_require__(45148);

ValueParser.walk = walk;

ValueParser.stringify = stringify;

module.exports = ValueParser;


/***/ }),

/***/ 75920:
/***/ ((module) => {

var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var uLower = "u".charCodeAt(0);
var uUpper = "U".charCodeAt(0);
var plus = "+".charCodeAt(0);
var isUnicodeRange = /^[a-f0-9?-]+$/i;

module.exports = function(input) {
  var tokens = [];
  var value = input;

  var next,
    quote,
    prev,
    token,
    escape,
    escapePos,
    whitespacePos,
    parenthesesOpenPos;
  var pos = 0;
  var code = value.charCodeAt(pos);
  var max = value.length;
  var stack = [{ nodes: tokens }];
  var balanced = 0;
  var parent;

  var name = "";
  var before = "";
  var after = "";

  while (pos < max) {
    // Whitespaces
    if (code <= 32) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = value.slice(pos, next);

      prev = tokens[tokens.length - 1];
      if (code === closeParentheses && balanced) {
        after = token;
      } else if (prev && prev.type === "div") {
        prev.after = token;
      } else if (
        code === comma ||
        code === colon ||
        (code === slash &&
          value.charCodeAt(next + 1) !== star &&
          (!parent ||
            (parent && parent.type === "function" && parent.value !== "calc")))
      ) {
        before = token;
      } else {
        tokens.push({
          type: "space",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;

      // Quotes
    } else if (code === singleQuote || code === doubleQuote) {
      next = pos;
      quote = code === singleQuote ? "'" : '"';
      token = {
        type: "string",
        sourceIndex: pos,
        quote: quote
      };
      do {
        escape = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape = !escape;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token.unclosed = true;
        }
      } while (escape);
      token.value = value.slice(pos + 1, next);

      tokens.push(token);
      pos = next + 1;
      code = value.charCodeAt(pos);

      // Comments
    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
      token = {
        type: "comment",
        sourceIndex: pos
      };

      next = value.indexOf("*/", pos);
      if (next === -1) {
        token.unclosed = true;
        next = value.length;
      }

      token.value = value.slice(pos + 2, next);
      tokens.push(token);

      pos = next + 2;
      code = value.charCodeAt(pos);

      // Operation within calc
    } else if (
      (code === slash || code === star) &&
      parent &&
      parent.type === "function" &&
      parent.value === "calc"
    ) {
      token = value[pos];
      tokens.push({
        type: "word",
        sourceIndex: pos - before.length,
        value: token
      });
      pos += 1;
      code = value.charCodeAt(pos);

      // Dividers
    } else if (code === slash || code === comma || code === colon) {
      token = value[pos];

      tokens.push({
        type: "div",
        sourceIndex: pos - before.length,
        value: token,
        before: before,
        after: ""
      });
      before = "";

      pos += 1;
      code = value.charCodeAt(pos);

      // Open parentheses
    } else if (openParentheses === code) {
      // Whitespaces after open parentheses
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      parenthesesOpenPos = pos;
      token = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(parenthesesOpenPos + 1, next)
      };
      pos = next;

      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
        next -= 1;
        do {
          escape = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        // Whitespaces before closed
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code = value.charCodeAt(whitespacePos);
        } while (code <= 32);
        if (parenthesesOpenPos < whitespacePos) {
          if (pos !== whitespacePos + 1) {
            token.nodes = [
              {
                type: "word",
                sourceIndex: pos,
                value: value.slice(pos, whitespacePos + 1)
              }
            ];
          } else {
            token.nodes = [];
          }
          if (token.unclosed && whitespacePos + 1 !== next) {
            token.after = "";
            token.nodes.push({
              type: "space",
              sourceIndex: whitespacePos + 1,
              value: value.slice(whitespacePos + 1, next)
            });
          } else {
            token.after = value.slice(whitespacePos + 1, next);
          }
        } else {
          token.after = "";
          token.nodes = [];
        }
        pos = next + 1;
        code = value.charCodeAt(pos);
        tokens.push(token);
      } else {
        balanced += 1;
        token.after = "";
        tokens.push(token);
        stack.push(token);
        tokens = token.nodes = [];
        parent = token;
      }
      name = "";

      // Close parentheses
    } else if (closeParentheses === code && balanced) {
      pos += 1;
      code = value.charCodeAt(pos);

      parent.after = after;
      after = "";
      balanced -= 1;
      stack.pop();
      parent = stack[balanced];
      tokens = parent.nodes;

      // Words
    } else {
      next = pos;
      do {
        if (code === backslash) {
          next += 1;
        }
        next += 1;
        code = value.charCodeAt(next);
      } while (
        next < max &&
        !(
          code <= 32 ||
          code === singleQuote ||
          code === doubleQuote ||
          code === comma ||
          code === colon ||
          code === slash ||
          code === openParentheses ||
          (code === star &&
            parent &&
            parent.type === "function" &&
            parent.value === "calc") ||
          (code === slash &&
            parent.type === "function" &&
            parent.value === "calc") ||
          (code === closeParentheses && balanced)
        )
      );
      token = value.slice(pos, next);

      if (openParentheses === code) {
        name = token;
      } else if (
        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&
        plus === token.charCodeAt(1) &&
        isUnicodeRange.test(token.slice(2))
      ) {
        tokens.push({
          type: "unicode-range",
          sourceIndex: pos,
          value: token
        });
      } else {
        tokens.push({
          type: "word",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;
    }
  }

  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
  }

  return stack[0].nodes;
};


/***/ }),

/***/ 27952:
/***/ ((module) => {

function stringifyNode(node, custom) {
  var type = node.type;
  var value = node.value;
  var buf;
  var customResult;

  if (custom && (customResult = custom(node)) !== undefined) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value;
  } else if (type === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify(node.nodes, custom);
    if (type !== "function") {
      return buf;
    }
    return (
      value +
      "(" +
      (node.before || "") +
      buf +
      (node.after || "") +
      (node.unclosed ? "" : ")")
    );
  }
  return value;
}

function stringify(nodes, custom) {
  var result, i;

  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}

module.exports = stringify;


/***/ }),

/***/ 45148:
/***/ ((module) => {

var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);

// Check if three code points would start a number
// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
function likeNumber(value) {
  var code = value.charCodeAt(0);
  var nextCode;

  if (code === plus || code === minus) {
    nextCode = value.charCodeAt(1);

    if (nextCode >= 48 && nextCode <= 57) {
      return true;
    }

    var nextNextCode = value.charCodeAt(2);

    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
      return true;
    }

    return false;
  }

  if (code === dot) {
    nextCode = value.charCodeAt(1);

    if (nextCode >= 48 && nextCode <= 57) {
      return true;
    }

    return false;
  }

  if (code >= 48 && code <= 57) {
    return true;
  }

  return false;
}

// Consume a number
// https://www.w3.org/TR/css-syntax-3/#consume-number
module.exports = function(value) {
  var pos = 0;
  var length = value.length;
  var code;
  var nextCode;
  var nextNextCode;

  if (length === 0 || !likeNumber(value)) {
    return false;
  }

  code = value.charCodeAt(pos);

  if (code === plus || code === minus) {
    pos++;
  }

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code < 48 || code > 57) {
      break;
    }

    pos += 1;
  }

  code = value.charCodeAt(pos);
  nextCode = value.charCodeAt(pos + 1);

  if (code === dot && nextCode >= 48 && nextCode <= 57) {
    pos += 2;

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }
  }

  code = value.charCodeAt(pos);
  nextCode = value.charCodeAt(pos + 1);
  nextNextCode = value.charCodeAt(pos + 2);

  if (
    (code === exp || code === EXP) &&
    ((nextCode >= 48 && nextCode <= 57) ||
      ((nextCode === plus || nextCode === minus) &&
        nextNextCode >= 48 &&
        nextNextCode <= 57))
  ) {
    pos += nextCode === plus || nextCode === minus ? 3 : 2;

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }
  }

  return {
    number: value.slice(0, pos),
    unit: value.slice(pos)
  };
};


/***/ }),

/***/ 69987:
/***/ ((module) => {

module.exports = function walk(nodes, cb, bubble) {
  var i, max, node, result;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];
    if (!bubble) {
      result = cb(node, i, nodes);
    }

    if (
      result !== false &&
      node.type === "function" &&
      Array.isArray(node.nodes)
    ) {
      walk(node.nodes, cb, bubble);
    }

    if (bubble) {
      cb(node, i, nodes);
    }
  }
};


/***/ }),

/***/ 54193:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Container = __nccwpck_require__(56919)

class AtRule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'atrule'
  }

  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.append(...children)
  }

  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.prepend(...children)
  }
}

module.exports = AtRule
AtRule.default = AtRule

Container.registerAtRule(AtRule)


/***/ }),

/***/ 37592:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Node = __nccwpck_require__(48557)

class Comment extends Node {
  constructor(defaults) {
    super(defaults)
    this.type = 'comment'
  }
}

module.exports = Comment
Comment.default = Comment


/***/ }),

/***/ 56919:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let { isClean, my } = __nccwpck_require__(32594)
let Declaration = __nccwpck_require__(33522)
let Comment = __nccwpck_require__(37592)
let Node = __nccwpck_require__(48557)

let parse, Rule, AtRule

function cleanSource(nodes) {
  return nodes.map(i => {
    if (i.nodes) i.nodes = cleanSource(i.nodes)
    delete i.source
    return i
  })
}

function markDirtyUp(node) {
  node[isClean] = false
  if (node.proxyOf.nodes) {
    for (let i of node.proxyOf.nodes) {
      markDirtyUp(i)
    }
  }
}

class Container extends Node {
  push(child) {
    child.parent = this
    this.proxyOf.nodes.push(child)
    return this
  }

  each(callback) {
    if (!this.proxyOf.nodes) return undefined
    let iterator = this.getIterator()

    let index, result
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index = this.indexes[iterator]
      result = callback(this.proxyOf.nodes[index], index)
      if (result === false) break

      this.indexes[iterator] += 1
    }

    delete this.indexes[iterator]
    return result
  }

  walk(callback) {
    return this.each((child, i) => {
      let result
      try {
        result = callback(child, i)
      } catch (e) {
        throw child.addToError(e)
      }
      if (result !== false && child.walk) {
        result = child.walk(callback)
      }

      return result
    })
  }

  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop
      return this.walk((child, i) => {
        if (child.type === 'decl') {
          return callback(child, i)
        }
      })
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i)
      }
    })
  }

  walkRules(selector, callback) {
    if (!callback) {
      callback = selector

      return this.walk((child, i) => {
        if (child.type === 'rule') {
          return callback(child, i)
        }
      })
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i)
      }
    })
  }

  walkAtRules(name, callback) {
    if (!callback) {
      callback = name
      return this.walk((child, i) => {
        if (child.type === 'atrule') {
          return callback(child, i)
        }
      })
    }
    if (name instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i)
      }
    })
  }

  walkComments(callback) {
    return this.walk((child, i) => {
      if (child.type === 'comment') {
        return callback(child, i)
      }
    })
  }

  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last)
      for (let node of nodes) this.proxyOf.nodes.push(node)
    }

    this.markDirty()

    return this
  }

  prepend(...children) {
    children = children.reverse()
    for (let child of children) {
      let nodes = this.normalize(child, this.first, 'prepend').reverse()
      for (let node of nodes) this.proxyOf.nodes.unshift(node)
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween)
    if (this.nodes) {
      for (let node of this.nodes) node.cleanRaws(keepBetween)
    }
  }

  insertBefore(exist, add) {
    exist = this.index(exist)

    let type = exist === 0 ? 'prepend' : false
    let nodes = this.normalize(add, this.proxyOf.nodes[exist], type).reverse()
    for (le